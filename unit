#!/usr/bin/env ruby

load 'ppp'

require 'fileutils'
require 'test/unit'

class Unit < Test::Unit::TestCase

  def compile(f)
    b=stem(f)
    cmd="#{@fc} -o #{b} #{f}"
    stat,out=docmd(cmd)
    puts out unless stat
    assert(stat,"Failed: #{cmd}")
    b
  end

  def translate(f)
    t="#{stem(f)}_ppp#{File.extname(f)}"
    cmd="./ppp #{f} > #{t}"
    stat,out=docmd(cmd)
    puts out unless stat
    assert(stat,"Failed: #{cmd}")
    t
  end

  def docmd(cmd)
    out=IO.popen(cmd+' 2>&1') { |x| x.readlines.reduce('') { |s,e| s+=e } }
    [($?.exitstatus==0)?(true):(false),out]
  end
  
  def exe(bin)
    cmd=bin
    stat,out=docmd(cmd)
    assert(stat,"Failed: #{cmd}")
    out
  end

  def setup
    @fc="gfortran -pedantic -std=f95"
    @tests=Dir.glob("tests/*").find_all { |e| e=~/t#{'.'*4}\.f90/ }
  end

  def stem(f)
    f.chomp(File.extname(f))
  end

  def teardown
    items=[]
    @tests.each { |e| items << stem(e) }
    @tests.each { |e| items << "#{stem(e)}_ppp" }
    @tests.each { |e| items << "#{stem(e)}_ppp#{File.extname(e)}" }
    FileUtils.rm_f(items)
  end

  def test_parser
    @tests.each do |s|
      bin_c=compile(s)
      out_c=exe(bin_c)
      t=translate(s)
      bin_e=compile(t)
      out_e=exe(bin_e)
      assert_equal(out_c,out_e)
    end
  end

end

# Run-time generation of test_* methods possible? Otherwise, just one test...
