# Autogenerated from a Treetop grammar. Edits may be lost.


module Fortran
  include Treetop::Runtime

  def root
    @root ||= :ac_do_variable
  end

  def _nt_ac_do_variable
    start_index = index
    if node_cache[:ac_do_variable].has_key?(index)
      cached = node_cache[:ac_do_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_variable

    node_cache[:ac_do_variable][start_index] = r0

    r0
  end

  module AcImpliedDo0
    def t_paren_l
      elements[0]
    end

    def ac_value_list
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def ac_implied_do_control
      elements[3]
    end

    def t_paren_r
      elements[4]
    end
  end

  def _nt_ac_implied_do
    start_index = index
    if node_cache[:ac_implied_do].has_key?(index)
      cached = node_cache[:ac_implied_do][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_ac_value_list
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_ac_implied_do_control
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(AcImpliedDo0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:ac_implied_do][start_index] = r0

    r0
  end

  module AcImpliedDoControl0
    def t_comma
      elements[0]
    end

    def scalar_int_expr
      elements[1]
    end
  end

  module AcImpliedDoControl1
    def ac_do_variable
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_int_expr
      elements[2]
    end

  end

  def _nt_ac_implied_do_control
    start_index = index
    if node_cache[:ac_implied_do_control].has_key?(index)
      cached = node_cache[:ac_implied_do_control][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_ac_do_variable
    s0 << r1
    if r1
      r2 = _nt_t_equal
      s0 << r2
      if r2
        r3 = _nt_scalar_int_expr
        s0 << r3
        if r3
          i5, s5 = index, []
          r6 = _nt_t_comma
          s5 << r6
          if r6
            r7 = _nt_scalar_int_expr
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(AcImpliedDoControl0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            r4 = r5
          else
            r4 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(AC_Implied_Do_Control,input, i0...index, s0)
      r0.extend(AcImpliedDoControl1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:ac_implied_do_control][start_index] = r0

    r0
  end

  module AcValue0
    def expr
      elements[0]
    end

  end

  def _nt_ac_value
    start_index = index
    if node_cache[:ac_value].has_key?(index)
      cached = node_cache[:ac_value][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_ac_implied_do
    if r1
      r0 = r1
    else
      i2, s2 = index, []
      r3 = _nt_expr
      s2 << r3
      if r3
        i4 = index
        r5 = _nt_t_equal
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(E,input, i2...index, s2)
        r2.extend(AcValue0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:ac_value][start_index] = r0

    r0
  end

  module AcValueList0
    def t_comma
      elements[0]
    end

    def ac_value
      elements[1]
    end
  end

  module AcValueList1
    def ac_value
      elements[0]
    end

  end

  def _nt_ac_value_list
    start_index = index
    if node_cache[:ac_value_list].has_key?(index)
      cached = node_cache[:ac_value_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_ac_value
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_ac_value
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(AcValueList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(AC_Value_List,input, i0...index, s0)
      r0.extend(AcValueList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:ac_value_list][start_index] = r0

    r0
  end

  def _nt_access_id
    start_index = index
    if node_cache[:access_id].has_key?(index)
      cached = node_cache[:access_id][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_use_name
    if r1
      r0 = r1
    else
      r2 = _nt_generic_spec
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:access_id][start_index] = r0

    r0
  end

  module AccessIdList0
    def access_id
      elements[0]
    end

  end

  def _nt_access_id_list
    start_index = index
    if node_cache[:access_id_list].has_key?(index)
      cached = node_cache[:access_id_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_access_id
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_access_id_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Access_Id_List,input, i0...index, s0)
      r0.extend(AccessIdList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:access_id_list][start_index] = r0

    r0
  end

  module AccessIdPair0
    def t_comma
      elements[0]
    end

    def access_id
      elements[1]
    end
  end

  def _nt_access_id_pair
    start_index = index
    if node_cache[:access_id_pair].has_key?(index)
      cached = node_cache[:access_id_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_access_id
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Access_Id_List_Pair,input, i0...index, s0)
      r0.extend(AccessIdPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:access_id_pair][start_index] = r0

    r0
  end

  def _nt_access_spec
    start_index = index
    if node_cache[:access_spec].has_key?(index)
      cached = node_cache[:access_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_public
    if r1
      r0 = r1
    else
      r2 = _nt_t_private
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:access_spec][start_index] = r0

    r0
  end

  module AccessStmt0
    def label
      elements[0]
    end

    def access_spec
      elements[1]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_access_stmt
    start_index = index
    if node_cache[:access_stmt].has_key?(index)
      cached = node_cache[:access_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_access_spec
      s0 << r3
      if r3
        r5 = _nt_access_stmt_option
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
          if r6
            i7 = index
            r8 = lambda { |e| sp_access_stmt(e[1],e[2]) }.call(s0)
            if r8
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            else
              r7 = nil
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Access_Stmt,input, i0...index, s0)
      r0.extend(AccessStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:access_stmt][start_index] = r0

    r0
  end

  module AccessStmtOption0
    def access_id_list
      elements[1]
    end
  end

  def _nt_access_stmt_option
    start_index = index
    if node_cache[:access_stmt_option].has_key?(index)
      cached = node_cache[:access_stmt_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_double_colon
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_access_id_list
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(Access_Stmt_Option,input, i0...index, s0)
      r0.extend(AccessStmtOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:access_stmt_option][start_index] = r0

    r0
  end

  def _nt_action_stmt
    start_index = index
    if node_cache[:action_stmt].has_key?(index)
      cached = node_cache[:action_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_allocate_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_assignment_stmt
      if r2
        r0 = r2
      else
        r3 = _nt_backspace_stmt
        if r3
          r0 = r3
        else
          r4 = _nt_call_stmt
          if r4
            r0 = r4
          else
            r5 = _nt_close_stmt
            if r5
              r0 = r5
            else
              r6 = _nt_computed_goto_stmt
              if r6
                r0 = r6
              else
                r7 = _nt_continue_stmt
                if r7
                  r0 = r7
                else
                  r8 = _nt_cycle_stmt
                  if r8
                    r0 = r8
                  else
                    r9 = _nt_deallocate_stmt
                    if r9
                      r0 = r9
                    else
                      r10 = _nt_endfile_stmt
                      if r10
                        r0 = r10
                      else
                        r11 = _nt_end_function_stmt
                        if r11
                          r0 = r11
                        else
                          r12 = _nt_end_program_stmt
                          if r12
                            r0 = r12
                          else
                            r13 = _nt_end_subroutine_stmt
                            if r13
                              r0 = r13
                            else
                              r14 = _nt_exit_stmt
                              if r14
                                r0 = r14
                              else
                                r15 = _nt_goto_stmt
                                if r15
                                  r0 = r15
                                else
                                  r16 = _nt_if_stmt
                                  if r16
                                    r0 = r16
                                  else
                                    r17 = _nt_inquire_stmt
                                    if r17
                                      r0 = r17
                                    else
                                      r18 = _nt_nullify_stmt
                                      if r18
                                        r0 = r18
                                      else
                                        r19 = _nt_open_stmt
                                        if r19
                                          r0 = r19
                                        else
                                          r20 = _nt_pointer_assignment_stmt
                                          if r20
                                            r0 = r20
                                          else
                                            r21 = _nt_print_stmt
                                            if r21
                                              r0 = r21
                                            else
                                              r22 = _nt_read_stmt
                                              if r22
                                                r0 = r22
                                              else
                                                r23 = _nt_return_stmt
                                                if r23
                                                  r0 = r23
                                                else
                                                  r24 = _nt_rewind_stmt
                                                  if r24
                                                    r0 = r24
                                                  else
                                                    r25 = _nt_stop_stmt
                                                    if r25
                                                      r0 = r25
                                                    else
                                                      r26 = _nt_where_stmt
                                                      if r26
                                                        r0 = r26
                                                      else
                                                        r27 = _nt_write_stmt
                                                        if r27
                                                          r0 = r27
                                                        else
                                                          r28 = _nt_arithmetic_if_stmt
                                                          if r28
                                                            r0 = r28
                                                          else
                                                            r29 = _nt_assign_stmt
                                                            if r29
                                                              r0 = r29
                                                            else
                                                              r30 = _nt_assigned_goto_stmt
                                                              if r30
                                                                r0 = r30
                                                              else
                                                                r31 = _nt_pause_stmt
                                                                if r31
                                                                  r0 = r31
                                                                else
                                                                  @index = i0
                                                                  r0 = nil
                                                                end
                                                              end
                                                            end
                                                          end
                                                        end
                                                      end
                                                    end
                                                  end
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:action_stmt][start_index] = r0

    r0
  end

  module ActionTermDoConstruct0
    def label_do_stmt
      elements[0]
    end

    def do_body
      elements[2]
    end

    def do_term_action_stmt
      elements[3]
    end
  end

  def _nt_action_term_do_construct
    start_index = index
    if node_cache[:action_term_do_construct].has_key?(index)
      cached = node_cache[:action_term_do_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_label_do_stmt
    s0 << r1
    if r1
      i2 = index
      r3 = lambda { |e| dolabel_dupe? }.call(s0)
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_do_body
        s0 << r4
        if r4
          r5 = _nt_do_term_action_stmt
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ActionTermDoConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:action_term_do_construct][start_index] = r0

    r0
  end

  def _nt_actual_arg
    start_index = index
    if node_cache[:actual_arg].has_key?(index)
      cached = node_cache[:actual_arg][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_expr
    if r1
      r0 = r1
    else
      r2 = _nt_variable
      if r2
        r0 = r2
      else
        r3 = _nt_procedure_name
        if r3
          r0 = r3
        else
          r4 = _nt_alt_return_spec
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:actual_arg][start_index] = r0

    r0
  end

  module ActualArgSpec0
    def keyword_option
      elements[0]
    end

    def actual_arg
      elements[1]
    end
  end

  def _nt_actual_arg_spec
    start_index = index
    if node_cache[:actual_arg_spec].has_key?(index)
      cached = node_cache[:actual_arg_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_keyword_option
    s0 << r1
    if r1
      r2 = _nt_actual_arg
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ActualArgSpec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:actual_arg_spec][start_index] = r0

    r0
  end

  module ActualArgSpecList0
    def t_comma
      elements[0]
    end

    def actual_arg_spec
      elements[1]
    end
  end

  module ActualArgSpecList1
    def actual_arg_spec
      elements[0]
    end

  end

  def _nt_actual_arg_spec_list
    start_index = index
    if node_cache[:actual_arg_spec_list].has_key?(index)
      cached = node_cache[:actual_arg_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_actual_arg_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_actual_arg_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(ActualArgSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Actual_Arg_Spec_List,input, i0...index, s0)
      r0.extend(ActualArgSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:actual_arg_spec_list][start_index] = r0

    r0
  end

  def _nt_add_op
    start_index = index
    if node_cache[:add_op].has_key?(index)
      cached = node_cache[:add_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_plus
    if r1
      r0 = r1
    else
      r2 = _nt_t_minus
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:add_op][start_index] = r0

    r0
  end

  module AddOperand0
    def mult_op
      elements[0]
    end

    def add_operand
      elements[1]
    end
  end

  module AddOperand1
    def mult_operand
      elements[0]
    end

  end

  def _nt_add_operand
    start_index = index
    if node_cache[:add_operand].has_key?(index)
      cached = node_cache[:add_operand][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_mult_operand
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_mult_op
      s3 << r4
      if r4
        r5 = _nt_add_operand
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(AddOperand0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Add_Operand,input, i0...index, s0)
      r0.extend(AddOperand1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:add_operand][start_index] = r0

    r0
  end

  def _nt_and_op
    start_index = index
    if node_cache[:and_op].has_key?(index)
      cached = node_cache[:and_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(".and.", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure(".and.")
      r0 = nil
    end

    node_cache[:and_op][start_index] = r0

    r0
  end

  module AllocatableStmt0
    def label
      elements[0]
    end

    def t_allocatable
      elements[1]
    end

    def array_names_and_deferred_shape_spec_lists
      elements[3]
    end

    def t_newline
      elements[4]
    end

  end

  def _nt_allocatable_stmt
    start_index = index
    if node_cache[:allocatable_stmt].has_key?(index)
      cached = node_cache[:allocatable_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_allocatable
      s0 << r3
      if r3
        r5 = _nt_double_colon
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_array_names_and_deferred_shape_spec_lists
          s0 << r6
          if r6
            r7 = _nt_t_newline
            s0 << r7
            if r7
              i8 = index
              r9 = lambda { |e| sp_allocatable_stmt(e[3]) }.call(s0)
              if r9
                @index = i8
                r8 = instantiate_node(SyntaxNode,input, index...index)
              else
                r8 = nil
              end
              s0 << r8
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Allocatable_Stmt,input, i0...index, s0)
      r0.extend(AllocatableStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:allocatable_stmt][start_index] = r0

    r0
  end

  def _nt_allocate_lower_bound
    start_index = index
    if node_cache[:allocate_lower_bound].has_key?(index)
      cached = node_cache[:allocate_lower_bound][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_expr

    node_cache[:allocate_lower_bound][start_index] = r0

    r0
  end

  module AllocateObject0
    def t_stat
      elements[0]
    end

    def t_equal
      elements[1]
    end
  end

  module AllocateObject1
    def structure_component
      elements[1]
    end
  end

  module AllocateObject2
    def t_stat
      elements[0]
    end

    def t_equal
      elements[1]
    end
  end

  module AllocateObject3
    def variable_name
      elements[1]
    end
  end

  def _nt_allocate_object
    start_index = index
    if node_cache[:allocate_object].has_key?(index)
      cached = node_cache[:allocate_object][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    i2 = index
    i3, s3 = index, []
    r4 = _nt_t_stat
    s3 << r4
    if r4
      r5 = _nt_t_equal
      s3 << r5
    end
    if s3.last
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      r3.extend(AllocateObject0)
    else
      @index = i3
      r3 = nil
    end
    if r3
      r2 = nil
    else
      @index = i2
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r6 = _nt_structure_component
      s1 << r6
    end
    if s1.last
      r1 = instantiate_node(Allocate_Object,input, i1...index, s1)
      r1.extend(AllocateObject1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i7, s7 = index, []
      i8 = index
      i9, s9 = index, []
      r10 = _nt_t_stat
      s9 << r10
      if r10
        r11 = _nt_t_equal
        s9 << r11
      end
      if s9.last
        r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
        r9.extend(AllocateObject2)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r8 = nil
      else
        @index = i8
        r8 = instantiate_node(SyntaxNode,input, index...index)
      end
      s7 << r8
      if r8
        r12 = _nt_variable_name
        s7 << r12
      end
      if s7.last
        r7 = instantiate_node(Allocate_Object,input, i7...index, s7)
        r7.extend(AllocateObject3)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r0 = r7
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:allocate_object][start_index] = r0

    r0
  end

  module AllocateObjectList0
    def t_comma
      elements[0]
    end

    def allocate_object
      elements[1]
    end
  end

  module AllocateObjectList1
    def allocate_object
      elements[0]
    end

  end

  def _nt_allocate_object_list
    start_index = index
    if node_cache[:allocate_object_list].has_key?(index)
      cached = node_cache[:allocate_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_allocate_object
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_allocate_object
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(AllocateObjectList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Allocate_Object_List,input, i0...index, s0)
      r0.extend(AllocateObjectList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:allocate_object_list][start_index] = r0

    r0
  end

  module AllocateShapeSpec0
    def allocate_lower_bound
      elements[0]
    end

    def t_colon
      elements[1]
    end
  end

  module AllocateShapeSpec1
    def allocate_upper_bound
      elements[1]
    end
  end

  def _nt_allocate_shape_spec
    start_index = index
    if node_cache[:allocate_shape_spec].has_key?(index)
      cached = node_cache[:allocate_shape_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i2, s2 = index, []
    r3 = _nt_allocate_lower_bound
    s2 << r3
    if r3
      r4 = _nt_t_colon
      s2 << r4
    end
    if s2.last
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      r2.extend(AllocateShapeSpec0)
    else
      @index = i2
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r5 = _nt_allocate_upper_bound
      s0 << r5
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(AllocateShapeSpec1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:allocate_shape_spec][start_index] = r0

    r0
  end

  module AllocateShapeSpecList0
    def t_comma
      elements[0]
    end

    def allocate_shape_spec
      elements[1]
    end
  end

  module AllocateShapeSpecList1
    def allocate_shape_spec
      elements[0]
    end

  end

  def _nt_allocate_shape_spec_list
    start_index = index
    if node_cache[:allocate_shape_spec_list].has_key?(index)
      cached = node_cache[:allocate_shape_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_allocate_shape_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_allocate_shape_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(AllocateShapeSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Allocate_Shape_Spec_List,input, i0...index, s0)
      r0.extend(AllocateShapeSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:allocate_shape_spec_list][start_index] = r0

    r0
  end

  module AllocateStatConstruct0
    def t_comma
      elements[0]
    end

    def t_stat
      elements[1]
    end

    def t_equal
      elements[2]
    end

    def stat_variable
      elements[3]
    end
  end

  def _nt_allocate_stat_construct
    start_index = index
    if node_cache[:allocate_stat_construct].has_key?(index)
      cached = node_cache[:allocate_stat_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_t_stat
      s0 << r2
      if r2
        r3 = _nt_t_equal
        s0 << r3
        if r3
          r4 = _nt_stat_variable
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(AllocateStatConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:allocate_stat_construct][start_index] = r0

    r0
  end

  module AllocateStmt0
    def label
      elements[0]
    end

    def t_allocate
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def allocation_list
      elements[3]
    end

    def t_paren_r
      elements[5]
    end

    def t_newline
      elements[6]
    end
  end

  def _nt_allocate_stmt
    start_index = index
    if node_cache[:allocate_stmt].has_key?(index)
      cached = node_cache[:allocate_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_allocate
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_allocation_list
          s0 << r5
          if r5
            r7 = _nt_allocate_stat_construct
            if r7
              r6 = r7
            else
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r6
            if r6
              r8 = _nt_t_paren_r
              s0 << r8
              if r8
                r9 = _nt_t_newline
                s0 << r9
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Allocate_Stmt,input, i0...index, s0)
      r0.extend(AllocateStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:allocate_stmt][start_index] = r0

    r0
  end

  def _nt_allocate_upper_bound
    start_index = index
    if node_cache[:allocate_upper_bound].has_key?(index)
      cached = node_cache[:allocate_upper_bound][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_expr

    node_cache[:allocate_upper_bound][start_index] = r0

    r0
  end

  module Allocation0
    def allocate_object
      elements[0]
    end

  end

  def _nt_allocation
    start_index = index
    if node_cache[:allocation].has_key?(index)
      cached = node_cache[:allocation][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_allocate_object
    s0 << r1
    if r1
      r3 = _nt_parenthesized_allocate_shape_spec_list
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Allocation,input, i0...index, s0)
      r0.extend(Allocation0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:allocation][start_index] = r0

    r0
  end

  module AllocationList0
    def t_comma
      elements[0]
    end

    def allocation
      elements[1]
    end
  end

  module AllocationList1
    def allocation
      elements[0]
    end

  end

  def _nt_allocation_list
    start_index = index
    if node_cache[:allocation_list].has_key?(index)
      cached = node_cache[:allocation_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_allocation
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_allocation
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(AllocationList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Allocation_List,input, i0...index, s0)
      r0.extend(AllocationList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:allocation_list][start_index] = r0

    r0
  end

  def _nt_alphanumeric_character
    start_index = index
    if node_cache[:alphanumeric_character].has_key?(index)
      cached = node_cache[:alphanumeric_character][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_letter
    if r1
      r0 = r1
    else
      r2 = _nt_t_digit
      if r2
        r0 = r2
      else
        r3 = _nt_t_underscore
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:alphanumeric_character][start_index] = r0

    r0
  end

  module AltReturnSpec0
    def t_star
      elements[0]
    end

    def label
      elements[1]
    end
  end

  def _nt_alt_return_spec
    start_index = index
    if node_cache[:alt_return_spec].has_key?(index)
      cached = node_cache[:alt_return_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_star
    s0 << r1
    if r1
      r2 = _nt_label
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(AltReturnSpec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:alt_return_spec][start_index] = r0

    r0
  end

  module ArithmeticIfStmt0
    def label1
      elements[0]
    end

    def t_if
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def scalar_numeric_expr
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def label2
      elements[5]
    end

    def t_comma1
      elements[6]
    end

    def label3
      elements[7]
    end

    def t_comma2
      elements[8]
    end

    def label4
      elements[9]
    end

    def t_newline
      elements[10]
    end
  end

  def _nt_arithmetic_if_stmt
    start_index = index
    if node_cache[:arithmetic_if_stmt].has_key?(index)
      cached = node_cache[:arithmetic_if_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_if
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_scalar_numeric_expr
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r7 = _nt_label
              s0 << r7
              if r7
                r8 = _nt_t_comma
                s0 << r8
                if r8
                  r9 = _nt_label
                  s0 << r9
                  if r9
                    r10 = _nt_t_comma
                    s0 << r10
                    if r10
                      r11 = _nt_label
                      s0 << r11
                      if r11
                        r12 = _nt_t_newline
                        s0 << r12
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Arithmetic_If_Stmt,input, i0...index, s0)
      r0.extend(ArithmeticIfStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:arithmetic_if_stmt][start_index] = r0

    r0
  end

  module ArrayConstructor0
    def t_paren_l
      elements[0]
    end

    def t_slash1
      elements[1]
    end

    def ac_value_list
      elements[2]
    end

    def t_slash2
      elements[3]
    end

    def t_paren_r
      elements[4]
    end
  end

  def _nt_array_constructor
    start_index = index
    if node_cache[:array_constructor].has_key?(index)
      cached = node_cache[:array_constructor][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_t_slash
      s0 << r2
      if r2
        r3 = _nt_ac_value_list
        s0 << r3
        if r3
          r4 = _nt_t_slash
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ArrayConstructor0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:array_constructor][start_index] = r0

    r0
  end

  def _nt_array_element
    start_index = index
    if node_cache[:array_element].has_key?(index)
      cached = node_cache[:array_element][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_data_ref

    node_cache[:array_element][start_index] = r0

    r0
  end

  def _nt_array_name
    start_index = index
    if node_cache[:array_name].has_key?(index)
      cached = node_cache[:array_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:array_name][start_index] = r0

    r0
  end

  module ArrayNameAndDeferredShapeSpecList0
    def array_name
      elements[0]
    end

  end

  def _nt_array_name_and_deferred_shape_spec_list
    start_index = index
    if node_cache[:array_name_and_deferred_shape_spec_list].has_key?(index)
      cached = node_cache[:array_name_and_deferred_shape_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_array_name
    s0 << r1
    if r1
      r3 = _nt_parenthesized_deferred_shape_spec_list
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Array_Name_And_Deferred_Shape_Spec_List,input, i0...index, s0)
      r0.extend(ArrayNameAndDeferredShapeSpecList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:array_name_and_deferred_shape_spec_list][start_index] = r0

    r0
  end

  module ArrayNameAndDeferredShapeSpecListPair0
    def t_comma
      elements[0]
    end

    def array_name_and_deferred_shape_spec_list
      elements[1]
    end
  end

  def _nt_array_name_and_deferred_shape_spec_list_pair
    start_index = index
    if node_cache[:array_name_and_deferred_shape_spec_list_pair].has_key?(index)
      cached = node_cache[:array_name_and_deferred_shape_spec_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_array_name_and_deferred_shape_spec_list
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Array_Name_And_Deferred_Shape_Spec_List_Pair,input, i0...index, s0)
      r0.extend(ArrayNameAndDeferredShapeSpecListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:array_name_and_deferred_shape_spec_list_pair][start_index] = r0

    r0
  end

  module ArrayNamesAndDeferredShapeSpecLists0
    def array_name_and_deferred_shape_spec_list
      elements[0]
    end

  end

  def _nt_array_names_and_deferred_shape_spec_lists
    start_index = index
    if node_cache[:array_names_and_deferred_shape_spec_lists].has_key?(index)
      cached = node_cache[:array_names_and_deferred_shape_spec_lists][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_array_name_and_deferred_shape_spec_list
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_array_name_and_deferred_shape_spec_list_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Array_Names_And_Deferred_Shape_Spec_Lists,input, i0...index, s0)
      r0.extend(ArrayNamesAndDeferredShapeSpecLists0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:array_names_and_deferred_shape_spec_lists][start_index] = r0

    r0
  end

  module ArrayNameAndSpec0
    def array_name
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def array_spec
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_array_name_and_spec
    start_index = index
    if node_cache[:array_name_and_spec].has_key?(index)
      cached = node_cache[:array_name_and_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_array_name
    s0 << r1
    if r1
      r2 = _nt_t_paren_l
      s0 << r2
      if r2
        r3 = _nt_array_spec
        s0 << r3
        if r3
          r4 = _nt_t_paren_r
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Array_Name_And_Spec,input, i0...index, s0)
      r0.extend(ArrayNameAndSpec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:array_name_and_spec][start_index] = r0

    r0
  end

  module ArrayNameAndSpecPair0
    def t_comma
      elements[0]
    end

    def array_name_and_spec
      elements[1]
    end
  end

  def _nt_array_name_and_spec_pair
    start_index = index
    if node_cache[:array_name_and_spec_pair].has_key?(index)
      cached = node_cache[:array_name_and_spec_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_array_name_and_spec
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Array_Name_And_Spec_Pair,input, i0...index, s0)
      r0.extend(ArrayNameAndSpecPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:array_name_and_spec_pair][start_index] = r0

    r0
  end

  module ArrayNamesAndSpecs0
    def array_name_and_spec
      elements[0]
    end

  end

  def _nt_array_names_and_specs
    start_index = index
    if node_cache[:array_names_and_specs].has_key?(index)
      cached = node_cache[:array_names_and_specs][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_array_name_and_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_array_name_and_spec_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Array_Names_And_Specs,input, i0...index, s0)
      r0.extend(ArrayNamesAndSpecs0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:array_names_and_specs][start_index] = r0

    r0
  end

  module ArraySection0
    def data_ref
      elements[0]
    end

  end

  def _nt_array_section
    start_index = index
    if node_cache[:array_section].has_key?(index)
      cached = node_cache[:array_section][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_data_ref
    s0 << r1
    if r1
      i2 = index
      r3 = lambda { |e| sp_is_array?(e[0]) }.call(s0)
      if r3
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      else
        r2 = nil
      end
      s0 << r2
      if r2
        r5 = _nt_substring_range_triplet
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(Array_Section,input, i0...index, s0)
      r0.extend(ArraySection0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:array_section][start_index] = r0

    r0
  end

  module ArraySpec0
    def explicit_shape_spec_list
      elements[0]
    end

  end

  module ArraySpec1
    def assumed_shape_spec_list
      elements[0]
    end

  end

  module ArraySpec2
    def assumed_size_spec
      elements[0]
    end

  end

  def _nt_array_spec
    start_index = index
    if node_cache[:array_spec].has_key?(index)
      cached = node_cache[:array_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_explicit_shape_spec_list
    s1 << r2
    if r2
      if has_terminal?("", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure("")
        r3 = nil
      end
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(Array_Spec,input, i1...index, s1)
      r1.extend(ArraySpec0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i4, s4 = index, []
      r5 = _nt_assumed_shape_spec_list
      s4 << r5
      if r5
        if has_terminal?("", false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 0))
          @index += 0
        else
          terminal_parse_failure("")
          r6 = nil
        end
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(Array_Spec,input, i4...index, s4)
        r4.extend(ArraySpec1)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r0 = r4
      else
        i7, s7 = index, []
        r8 = _nt_assumed_size_spec
        s7 << r8
        if r8
          if has_terminal?("", false, index)
            r9 = instantiate_node(SyntaxNode,input, index...(index + 0))
            @index += 0
          else
            terminal_parse_failure("")
            r9 = nil
          end
          s7 << r9
        end
        if s7.last
          r7 = instantiate_node(Array_Spec,input, i7...index, s7)
          r7.extend(ArraySpec2)
        else
          @index = i7
          r7 = nil
        end
        if r7
          r0 = r7
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:array_spec][start_index] = r0

    r0
  end

  def _nt_array_variable_name
    start_index = index
    if node_cache[:array_variable_name].has_key?(index)
      cached = node_cache[:array_variable_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable_name

    node_cache[:array_variable_name][start_index] = r0

    r0
  end

  module AssignStmt0
    def label1
      elements[0]
    end

    def t_assign
      elements[1]
    end

    def label2
      elements[2]
    end

    def t_to
      elements[3]
    end

    def scalar_int_variable
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_assign_stmt
    start_index = index
    if node_cache[:assign_stmt].has_key?(index)
      cached = node_cache[:assign_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_assign
      s0 << r3
      if r3
        r4 = _nt_label
        s0 << r4
        if r4
          r5 = _nt_t_to
          s0 << r5
          if r5
            r6 = _nt_scalar_int_variable
            s0 << r6
            if r6
              r7 = _nt_t_newline
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(AssignStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assign_stmt][start_index] = r0

    r0
  end

  module AssignedGotoStmt0
    def label
      elements[0]
    end

    def t_goto
      elements[1]
    end

    def scalar_int_variable
      elements[2]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_assigned_goto_stmt
    start_index = index
    if node_cache[:assigned_goto_stmt].has_key?(index)
      cached = node_cache[:assigned_goto_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_goto
      s0 << r3
      if r3
        r4 = _nt_scalar_int_variable
        s0 << r4
        if r4
          r6 = _nt_assigned_goto_stmt_label_list
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Assigned_Goto_Stmt,input, i0...index, s0)
      r0.extend(AssignedGotoStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assigned_goto_stmt][start_index] = r0

    r0
  end

  module AssignedGotoStmtLabelList0
    def t_paren_l
      elements[1]
    end

    def label_list
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_assigned_goto_stmt_label_list
    start_index = index
    if node_cache[:assigned_goto_stmt_label_list].has_key?(index)
      cached = node_cache[:assigned_goto_stmt_label_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_t_comma
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_paren_l
      s0 << r3
      if r3
        r4 = _nt_label_list
        s0 << r4
        if r4
          r5 = _nt_t_paren_r
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(AssignedGotoStmtLabelList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assigned_goto_stmt_label_list][start_index] = r0

    r0
  end

  module AssignmentStmt0
    def label
      elements[0]
    end

    def variable
      elements[1]
    end

    def t_equal
      elements[2]
    end

    def expr
      elements[3]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_assignment_stmt
    start_index = index
    if node_cache[:assignment_stmt].has_key?(index)
      cached = node_cache[:assignment_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_variable
      s0 << r3
      if r3
        r4 = _nt_t_equal
        s0 << r4
        if r4
          r5 = _nt_expr
          s0 << r5
          if r5
            r6 = _nt_t_newline
            s0 << r6
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtC,input, i0...index, s0)
      r0.extend(AssignmentStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assignment_stmt][start_index] = r0

    r0
  end

  module AssumedShapeSpec0
    def t_colon
      elements[1]
    end
  end

  def _nt_assumed_shape_spec
    start_index = index
    if node_cache[:assumed_shape_spec].has_key?(index)
      cached = node_cache[:assumed_shape_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_lower_bound
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_colon
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(Assumed_Shape_Spec,input, i0...index, s0)
      r0.extend(AssumedShapeSpec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assumed_shape_spec][start_index] = r0

    r0
  end

  module AssumedShapeSpecList0
    def assumed_shape_spec
      elements[0]
    end

  end

  def _nt_assumed_shape_spec_list
    start_index = index
    if node_cache[:assumed_shape_spec_list].has_key?(index)
      cached = node_cache[:assumed_shape_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_assumed_shape_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_assumed_shape_spec_list_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Assumed_Shape_Spec_List,input, i0...index, s0)
      r0.extend(AssumedShapeSpecList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assumed_shape_spec_list][start_index] = r0

    r0
  end

  module AssumedShapeSpecListPair0
    def t_comma
      elements[0]
    end

    def assumed_shape_spec
      elements[1]
    end
  end

  def _nt_assumed_shape_spec_list_pair
    start_index = index
    if node_cache[:assumed_shape_spec_list_pair].has_key?(index)
      cached = node_cache[:assumed_shape_spec_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_assumed_shape_spec
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Assumed_Shape_Spec_List_Pair,input, i0...index, s0)
      r0.extend(AssumedShapeSpecListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assumed_shape_spec_list_pair][start_index] = r0

    r0
  end

  module AssumedSizeSpec0
    def t_star
      elements[2]
    end
  end

  def _nt_assumed_size_spec
    start_index = index
    if node_cache[:assumed_size_spec].has_key?(index)
      cached = node_cache[:assumed_size_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_assumed_size_spec_pair
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r4 = _nt_lower_bound_pair
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r5 = _nt_t_star
        s0 << r5
      end
    end
    if s0.last
      r0 = instantiate_node(Assumed_Size_Spec,input, i0...index, s0)
      r0.extend(AssumedSizeSpec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assumed_size_spec][start_index] = r0

    r0
  end

  module AssumedSizeSpecPair0
    def explicit_shape_spec_list
      elements[0]
    end

    def t_comma
      elements[1]
    end
  end

  def _nt_assumed_size_spec_pair
    start_index = index
    if node_cache[:assumed_size_spec_pair].has_key?(index)
      cached = node_cache[:assumed_size_spec_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_explicit_shape_spec_list
    s0 << r1
    if r1
      r2 = _nt_t_comma
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Assumed_Size_Spec_Pair,input, i0...index, s0)
      r0.extend(AssumedSizeSpecPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:assumed_size_spec_pair][start_index] = r0

    r0
  end

  module AttrSpec0
    def t_dimension
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def array_spec
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  module AttrSpec1
    def t_intent
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def intent_spec
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_attr_spec
    start_index = index
    if node_cache[:attr_spec].has_key?(index)
      cached = node_cache[:attr_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_parameter
    if r1
      r0 = r1
    else
      r2 = _nt_access_spec
      if r2
        r0 = r2
      else
        r3 = _nt_t_allocatable
        if r3
          r0 = r3
        else
          i4, s4 = index, []
          r5 = _nt_t_dimension
          s4 << r5
          if r5
            r6 = _nt_t_paren_l
            s4 << r6
            if r6
              r7 = _nt_array_spec
              s4 << r7
              if r7
                r8 = _nt_t_paren_r
                s4 << r8
              end
            end
          end
          if s4.last
            r4 = instantiate_node(Attr_Spec_Dimension,input, i4...index, s4)
            r4.extend(AttrSpec0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r0 = r4
          else
            r9 = _nt_t_external
            if r9
              r0 = r9
            else
              i10, s10 = index, []
              r11 = _nt_t_intent
              s10 << r11
              if r11
                r12 = _nt_t_paren_l
                s10 << r12
                if r12
                  r13 = _nt_intent_spec
                  s10 << r13
                  if r13
                    r14 = _nt_t_paren_r
                    s10 << r14
                  end
                end
              end
              if s10.last
                r10 = instantiate_node(T,input, i10...index, s10)
                r10.extend(AttrSpec1)
              else
                @index = i10
                r10 = nil
              end
              if r10
                r0 = r10
              else
                r15 = _nt_t_intrinsic
                if r15
                  r0 = r15
                else
                  r16 = _nt_t_optional
                  if r16
                    r0 = r16
                  else
                    r17 = _nt_t_pointer
                    if r17
                      r0 = r17
                    else
                      r18 = _nt_t_save
                      if r18
                        r0 = r18
                      else
                        r19 = _nt_t_target
                        if r19
                          r0 = r19
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:attr_spec][start_index] = r0

    r0
  end

  module AttrSpecList0
    def attr_spec
      elements[0]
    end

    def attr_spec_list_pairs
      elements[1]
    end
  end

  def _nt_attr_spec_list
    start_index = index
    if node_cache[:attr_spec_list].has_key?(index)
      cached = node_cache[:attr_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_attr_spec
    s0 << r1
    if r1
      r2 = _nt_attr_spec_list_pairs
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Attr_Spec_List,input, i0...index, s0)
      r0.extend(AttrSpecList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:attr_spec_list][start_index] = r0

    r0
  end

  module AttrSpecListPair0
    def t_comma
      elements[0]
    end

    def attr_spec
      elements[1]
    end
  end

  def _nt_attr_spec_list_pair
    start_index = index
    if node_cache[:attr_spec_list_pair].has_key?(index)
      cached = node_cache[:attr_spec_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_attr_spec
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Attr_Spec_List_Pair,input, i0...index, s0)
      r0.extend(AttrSpecListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:attr_spec_list_pair][start_index] = r0

    r0
  end

  def _nt_attr_spec_list_pairs
    start_index = index
    if node_cache[:attr_spec_list_pairs].has_key?(index)
      cached = node_cache[:attr_spec_list_pairs][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_attr_spec_list_pair
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(Attr_Spec_List_Pairs,input, i0...index, s0)

    node_cache[:attr_spec_list_pairs][start_index] = r0

    r0
  end

  module AttrSpecOption0
    def t_comma
      elements[0]
    end

    def attr_spec_list
      elements[1]
    end

    def double_colon
      elements[2]
    end
  end

  def _nt_attr_spec_option
    start_index = index
    if node_cache[:attr_spec_option].has_key?(index)
      cached = node_cache[:attr_spec_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_comma
    s1 << r2
    if r2
      r3 = _nt_attr_spec_list
      s1 << r3
      if r3
        r4 = _nt_double_colon
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(Attr_Spec_Option,input, i1...index, s1)
      r1.extend(AttrSpecOption0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r5 = _nt_double_colon
      if r5
        r0 = r5
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:attr_spec_option][start_index] = r0

    r0
  end

  module BackspaceStmt0
    def label
      elements[0]
    end

    def t_backspace
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def position_spec_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  module BackspaceStmt1
    def label
      elements[0]
    end

    def t_backspace
      elements[1]
    end

    def external_file_unit
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_backspace_stmt
    start_index = index
    if node_cache[:backspace_stmt].has_key?(index)
      cached = node_cache[:backspace_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_label
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r4 = _nt_t_backspace
      s1 << r4
      if r4
        r5 = _nt_t_paren_l
        s1 << r5
        if r5
          r6 = _nt_position_spec_list
          s1 << r6
          if r6
            r7 = _nt_t_paren_r
            s1 << r7
            if r7
              r8 = _nt_t_newline
              s1 << r8
            end
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(StmtC,input, i1...index, s1)
      r1.extend(BackspaceStmt0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i9, s9 = index, []
      r11 = _nt_label
      if r11
        r10 = r11
      else
        r10 = instantiate_node(SyntaxNode,input, index...index)
      end
      s9 << r10
      if r10
        r12 = _nt_t_backspace
        s9 << r12
        if r12
          r13 = _nt_external_file_unit
          s9 << r13
          if r13
            r14 = _nt_t_newline
            s9 << r14
          end
        end
      end
      if s9.last
        r9 = instantiate_node(StmtJ,input, i9...index, s9)
        r9.extend(BackspaceStmt1)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r0 = r9
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:backspace_stmt][start_index] = r0

    r0
  end

  module BinaryConstant0
    def t_apostrophe1
      elements[0]
    end

    def t_apostrophe2
      elements[2]
    end
  end

  module BinaryConstant1
    def t_quotemark1
      elements[0]
    end

    def t_quotemark2
      elements[2]
    end
  end

  module BinaryConstant2
  end

  def _nt_binary_constant
    start_index = index
    if node_cache[:binary_constant].has_key?(index)
      cached = node_cache[:binary_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("b", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("b")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      i3, s3 = index, []
      r4 = _nt_t_apostrophe
      s3 << r4
      if r4
        s5, i5 = [], index
        loop do
          r6 = _nt_t_binary
          if r6
            s5 << r6
          else
            break
          end
        end
        if s5.empty?
          @index = i5
          r5 = nil
        else
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        end
        s3 << r5
        if r5
          r7 = _nt_t_apostrophe
          s3 << r7
        end
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(BinaryConstant0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        i8, s8 = index, []
        r9 = _nt_t_quotemark
        s8 << r9
        if r9
          s10, i10 = [], index
          loop do
            r11 = _nt_t_binary
            if r11
              s10 << r11
            else
              break
            end
          end
          if s10.empty?
            @index = i10
            r10 = nil
          else
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
          end
          s8 << r10
          if r10
            r12 = _nt_t_quotemark
            s8 << r12
          end
        end
        if s8.last
          r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
          r8.extend(BinaryConstant1)
        else
          @index = i8
          r8 = nil
        end
        if r8
          r2 = r8
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(BinaryConstant2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:binary_constant][start_index] = r0

    r0
  end

  def _nt_block
    start_index = index
    if node_cache[:block].has_key?(index)
      cached = node_cache[:block][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_execution_part_construct

    node_cache[:block][start_index] = r0

    r0
  end

  module BlockData0
    def block_data_stmt
      elements[0]
    end

    def end_block_data_stmt
      elements[2]
    end
  end

  def _nt_block_data
    start_index = index
    if node_cache[:block_data].has_key?(index)
      cached = node_cache[:block_data][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_block_data_stmt
    s0 << r1
    if r1
      r3 = _nt_specification_part
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_end_block_data_stmt
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(Block_Data,input, i0...index, s0)
      r0.extend(BlockData0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:block_data][start_index] = r0

    r0
  end

  def _nt_block_data_name
    start_index = index
    if node_cache[:block_data_name].has_key?(index)
      cached = node_cache[:block_data_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:block_data_name][start_index] = r0

    r0
  end

  module BlockDataStmt0
    def label
      elements[0]
    end

    def t_block
      elements[1]
    end

    def t_data
      elements[2]
    end

    def t_newline
      elements[4]
    end

  end

  def _nt_block_data_stmt
    start_index = index
    if node_cache[:block_data_stmt].has_key?(index)
      cached = node_cache[:block_data_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_block
      s0 << r3
      if r3
        r4 = _nt_t_data
        s0 << r4
        if r4
          r6 = _nt_block_data_name
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r7 = _nt_t_newline
            s0 << r7
            if r7
              i8 = index
              r9 = lambda { |e| sp_block_data_stmt }.call(s0)
              if r9
                @index = i8
                r8 = instantiate_node(SyntaxNode,input, index...index)
              else
                r8 = nil
              end
              s0 << r8
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Block_Data_Stmt,input, i0...index, s0)
      r0.extend(BlockDataStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:block_data_stmt][start_index] = r0

    r0
  end

  module BlockDoConstruct0
    def do_stmt
      elements[0]
    end

    def do_block
      elements[1]
    end

    def end_do
      elements[2]
    end
  end

  def _nt_block_do_construct
    start_index = index
    if node_cache[:block_do_construct].has_key?(index)
      cached = node_cache[:block_do_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_do_stmt
    s0 << r1
    if r1
      r2 = _nt_do_block
      s0 << r2
      if r2
        r3 = _nt_end_do
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(BlockDoConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:block_do_construct][start_index] = r0

    r0
  end

  def _nt_boz_literal_constant
    start_index = index
    if node_cache[:boz_literal_constant].has_key?(index)
      cached = node_cache[:boz_literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_binary_constant
    if r1
      r0 = r1
    else
      r2 = _nt_octal_constant
      if r2
        r0 = r2
      else
        r3 = _nt_hex_constant
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:boz_literal_constant][start_index] = r0

    r0
  end

  module CallStmt0
    def label
      elements[0]
    end

    def t_call
      elements[1]
    end

    def subroutine_name
      elements[2]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_call_stmt
    start_index = index
    if node_cache[:call_stmt].has_key?(index)
      cached = node_cache[:call_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_call
      s0 << r3
      if r3
        r4 = _nt_subroutine_name
        s0 << r4
        if r4
          r6 = _nt_parenthesized_args
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Call_Stmt,input, i0...index, s0)
      r0.extend(CallStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:call_stmt][start_index] = r0

    r0
  end

  module CaseConstruct0
    def select_case_stmt
      elements[0]
    end

    def case_stmt_construct_block
      elements[1]
    end

    def end_select_stmt
      elements[2]
    end
  end

  def _nt_case_construct
    start_index = index
    if node_cache[:case_construct].has_key?(index)
      cached = node_cache[:case_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_select_case_stmt
    s0 << r1
    if r1
      r2 = _nt_case_stmt_construct_block
      s0 << r2
      if r2
        r3 = _nt_end_select_stmt
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(CaseConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:case_construct][start_index] = r0

    r0
  end

  def _nt_case_construct_name
    start_index = index
    if node_cache[:case_construct_name].has_key?(index)
      cached = node_cache[:case_construct_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:case_construct_name][start_index] = r0

    r0
  end

  module CaseConstructNamePair0
    def case_construct_name
      elements[0]
    end

    def t_colon
      elements[1]
    end
  end

  def _nt_case_construct_name_pair
    start_index = index
    if node_cache[:case_construct_name_pair].has_key?(index)
      cached = node_cache[:case_construct_name_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_case_construct_name
    s0 << r1
    if r1
      r2 = _nt_t_colon
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(CaseConstructNamePair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:case_construct_name_pair][start_index] = r0

    r0
  end

  def _nt_case_expr
    start_index = index
    if node_cache[:case_expr].has_key?(index)
      cached = node_cache[:case_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_scalar_int_expr
    if r1
      r0 = r1
    else
      r2 = _nt_scalar_char_expr
      if r2
        r0 = r2
      else
        r3 = _nt_scalar_logical_expr
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:case_expr][start_index] = r0

    r0
  end

  def _nt_case_selector
    start_index = index
    if node_cache[:case_selector].has_key?(index)
      cached = node_cache[:case_selector][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_case_selector_range
    if r1
      r0 = r1
    else
      r2 = _nt_t_default
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:case_selector][start_index] = r0

    r0
  end

  module CaseSelectorRange0
    def t_paren_l
      elements[0]
    end

    def case_value_range_list
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_case_selector_range
    start_index = index
    if node_cache[:case_selector_range].has_key?(index)
      cached = node_cache[:case_selector_range][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_case_value_range_list
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(CaseSelectorRange0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:case_selector_range][start_index] = r0

    r0
  end

  module CaseStmt0
    def label
      elements[0]
    end

    def t_case
      elements[1]
    end

    def case_selector
      elements[2]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_case_stmt
    start_index = index
    if node_cache[:case_stmt].has_key?(index)
      cached = node_cache[:case_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_case
      s0 << r3
      if r3
        r4 = _nt_case_selector
        s0 << r4
        if r4
          r6 = _nt_case_construct_name
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Case_Stmt,input, i0...index, s0)
      r0.extend(CaseStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:case_stmt][start_index] = r0

    r0
  end

  module CaseStmtConstruct0
    def case_stmt
      elements[0]
    end

    def block
      elements[1]
    end
  end

  def _nt_case_stmt_construct
    start_index = index
    if node_cache[:case_stmt_construct].has_key?(index)
      cached = node_cache[:case_stmt_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_case_stmt
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(CaseStmtConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:case_stmt_construct][start_index] = r0

    r0
  end

  def _nt_case_stmt_construct_block
    start_index = index
    if node_cache[:case_stmt_construct_block].has_key?(index)
      cached = node_cache[:case_stmt_construct_block][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_case_stmt_construct
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:case_stmt_construct_block][start_index] = r0

    r0
  end

  def _nt_case_value
    start_index = index
    if node_cache[:case_value].has_key?(index)
      cached = node_cache[:case_value][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_scalar_int_initialization_expr
    if r1
      r0 = r1
    else
      r2 = _nt_scalar_char_initialization_expr
      if r2
        r0 = r2
      else
        r3 = _nt_scalar_logical_initialization_expr
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:case_value][start_index] = r0

    r0
  end

  module CaseValueRange0
    def t_colon
      elements[0]
    end

    def case_value
      elements[1]
    end
  end

  module CaseValueRange1
    def case_value1
      elements[0]
    end

    def t_colon
      elements[1]
    end

    def case_value2
      elements[2]
    end
  end

  module CaseValueRange2
    def case_value
      elements[0]
    end

    def t_colon
      elements[1]
    end
  end

  def _nt_case_value_range
    start_index = index
    if node_cache[:case_value_range].has_key?(index)
      cached = node_cache[:case_value_range][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_colon
    s1 << r2
    if r2
      r3 = _nt_case_value
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(CaseValueRange0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i4, s4 = index, []
      r5 = _nt_case_value
      s4 << r5
      if r5
        r6 = _nt_t_colon
        s4 << r6
        if r6
          r7 = _nt_case_value
          s4 << r7
        end
      end
      if s4.last
        r4 = instantiate_node(T,input, i4...index, s4)
        r4.extend(CaseValueRange1)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r0 = r4
      else
        i8, s8 = index, []
        r9 = _nt_case_value
        s8 << r9
        if r9
          r10 = _nt_t_colon
          s8 << r10
        end
        if s8.last
          r8 = instantiate_node(T,input, i8...index, s8)
          r8.extend(CaseValueRange2)
        else
          @index = i8
          r8 = nil
        end
        if r8
          r0 = r8
        else
          r11 = _nt_case_value
          if r11
            r0 = r11
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:case_value_range][start_index] = r0

    r0
  end

  module CaseValueRangeList0
    def t_comma
      elements[0]
    end

    def case_value_range
      elements[1]
    end
  end

  module CaseValueRangeList1
    def case_value_range
      elements[0]
    end

  end

  def _nt_case_value_range_list
    start_index = index
    if node_cache[:case_value_range_list].has_key?(index)
      cached = node_cache[:case_value_range_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_case_value_range
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_case_value_range
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(CaseValueRangeList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Case_Value_Range_List,input, i0...index, s0)
      r0.extend(CaseValueRangeList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:case_value_range_list][start_index] = r0

    r0
  end

  def _nt_char_expr
    start_index = index
    if node_cache[:char_expr].has_key?(index)
      cached = node_cache[:char_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_expr

    node_cache[:char_expr][start_index] = r0

    r0
  end

  def _nt_char_initialization_expr
    start_index = index
    if node_cache[:char_initialization_expr].has_key?(index)
      cached = node_cache[:char_initialization_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_char_expr

    node_cache[:char_initialization_expr][start_index] = r0

    r0
  end

  module CharLength0
    def t_paren_l
      elements[0]
    end

    def type_param_value
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_char_length
    start_index = index
    if node_cache[:char_length].has_key?(index)
      cached = node_cache[:char_length][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_paren_l
    s1 << r2
    if r2
      r3 = _nt_type_param_value
      s1 << r3
      if r3
        r4 = _nt_t_paren_r
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(CharLength0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r5 = _nt_scalar_int_literal_constant
      if r5
        r0 = r5
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:char_length][start_index] = r0

    r0
  end

  module CharLengthPair0
    def t_star
      elements[0]
    end

    def char_length
      elements[1]
    end
  end

  def _nt_char_length_pair
    start_index = index
    if node_cache[:char_length_pair].has_key?(index)
      cached = node_cache[:char_length_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_star
    s0 << r1
    if r1
      r2 = _nt_char_length
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(CharLengthPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:char_length_pair][start_index] = r0

    r0
  end

  module CharLiteralConstant0
    def kind_param
      elements[0]
    end

    def t_underscore
      elements[1]
    end
  end

  module CharLiteralConstant1
    def char_literal_constant_sq
      elements[1]
    end
  end

  module CharLiteralConstant2
    def kind_param
      elements[0]
    end

    def t_underscore
      elements[1]
    end
  end

  module CharLiteralConstant3
    def char_literal_constant_dq
      elements[1]
    end
  end

  def _nt_char_literal_constant
    start_index = index
    if node_cache[:char_literal_constant].has_key?(index)
      cached = node_cache[:char_literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    i3, s3 = index, []
    r4 = _nt_kind_param
    s3 << r4
    if r4
      r5 = _nt_t_underscore
      s3 << r5
    end
    if s3.last
      r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
      r3.extend(CharLiteralConstant0)
    else
      @index = i3
      r3 = nil
    end
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r6 = _nt_char_literal_constant_sq
      s1 << r6
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(CharLiteralConstant1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i7, s7 = index, []
      i9, s9 = index, []
      r10 = _nt_kind_param
      s9 << r10
      if r10
        r11 = _nt_t_underscore
        s9 << r11
      end
      if s9.last
        r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
        r9.extend(CharLiteralConstant2)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r8 = r9
      else
        r8 = instantiate_node(SyntaxNode,input, index...index)
      end
      s7 << r8
      if r8
        r12 = _nt_char_literal_constant_dq
        s7 << r12
      end
      if s7.last
        r7 = instantiate_node(T,input, i7...index, s7)
        r7.extend(CharLiteralConstant3)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r0 = r7
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:char_literal_constant][start_index] = r0

    r0
  end

  module CharLiteralConstantDq0
    def rep_char
      elements[1]
    end
  end

  module CharLiteralConstantDq1
    def t_quotemark1
      elements[0]
    end

    def t_quotemark2
      elements[2]
    end
  end

  def _nt_char_literal_constant_dq
    start_index = index
    if node_cache[:char_literal_constant_dq].has_key?(index)
      cached = node_cache[:char_literal_constant_dq][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_quotemark
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        i4 = index
        r5 = _nt_t_quotemark
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          r6 = _nt_rep_char
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(CharLiteralConstantDq0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r7 = _nt_t_quotemark
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(CharLiteralConstantDq1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:char_literal_constant_dq][start_index] = r0

    r0
  end

  module CharLiteralConstantSq0
    def rep_char
      elements[1]
    end
  end

  module CharLiteralConstantSq1
    def t_apostrophe1
      elements[0]
    end

    def t_apostrophe2
      elements[2]
    end
  end

  def _nt_char_literal_constant_sq
    start_index = index
    if node_cache[:char_literal_constant_sq].has_key?(index)
      cached = node_cache[:char_literal_constant_sq][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_apostrophe
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        i4 = index
        r5 = _nt_t_apostrophe
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          r6 = _nt_rep_char
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(CharLiteralConstantSq0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r7 = _nt_t_apostrophe
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(CharLiteralConstantSq1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:char_literal_constant_sq][start_index] = r0

    r0
  end

  module CharSelector0
    def t_paren_l
      elements[0]
    end

    def len_pair
      elements[1]
    end

    def type_param_value
      elements[2]
    end

    def t_comma
      elements[3]
    end

    def kind_pair
      elements[4]
    end

    def scalar_int_initialization_expr
      elements[5]
    end

    def t_paren_r
      elements[6]
    end
  end

  module CharSelector1
    def t_paren_l
      elements[0]
    end

    def type_param_value
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def scalar_int_initialization_expr
      elements[4]
    end

    def t_paren_r
      elements[5]
    end
  end

  module CharSelector2
    def t_comma
      elements[0]
    end

    def len_pair
      elements[1]
    end

    def type_param_value
      elements[2]
    end
  end

  module CharSelector3
    def t_paren_l
      elements[0]
    end

    def kind_pair
      elements[1]
    end

    def scalar_int_initialization_expr
      elements[2]
    end

    def t_paren_r
      elements[4]
    end
  end

  def _nt_char_selector
    start_index = index
    if node_cache[:char_selector].has_key?(index)
      cached = node_cache[:char_selector][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_length_selector
    if r1
      r0 = r1
    else
      i2, s2 = index, []
      r3 = _nt_t_paren_l
      s2 << r3
      if r3
        r4 = _nt_len_pair
        s2 << r4
        if r4
          r5 = _nt_type_param_value
          s2 << r5
          if r5
            r6 = _nt_t_comma
            s2 << r6
            if r6
              r7 = _nt_kind_pair
              s2 << r7
              if r7
                r8 = _nt_scalar_int_initialization_expr
                s2 << r8
                if r8
                  r9 = _nt_t_paren_r
                  s2 << r9
                end
              end
            end
          end
        end
      end
      if s2.last
        r2 = instantiate_node(T,input, i2...index, s2)
        r2.extend(CharSelector0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r0 = r2
      else
        i10, s10 = index, []
        r11 = _nt_t_paren_l
        s10 << r11
        if r11
          r12 = _nt_type_param_value
          s10 << r12
          if r12
            r13 = _nt_t_comma
            s10 << r13
            if r13
              r15 = _nt_kind_pair
              if r15
                r14 = r15
              else
                r14 = instantiate_node(SyntaxNode,input, index...index)
              end
              s10 << r14
              if r14
                r16 = _nt_scalar_int_initialization_expr
                s10 << r16
                if r16
                  r17 = _nt_t_paren_r
                  s10 << r17
                end
              end
            end
          end
        end
        if s10.last
          r10 = instantiate_node(T,input, i10...index, s10)
          r10.extend(CharSelector1)
        else
          @index = i10
          r10 = nil
        end
        if r10
          r0 = r10
        else
          i18, s18 = index, []
          r19 = _nt_t_paren_l
          s18 << r19
          if r19
            r20 = _nt_kind_pair
            s18 << r20
            if r20
              r21 = _nt_scalar_int_initialization_expr
              s18 << r21
              if r21
                i23, s23 = index, []
                r24 = _nt_t_comma
                s23 << r24
                if r24
                  r25 = _nt_len_pair
                  s23 << r25
                  if r25
                    r26 = _nt_type_param_value
                    s23 << r26
                  end
                end
                if s23.last
                  r23 = instantiate_node(SyntaxNode,input, i23...index, s23)
                  r23.extend(CharSelector2)
                else
                  @index = i23
                  r23 = nil
                end
                if r23
                  r22 = r23
                else
                  r22 = instantiate_node(SyntaxNode,input, index...index)
                end
                s18 << r22
                if r22
                  r27 = _nt_t_paren_r
                  s18 << r27
                end
              end
            end
          end
          if s18.last
            r18 = instantiate_node(T,input, i18...index, s18)
            r18.extend(CharSelector3)
          else
            @index = i18
            r18 = nil
          end
          if r18
            r0 = r18
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:char_selector][start_index] = r0

    r0
  end

  def _nt_char_variable
    start_index = index
    if node_cache[:char_variable].has_key?(index)
      cached = node_cache[:char_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable

    node_cache[:char_variable][start_index] = r0

    r0
  end

  def _nt_character
    start_index = index
    if node_cache[:character].has_key?(index)
      cached = node_cache[:character][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_alphanumeric_character
    if r1
      r0 = r1
    else
      r2 = _nt_special_character
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:character][start_index] = r0

    r0
  end

  module CloseSpec0
    def t_iostat
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_int_variable
      elements[2]
    end
  end

  module CloseSpec1
    def t_err
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def label
      elements[2]
    end
  end

  module CloseSpec2
    def t_status
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module CloseSpec3
    def t_unit
      elements[0]
    end

    def t_equal
      elements[1]
    end
  end

  module CloseSpec4
    def external_file_unit
      elements[1]
    end
  end

  def _nt_close_spec
    start_index = index
    if node_cache[:close_spec].has_key?(index)
      cached = node_cache[:close_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_iostat
    s1 << r2
    if r2
      r3 = _nt_t_equal
      s1 << r3
      if r3
        r4 = _nt_scalar_default_int_variable
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(CloseSpec0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_t_err
      s5 << r6
      if r6
        r7 = _nt_t_equal
        s5 << r7
        if r7
          r8 = _nt_label
          s5 << r8
        end
      end
      if s5.last
        r5 = instantiate_node(T,input, i5...index, s5)
        r5.extend(CloseSpec1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        i9, s9 = index, []
        r10 = _nt_t_status
        s9 << r10
        if r10
          r11 = _nt_t_equal
          s9 << r11
          if r11
            r12 = _nt_scalar_default_char_expr
            s9 << r12
          end
        end
        if s9.last
          r9 = instantiate_node(T,input, i9...index, s9)
          r9.extend(CloseSpec2)
        else
          @index = i9
          r9 = nil
        end
        if r9
          r0 = r9
        else
          i13, s13 = index, []
          i15, s15 = index, []
          r16 = _nt_t_unit
          s15 << r16
          if r16
            r17 = _nt_t_equal
            s15 << r17
          end
          if s15.last
            r15 = instantiate_node(SyntaxNode,input, i15...index, s15)
            r15.extend(CloseSpec3)
          else
            @index = i15
            r15 = nil
          end
          if r15
            r14 = r15
          else
            r14 = instantiate_node(SyntaxNode,input, index...index)
          end
          s13 << r14
          if r14
            r18 = _nt_external_file_unit
            s13 << r18
          end
          if s13.last
            r13 = instantiate_node(T,input, i13...index, s13)
            r13.extend(CloseSpec4)
          else
            @index = i13
            r13 = nil
          end
          if r13
            r0 = r13
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:close_spec][start_index] = r0

    r0
  end

  module CloseSpecList0
    def t_comma
      elements[0]
    end

    def close_spec
      elements[1]
    end
  end

  module CloseSpecList1
    def close_spec
      elements[0]
    end

  end

  def _nt_close_spec_list
    start_index = index
    if node_cache[:close_spec_list].has_key?(index)
      cached = node_cache[:close_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_close_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_close_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(CloseSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Close_Spec_List,input, i0...index, s0)
      r0.extend(CloseSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:close_spec_list][start_index] = r0

    r0
  end

  module CloseStmt0
    def label
      elements[0]
    end

    def t_close
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def close_spec_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_close_stmt
    start_index = index
    if node_cache[:close_stmt].has_key?(index)
      cached = node_cache[:close_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_close
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_close_spec_list
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r7 = _nt_t_newline
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtC,input, i0...index, s0)
      r0.extend(CloseStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:close_stmt][start_index] = r0

    r0
  end

  def _nt_common_block_name
    start_index = index
    if node_cache[:common_block_name].has_key?(index)
      cached = node_cache[:common_block_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:common_block_name][start_index] = r0

    r0
  end

  module CommonBlockNameAndObjectList0
    def common_block_name_triplet
      elements[1]
    end

    def common_block_object_list
      elements[2]
    end
  end

  def _nt_common_block_name_and_object_list
    start_index = index
    if node_cache[:common_block_name_and_object_list].has_key?(index)
      cached = node_cache[:common_block_name_and_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_t_comma
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_common_block_name_triplet
      s0 << r3
      if r3
        r4 = _nt_common_block_object_list
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(Common_Block_Name_And_Object_List,input, i0...index, s0)
      r0.extend(CommonBlockNameAndObjectList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:common_block_name_and_object_list][start_index] = r0

    r0
  end

  def _nt_common_block_name_and_object_lists
    start_index = index
    if node_cache[:common_block_name_and_object_lists].has_key?(index)
      cached = node_cache[:common_block_name_and_object_lists][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_common_block_name_and_object_list
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:common_block_name_and_object_lists][start_index] = r0

    r0
  end

  module CommonBlockNameTriplet0
    def t_slash1
      elements[0]
    end

    def t_slash2
      elements[2]
    end
  end

  def _nt_common_block_name_triplet
    start_index = index
    if node_cache[:common_block_name_triplet].has_key?(index)
      cached = node_cache[:common_block_name_triplet][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_slash
    s0 << r1
    if r1
      r3 = _nt_common_block_name
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_t_slash
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(CommonBlockNameTriplet0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:common_block_name_triplet][start_index] = r0

    r0
  end

  module CommonBlockObject0
    def variable_name
      elements[0]
    end

  end

  def _nt_common_block_object
    start_index = index
    if node_cache[:common_block_object].has_key?(index)
      cached = node_cache[:common_block_object][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_variable_name
    s0 << r1
    if r1
      r3 = _nt_common_block_object_explicit_shape_spec_list
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(CommonBlockObject0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:common_block_object][start_index] = r0

    r0
  end

  def _nt_common_block_object_explicit_shape_spec_list
    start_index = index
    if node_cache[:common_block_object_explicit_shape_spec_list].has_key?(index)
      cached = node_cache[:common_block_object_explicit_shape_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_parenthesized_explicit_shape_spec_list

    node_cache[:common_block_object_explicit_shape_spec_list][start_index] = r0

    r0
  end

  module CommonBlockObjectList0
    def common_block_object
      elements[0]
    end

    def common_block_object_pairs
      elements[1]
    end
  end

  def _nt_common_block_object_list
    start_index = index
    if node_cache[:common_block_object_list].has_key?(index)
      cached = node_cache[:common_block_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_common_block_object
    s0 << r1
    if r1
      r2 = _nt_common_block_object_pairs
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(CommonBlockObjectList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:common_block_object_list][start_index] = r0

    r0
  end

  module CommonBlockObjectPair0
    def t_comma
      elements[0]
    end

    def common_block_object
      elements[1]
    end
  end

  def _nt_common_block_object_pair
    start_index = index
    if node_cache[:common_block_object_pair].has_key?(index)
      cached = node_cache[:common_block_object_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_common_block_object
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(CommonBlockObjectPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:common_block_object_pair][start_index] = r0

    r0
  end

  def _nt_common_block_object_pairs
    start_index = index
    if node_cache[:common_block_object_pairs].has_key?(index)
      cached = node_cache[:common_block_object_pairs][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_common_block_object_pair
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:common_block_object_pairs][start_index] = r0

    r0
  end

  module CommonStmt0
    def label
      elements[0]
    end

    def t_common
      elements[1]
    end

    def common_block_object_list
      elements[3]
    end

    def common_block_name_and_object_lists
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_common_stmt
    start_index = index
    if node_cache[:common_stmt].has_key?(index)
      cached = node_cache[:common_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_common
      s0 << r3
      if r3
        r5 = _nt_common_block_name_triplet
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_common_block_object_list
          s0 << r6
          if r6
            r7 = _nt_common_block_name_and_object_lists
            s0 << r7
            if r7
              r8 = _nt_t_newline
              s0 << r8
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Common_Stmt,input, i0...index, s0)
      r0.extend(CommonStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:common_stmt][start_index] = r0

    r0
  end

  module ComplexLiteralConstant0
    def t_paren_l
      elements[0]
    end

    def real_part
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def imag_part
      elements[3]
    end

    def t_paren_r
      elements[4]
    end
  end

  def _nt_complex_literal_constant
    start_index = index
    if node_cache[:complex_literal_constant].has_key?(index)
      cached = node_cache[:complex_literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_real_part
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_imag_part
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(ComplexLiteralConstant0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:complex_literal_constant][start_index] = r0

    r0
  end

  def _nt_component_array_spec
    start_index = index
    if node_cache[:component_array_spec].has_key?(index)
      cached = node_cache[:component_array_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_explicit_shape_spec_list
    if r1
      r0 = r1
    else
      r2 = _nt_deferred_shape_spec_list
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:component_array_spec][start_index] = r0

    r0
  end

  module ComponentAttrSpec0
    def t_dimension
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def component_array_spec
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_component_attr_spec
    start_index = index
    if node_cache[:component_attr_spec].has_key?(index)
      cached = node_cache[:component_attr_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_pointer
    if r1
      r0 = r1
    else
      i2, s2 = index, []
      r3 = _nt_t_dimension
      s2 << r3
      if r3
        r4 = _nt_t_paren_l
        s2 << r4
        if r4
          r5 = _nt_component_array_spec
          s2 << r5
          if r5
            r6 = _nt_t_paren_r
            s2 << r6
          end
        end
      end
      if s2.last
        r2 = instantiate_node(E,input, i2...index, s2)
        r2.extend(ComponentAttrSpec0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r0 = r2
      else
        r7 = _nt_t_allocatable
        if r7
          r0 = r7
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:component_attr_spec][start_index] = r0

    r0
  end

  module ComponentAttrSpecList0
    def t_comma
      elements[0]
    end

    def component_attr_spec
      elements[1]
    end
  end

  module ComponentAttrSpecList1
    def component_attr_spec
      elements[0]
    end

  end

  def _nt_component_attr_spec_list
    start_index = index
    if node_cache[:component_attr_spec_list].has_key?(index)
      cached = node_cache[:component_attr_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_component_attr_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_component_attr_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(ComponentAttrSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Component_Attr_Spec_List,input, i0...index, s0)
      r0.extend(ComponentAttrSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:component_attr_spec_list][start_index] = r0

    r0
  end

  module ComponentAttrSpecListOption0
    def t_comma
      elements[0]
    end

    def component_attr_spec_list
      elements[1]
    end
  end

  module ComponentAttrSpecListOption1
    def double_colon
      elements[1]
    end
  end

  def _nt_component_attr_spec_list_option
    start_index = index
    if node_cache[:component_attr_spec_list_option].has_key?(index)
      cached = node_cache[:component_attr_spec_list_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i2, s2 = index, []
    r3 = _nt_t_comma
    s2 << r3
    if r3
      r4 = _nt_component_attr_spec_list
      s2 << r4
    end
    if s2.last
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      r2.extend(ComponentAttrSpecListOption0)
    else
      @index = i2
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r5 = _nt_double_colon
      s0 << r5
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(ComponentAttrSpecListOption1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:component_attr_spec_list_option][start_index] = r0

    r0
  end

  module ComponentDecl0
    def t_star
      elements[0]
    end

    def char_length
      elements[1]
    end
  end

  module ComponentDecl1
    def component_name
      elements[0]
    end

  end

  def _nt_component_decl
    start_index = index
    if node_cache[:component_decl].has_key?(index)
      cached = node_cache[:component_decl][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_component_name
    s0 << r1
    if r1
      r3 = _nt_parenthesized_component_array_spec
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        i5, s5 = index, []
        r6 = _nt_t_star
        s5 << r6
        if r6
          r7 = _nt_char_length
          s5 << r7
        end
        if s5.last
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
          r5.extend(ComponentDecl0)
        else
          @index = i5
          r5 = nil
        end
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r9 = _nt_component_initialization
          if r9
            r8 = r9
          else
            r8 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r8
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ComponentDecl1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:component_decl][start_index] = r0

    r0
  end

  module ComponentDeclList0
    def t_comma
      elements[0]
    end

    def component_decl
      elements[1]
    end
  end

  module ComponentDeclList1
    def component_decl
      elements[0]
    end

  end

  def _nt_component_decl_list
    start_index = index
    if node_cache[:component_decl_list].has_key?(index)
      cached = node_cache[:component_decl_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_component_decl
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_component_decl
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(ComponentDeclList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Component_Decl_List,input, i0...index, s0)
      r0.extend(ComponentDeclList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:component_decl_list][start_index] = r0

    r0
  end

  module ComponentDefStmt0
    def label
      elements[0]
    end

    def type_spec
      elements[1]
    end

    def component_decl_list
      elements[3]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_component_def_stmt
    start_index = index
    if node_cache[:component_def_stmt].has_key?(index)
      cached = node_cache[:component_def_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_type_spec
      s0 << r3
      if r3
        r5 = _nt_component_attr_spec_list_option
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_component_decl_list
          s0 << r6
          if r6
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Component_Def_Stmt,input, i0...index, s0)
      r0.extend(ComponentDefStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:component_def_stmt][start_index] = r0

    r0
  end

  def _nt_component_def_stmts
    start_index = index
    if node_cache[:component_def_stmts].has_key?(index)
      cached = node_cache[:component_def_stmts][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_component_def_stmt
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(E,input, i0...index, s0)
    end

    node_cache[:component_def_stmts][start_index] = r0

    r0
  end

  module ComponentInitialization0
    def t_equal
      elements[0]
    end

    def initialization_expr
      elements[1]
    end
  end

  module ComponentInitialization1
    def t_point
      elements[0]
    end

    def null_function_ref
      elements[1]
    end
  end

  def _nt_component_initialization
    start_index = index
    if node_cache[:component_initialization].has_key?(index)
      cached = node_cache[:component_initialization][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_equal
    s1 << r2
    if r2
      r3 = _nt_initialization_expr
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(E,input, i1...index, s1)
      r1.extend(ComponentInitialization0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i4, s4 = index, []
      r5 = _nt_t_point
      s4 << r5
      if r5
        r6 = _nt_null_function_ref
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(T,input, i4...index, s4)
        r4.extend(ComponentInitialization1)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r0 = r4
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:component_initialization][start_index] = r0

    r0
  end

  def _nt_component_name
    start_index = index
    if node_cache[:component_name].has_key?(index)
      cached = node_cache[:component_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:component_name][start_index] = r0

    r0
  end

  module ComputedGotoStmt0
    def label
      elements[0]
    end

    def t_goto
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def label_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def scalar_int_expr
      elements[6]
    end

    def t_newline
      elements[7]
    end
  end

  def _nt_computed_goto_stmt
    start_index = index
    if node_cache[:computed_goto_stmt].has_key?(index)
      cached = node_cache[:computed_goto_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_goto
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_label_list
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r8 = _nt_t_comma
              if r8
                r7 = r8
              else
                r7 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r7
              if r7
                r9 = _nt_scalar_int_expr
                s0 << r9
                if r9
                  r10 = _nt_t_newline
                  s0 << r10
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Computed_Goto_Stmt,input, i0...index, s0)
      r0.extend(ComputedGotoStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:computed_goto_stmt][start_index] = r0

    r0
  end

  def _nt_concat_op
    start_index = index
    if node_cache[:concat_op].has_key?(index)
      cached = node_cache[:concat_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("//", false, index)
      r0 = instantiate_node(T,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("//")
      r0 = nil
    end

    node_cache[:concat_op][start_index] = r0

    r0
  end

  module ConnectSpec0
    def t_iostat
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_int_variable
      elements[2]
    end
  end

  module ConnectSpec1
    def t_err
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def label
      elements[2]
    end
  end

  module ConnectSpec2
    def t_file
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def file_name_expr
      elements[2]
    end
  end

  module ConnectSpec3
    def t_status
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module ConnectSpec4
    def t_access
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module ConnectSpec5
    def t_form
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module ConnectSpec6
    def t_recl
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_int_expr
      elements[2]
    end
  end

  module ConnectSpec7
    def t_blank
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module ConnectSpec8
    def t_position
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module ConnectSpec9
    def t_action
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module ConnectSpec10
    def t_delim
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module ConnectSpec11
    def t_pad
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module ConnectSpec12
    def t_unit
      elements[0]
    end

    def t_equal
      elements[1]
    end
  end

  module ConnectSpec13
    def external_file_unit
      elements[1]
    end
  end

  def _nt_connect_spec
    start_index = index
    if node_cache[:connect_spec].has_key?(index)
      cached = node_cache[:connect_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_iostat
    s1 << r2
    if r2
      r3 = _nt_t_equal
      s1 << r3
      if r3
        r4 = _nt_scalar_default_int_variable
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(ConnectSpec0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_t_err
      s5 << r6
      if r6
        r7 = _nt_t_equal
        s5 << r7
        if r7
          r8 = _nt_label
          s5 << r8
        end
      end
      if s5.last
        r5 = instantiate_node(T,input, i5...index, s5)
        r5.extend(ConnectSpec1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        i9, s9 = index, []
        r10 = _nt_t_file
        s9 << r10
        if r10
          r11 = _nt_t_equal
          s9 << r11
          if r11
            r12 = _nt_file_name_expr
            s9 << r12
          end
        end
        if s9.last
          r9 = instantiate_node(T,input, i9...index, s9)
          r9.extend(ConnectSpec2)
        else
          @index = i9
          r9 = nil
        end
        if r9
          r0 = r9
        else
          i13, s13 = index, []
          r14 = _nt_t_status
          s13 << r14
          if r14
            r15 = _nt_t_equal
            s13 << r15
            if r15
              r16 = _nt_scalar_default_char_expr
              s13 << r16
            end
          end
          if s13.last
            r13 = instantiate_node(T,input, i13...index, s13)
            r13.extend(ConnectSpec3)
          else
            @index = i13
            r13 = nil
          end
          if r13
            r0 = r13
          else
            i17, s17 = index, []
            r18 = _nt_t_access
            s17 << r18
            if r18
              r19 = _nt_t_equal
              s17 << r19
              if r19
                r20 = _nt_scalar_default_char_expr
                s17 << r20
              end
            end
            if s17.last
              r17 = instantiate_node(T,input, i17...index, s17)
              r17.extend(ConnectSpec4)
            else
              @index = i17
              r17 = nil
            end
            if r17
              r0 = r17
            else
              i21, s21 = index, []
              r22 = _nt_t_form
              s21 << r22
              if r22
                r23 = _nt_t_equal
                s21 << r23
                if r23
                  r24 = _nt_scalar_default_char_expr
                  s21 << r24
                end
              end
              if s21.last
                r21 = instantiate_node(T,input, i21...index, s21)
                r21.extend(ConnectSpec5)
              else
                @index = i21
                r21 = nil
              end
              if r21
                r0 = r21
              else
                i25, s25 = index, []
                r26 = _nt_t_recl
                s25 << r26
                if r26
                  r27 = _nt_t_equal
                  s25 << r27
                  if r27
                    r28 = _nt_scalar_int_expr
                    s25 << r28
                  end
                end
                if s25.last
                  r25 = instantiate_node(T,input, i25...index, s25)
                  r25.extend(ConnectSpec6)
                else
                  @index = i25
                  r25 = nil
                end
                if r25
                  r0 = r25
                else
                  i29, s29 = index, []
                  r30 = _nt_t_blank
                  s29 << r30
                  if r30
                    r31 = _nt_t_equal
                    s29 << r31
                    if r31
                      r32 = _nt_scalar_default_char_expr
                      s29 << r32
                    end
                  end
                  if s29.last
                    r29 = instantiate_node(T,input, i29...index, s29)
                    r29.extend(ConnectSpec7)
                  else
                    @index = i29
                    r29 = nil
                  end
                  if r29
                    r0 = r29
                  else
                    i33, s33 = index, []
                    r34 = _nt_t_position
                    s33 << r34
                    if r34
                      r35 = _nt_t_equal
                      s33 << r35
                      if r35
                        r36 = _nt_scalar_default_char_expr
                        s33 << r36
                      end
                    end
                    if s33.last
                      r33 = instantiate_node(T,input, i33...index, s33)
                      r33.extend(ConnectSpec8)
                    else
                      @index = i33
                      r33 = nil
                    end
                    if r33
                      r0 = r33
                    else
                      i37, s37 = index, []
                      r38 = _nt_t_action
                      s37 << r38
                      if r38
                        r39 = _nt_t_equal
                        s37 << r39
                        if r39
                          r40 = _nt_scalar_default_char_expr
                          s37 << r40
                        end
                      end
                      if s37.last
                        r37 = instantiate_node(T,input, i37...index, s37)
                        r37.extend(ConnectSpec9)
                      else
                        @index = i37
                        r37 = nil
                      end
                      if r37
                        r0 = r37
                      else
                        i41, s41 = index, []
                        r42 = _nt_t_delim
                        s41 << r42
                        if r42
                          r43 = _nt_t_equal
                          s41 << r43
                          if r43
                            r44 = _nt_scalar_default_char_expr
                            s41 << r44
                          end
                        end
                        if s41.last
                          r41 = instantiate_node(T,input, i41...index, s41)
                          r41.extend(ConnectSpec10)
                        else
                          @index = i41
                          r41 = nil
                        end
                        if r41
                          r0 = r41
                        else
                          i45, s45 = index, []
                          r46 = _nt_t_pad
                          s45 << r46
                          if r46
                            r47 = _nt_t_equal
                            s45 << r47
                            if r47
                              r48 = _nt_scalar_default_char_expr
                              s45 << r48
                            end
                          end
                          if s45.last
                            r45 = instantiate_node(T,input, i45...index, s45)
                            r45.extend(ConnectSpec11)
                          else
                            @index = i45
                            r45 = nil
                          end
                          if r45
                            r0 = r45
                          else
                            i49, s49 = index, []
                            i51, s51 = index, []
                            r52 = _nt_t_unit
                            s51 << r52
                            if r52
                              r53 = _nt_t_equal
                              s51 << r53
                            end
                            if s51.last
                              r51 = instantiate_node(SyntaxNode,input, i51...index, s51)
                              r51.extend(ConnectSpec12)
                            else
                              @index = i51
                              r51 = nil
                            end
                            if r51
                              r50 = r51
                            else
                              r50 = instantiate_node(SyntaxNode,input, index...index)
                            end
                            s49 << r50
                            if r50
                              r54 = _nt_external_file_unit
                              s49 << r54
                            end
                            if s49.last
                              r49 = instantiate_node(T,input, i49...index, s49)
                              r49.extend(ConnectSpec13)
                            else
                              @index = i49
                              r49 = nil
                            end
                            if r49
                              r0 = r49
                            else
                              @index = i0
                              r0 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:connect_spec][start_index] = r0

    r0
  end

  module ConnectSpecList0
    def t_comma
      elements[0]
    end

    def connect_spec
      elements[1]
    end
  end

  module ConnectSpecList1
    def connect_spec
      elements[0]
    end

  end

  def _nt_connect_spec_list
    start_index = index
    if node_cache[:connect_spec_list].has_key?(index)
      cached = node_cache[:connect_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_connect_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_connect_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(ConnectSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Connect_Spec_List,input, i0...index, s0)
      r0.extend(ConnectSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:connect_spec_list][start_index] = r0

    r0
  end

  def _nt_constant
    start_index = index
    if node_cache[:constant].has_key?(index)
      cached = node_cache[:constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_literal_constant
    if r1
      r0 = r1
    else
      r2 = _nt_named_constant
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:constant][start_index] = r0

    r0
  end

  def _nt_constant_subobject
    start_index = index
    if node_cache[:constant_subobject].has_key?(index)
      cached = node_cache[:constant_subobject][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_subobject

    node_cache[:constant_subobject][start_index] = r0

    r0
  end

  module ContainsStmt0
    def label
      elements[0]
    end

    def t_contains
      elements[1]
    end

    def t_newline
      elements[2]
    end
  end

  def _nt_contains_stmt
    start_index = index
    if node_cache[:contains_stmt].has_key?(index)
      cached = node_cache[:contains_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_contains
      s0 << r3
      if r3
        r4 = _nt_t_newline
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(Contains_Stmt,input, i0...index, s0)
      r0.extend(ContainsStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:contains_stmt][start_index] = r0

    r0
  end

  module ContinueStmt0
    def label
      elements[0]
    end

    def t_continue
      elements[1]
    end

    def t_newline
      elements[2]
    end
  end

  def _nt_continue_stmt
    start_index = index
    if node_cache[:continue_stmt].has_key?(index)
      cached = node_cache[:continue_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_continue
      s0 << r3
      if r3
        r4 = _nt_t_newline
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(ContinueStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:continue_stmt][start_index] = r0

    r0
  end

  module CycleStmt0
    def label
      elements[0]
    end

    def t_cycle
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_cycle_stmt
    start_index = index
    if node_cache[:cycle_stmt].has_key?(index)
      cached = node_cache[:cycle_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_cycle
      s0 << r3
      if r3
        r5 = _nt_do_construct_name
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(CycleStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:cycle_stmt][start_index] = r0

    r0
  end

  module DataIDoObject0
    def array_element
      elements[0]
    end

  end

  module DataIDoObject1
    def scalar_structure_component
      elements[0]
    end

  end

  def _nt_data_i_do_object
    start_index = index
    if node_cache[:data_i_do_object].has_key?(index)
      cached = node_cache[:data_i_do_object][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_array_element
    s1 << r2
    if r2
      i3 = index
      r4 = _nt_t_equal
      if r4
        r3 = nil
      else
        @index = i3
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(E,input, i1...index, s1)
      r1.extend(DataIDoObject0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_scalar_structure_component
      s5 << r6
      if r6
        i7 = index
        r8 = _nt_t_equal
        if r8
          r7 = nil
        else
          @index = i7
          r7 = instantiate_node(SyntaxNode,input, index...index)
        end
        s5 << r7
      end
      if s5.last
        r5 = instantiate_node(E,input, i5...index, s5)
        r5.extend(DataIDoObject1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        r9 = _nt_data_implied_do
        if r9
          r0 = r9
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:data_i_do_object][start_index] = r0

    r0
  end

  module DataIDoObjectList0
    def t_comma
      elements[0]
    end

    def data_i_do_object
      elements[1]
    end
  end

  module DataIDoObjectList1
    def data_i_do_object
      elements[0]
    end

  end

  def _nt_data_i_do_object_list
    start_index = index
    if node_cache[:data_i_do_object_list].has_key?(index)
      cached = node_cache[:data_i_do_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_data_i_do_object
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_data_i_do_object
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(DataIDoObjectList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Data_I_Do_Object_List,input, i0...index, s0)
      r0.extend(DataIDoObjectList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_i_do_object_list][start_index] = r0

    r0
  end

  def _nt_data_i_do_variable
    start_index = index
    if node_cache[:data_i_do_variable].has_key?(index)
      cached = node_cache[:data_i_do_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_variable

    node_cache[:data_i_do_variable][start_index] = r0

    r0
  end

  module DataImpliedDo0
    def t_comma
      elements[0]
    end

    def scalar_int_expr
      elements[1]
    end
  end

  module DataImpliedDo1
    def t_paren_l
      elements[0]
    end

    def data_i_do_object_list
      elements[1]
    end

    def t_comma1
      elements[2]
    end

    def data_i_do_variable
      elements[3]
    end

    def t_equal
      elements[4]
    end

    def scalar_int_expr1
      elements[5]
    end

    def t_comma2
      elements[6]
    end

    def scalar_int_expr2
      elements[7]
    end

    def t_paren_r
      elements[9]
    end
  end

  def _nt_data_implied_do
    start_index = index
    if node_cache[:data_implied_do].has_key?(index)
      cached = node_cache[:data_implied_do][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_data_i_do_object_list
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_data_i_do_variable
          s0 << r4
          if r4
            r5 = _nt_t_equal
            s0 << r5
            if r5
              r6 = _nt_scalar_int_expr
              s0 << r6
              if r6
                r7 = _nt_t_comma
                s0 << r7
                if r7
                  r8 = _nt_scalar_int_expr
                  s0 << r8
                  if r8
                    s9, i9 = [], index
                    loop do
                      i10, s10 = index, []
                      r11 = _nt_t_comma
                      s10 << r11
                      if r11
                        r12 = _nt_scalar_int_expr
                        s10 << r12
                      end
                      if s10.last
                        r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
                        r10.extend(DataImpliedDo0)
                      else
                        @index = i10
                        r10 = nil
                      end
                      if r10
                        s9 << r10
                      else
                        break
                      end
                    end
                    r9 = instantiate_node(SyntaxNode,input, i9...index, s9)
                    s0 << r9
                    if r9
                      r13 = _nt_t_paren_r
                      s0 << r13
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(DataImpliedDo1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_implied_do][start_index] = r0

    r0
  end

  module DataRef0
    def t_percent
      elements[0]
    end

    def part_ref
      elements[1]
    end
  end

  module DataRef1
    def part_ref
      elements[0]
    end

  end

  def _nt_data_ref
    start_index = index
    if node_cache[:data_ref].has_key?(index)
      cached = node_cache[:data_ref][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_part_ref
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_percent
        s3 << r4
        if r4
          r5 = _nt_part_ref
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(DataRef0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Data_Ref,input, i0...index, s0)
      r0.extend(DataRef1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_ref][start_index] = r0

    r0
  end

  module DataStmt0
    def label
      elements[0]
    end

    def t_data
      elements[1]
    end

    def data_stmt_set_list
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_data_stmt
    start_index = index
    if node_cache[:data_stmt].has_key?(index)
      cached = node_cache[:data_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_data
      s0 << r3
      if r3
        r4 = _nt_data_stmt_set_list
        s0 << r4
        if r4
          r5 = _nt_t_newline
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(DataStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_stmt][start_index] = r0

    r0
  end

  def _nt_data_stmt_constant
    start_index = index
    if node_cache[:data_stmt_constant].has_key?(index)
      cached = node_cache[:data_stmt_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_signed_real_literal_constant
    if r1
      r0 = r1
    else
      r2 = _nt_signed_int_literal_constant
      if r2
        r0 = r2
      else
        r3 = _nt_boz_literal_constant
        if r3
          r0 = r3
        else
          r4 = _nt_structure_constructor
          if r4
            r0 = r4
          else
            r5 = _nt_scalar_constant
            if r5
              r0 = r5
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:data_stmt_constant][start_index] = r0

    r0
  end

  def _nt_data_stmt_object
    start_index = index
    if node_cache[:data_stmt_object].has_key?(index)
      cached = node_cache[:data_stmt_object][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_variable
    if r1
      r0 = r1
    else
      r2 = _nt_data_implied_do
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:data_stmt_object][start_index] = r0

    r0
  end

  module DataStmtObjectList0
    def t_comma
      elements[0]
    end

    def data_stmt_object
      elements[1]
    end
  end

  module DataStmtObjectList1
    def data_stmt_object
      elements[0]
    end

  end

  def _nt_data_stmt_object_list
    start_index = index
    if node_cache[:data_stmt_object_list].has_key?(index)
      cached = node_cache[:data_stmt_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_data_stmt_object
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_data_stmt_object
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(DataStmtObjectList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Data_Stmt_Object_List,input, i0...index, s0)
      r0.extend(DataStmtObjectList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_stmt_object_list][start_index] = r0

    r0
  end

  def _nt_data_stmt_repeat
    start_index = index
    if node_cache[:data_stmt_repeat].has_key?(index)
      cached = node_cache[:data_stmt_repeat][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_constant

    node_cache[:data_stmt_repeat][start_index] = r0

    r0
  end

  module DataStmtSet0
    def data_stmt_object_list
      elements[0]
    end

    def t_slash1
      elements[1]
    end

    def data_stmt_value_list
      elements[2]
    end

    def t_slash2
      elements[3]
    end
  end

  def _nt_data_stmt_set
    start_index = index
    if node_cache[:data_stmt_set].has_key?(index)
      cached = node_cache[:data_stmt_set][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_data_stmt_object_list
    s0 << r1
    if r1
      r2 = _nt_t_slash
      s0 << r2
      if r2
        r3 = _nt_data_stmt_value_list
        s0 << r3
        if r3
          r4 = _nt_t_slash
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(DataStmtSet0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_stmt_set][start_index] = r0

    r0
  end

  module DataStmtSetList0
    def data_stmt_set
      elements[0]
    end

    def data_stmt_set_list_pairs
      elements[1]
    end
  end

  def _nt_data_stmt_set_list
    start_index = index
    if node_cache[:data_stmt_set_list].has_key?(index)
      cached = node_cache[:data_stmt_set_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_data_stmt_set
    s0 << r1
    if r1
      r2 = _nt_data_stmt_set_list_pairs
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(DataStmtSetList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_stmt_set_list][start_index] = r0

    r0
  end

  module DataStmtSetListPair0
    def t_comma
      elements[0]
    end

    def data_stmt_set
      elements[1]
    end
  end

  def _nt_data_stmt_set_list_pair
    start_index = index
    if node_cache[:data_stmt_set_list_pair].has_key?(index)
      cached = node_cache[:data_stmt_set_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_data_stmt_set
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(DataStmtSetListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_stmt_set_list_pair][start_index] = r0

    r0
  end

  def _nt_data_stmt_set_list_pairs
    start_index = index
    if node_cache[:data_stmt_set_list_pairs].has_key?(index)
      cached = node_cache[:data_stmt_set_list_pairs][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_data_stmt_set_list_pair
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:data_stmt_set_list_pairs][start_index] = r0

    r0
  end

  module DataStmtValue0
    def data_stmt_constant
      elements[1]
    end
  end

  def _nt_data_stmt_value
    start_index = index
    if node_cache[:data_stmt_value].has_key?(index)
      cached = node_cache[:data_stmt_value][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_data_stmt_repeat_pair
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_data_stmt_constant
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(DataStmtValue0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_stmt_value][start_index] = r0

    r0
  end

  module DataStmtRepeatPair0
    def data_stmt_repeat
      elements[0]
    end

    def t_star
      elements[1]
    end
  end

  def _nt_data_stmt_repeat_pair
    start_index = index
    if node_cache[:data_stmt_repeat_pair].has_key?(index)
      cached = node_cache[:data_stmt_repeat_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_data_stmt_repeat
    s0 << r1
    if r1
      r2 = _nt_t_star
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(DataStmtRepeatPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_stmt_repeat_pair][start_index] = r0

    r0
  end

  module DataStmtValueList0
    def t_comma
      elements[0]
    end

    def data_stmt_value
      elements[1]
    end
  end

  module DataStmtValueList1
    def data_stmt_value
      elements[0]
    end

  end

  def _nt_data_stmt_value_list
    start_index = index
    if node_cache[:data_stmt_value_list].has_key?(index)
      cached = node_cache[:data_stmt_value_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_data_stmt_value
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_data_stmt_value
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(DataStmtValueList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Data_Stmt_Value_List,input, i0...index, s0)
      r0.extend(DataStmtValueList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:data_stmt_value_list][start_index] = r0

    r0
  end

  module DeallocateStmt0
    def label
      elements[0]
    end

    def t_deallocate
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def allocate_object_list
      elements[3]
    end

    def t_paren_r
      elements[5]
    end

    def t_newline
      elements[6]
    end
  end

  def _nt_deallocate_stmt
    start_index = index
    if node_cache[:deallocate_stmt].has_key?(index)
      cached = node_cache[:deallocate_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_deallocate
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_allocate_object_list
          s0 << r5
          if r5
            r7 = _nt_allocate_stat_construct
            if r7
              r6 = r7
            else
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r6
            if r6
              r8 = _nt_t_paren_r
              s0 << r8
              if r8
                r9 = _nt_t_newline
                s0 << r9
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Deallocate_Stmt,input, i0...index, s0)
      r0.extend(DeallocateStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:deallocate_stmt][start_index] = r0

    r0
  end

  module DeclarationConstruct0
    def stmt_function_stmt
      elements[0]
    end

  end

  def _nt_declaration_construct
    start_index = index
    if node_cache[:declaration_construct].has_key?(index)
      cached = node_cache[:declaration_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_derived_type_def
    if r1
      r0 = r1
    else
      r2 = _nt_interface_block
      if r2
        r0 = r2
      else
        r3 = _nt_type_declaration_stmt
        if r3
          r0 = r3
        else
          r4 = _nt_specification_stmt
          if r4
            r0 = r4
          else
            r5 = _nt_parameter_stmt
            if r5
              r0 = r5
            else
              r6 = _nt_format_stmt
              if r6
                r0 = r6
              else
                r7 = _nt_entry_stmt
                if r7
                  r0 = r7
                else
                  i8, s8 = index, []
                  r9 = _nt_stmt_function_stmt
                  s8 << r9
                  if r9
                    i10 = index
                    r11 = lambda { |e| sp_is_array?(e[0]) }.call(s8)
                    if r11
                      r10 = nil
                    else
                      @index = i10
                      r10 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s8 << r10
                  end
                  if s8.last
                    r8 = instantiate_node(E,input, i8...index, s8)
                    r8.extend(DeclarationConstruct0)
                  else
                    @index = i8
                    r8 = nil
                  end
                  if r8
                    r0 = r8
                  else
                    r12 = _nt_directive
                    if r12
                      r0 = r12
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:declaration_construct][start_index] = r0

    r0
  end

  module DeclarationConstructs0
  end

  def _nt_declaration_constructs
    start_index = index
    if node_cache[:declaration_constructs].has_key?(index)
      cached = node_cache[:declaration_constructs][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    s1, i1 = [], index
    loop do
      r2 = _nt_declaration_construct
      if r2
        s1 << r2
      else
        break
      end
    end
    r1 = instantiate_node(SyntaxNode,input, i1...index, s1)
    s0 << r1
    if r1
      if has_terminal?("", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure("")
        r3 = nil
      end
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(Declaration_Constructs,input, i0...index, s0)
      r0.extend(DeclarationConstructs0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:declaration_constructs][start_index] = r0

    r0
  end

  def _nt_default_char_variable
    start_index = index
    if node_cache[:default_char_variable].has_key?(index)
      cached = node_cache[:default_char_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable

    node_cache[:default_char_variable][start_index] = r0

    r0
  end

  def _nt_default_char_expr
    start_index = index
    if node_cache[:default_char_expr].has_key?(index)
      cached = node_cache[:default_char_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_expr

    node_cache[:default_char_expr][start_index] = r0

    r0
  end

  def _nt_default_int_variable
    start_index = index
    if node_cache[:default_int_variable].has_key?(index)
      cached = node_cache[:default_int_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable

    node_cache[:default_int_variable][start_index] = r0

    r0
  end

  def _nt_default_logical_variable
    start_index = index
    if node_cache[:default_logical_variable].has_key?(index)
      cached = node_cache[:default_logical_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable

    node_cache[:default_logical_variable][start_index] = r0

    r0
  end

  module DeferredShapeSpec0
    def t_colon
      elements[0]
    end

  end

  def _nt_deferred_shape_spec
    start_index = index
    if node_cache[:deferred_shape_spec].has_key?(index)
      cached = node_cache[:deferred_shape_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_colon
    s0 << r1
    if r1
      if has_terminal?("", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure("")
        r2 = nil
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Deferred_Shape_Spec,input, i0...index, s0)
      r0.extend(DeferredShapeSpec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:deferred_shape_spec][start_index] = r0

    r0
  end

  module DeferredShapeSpecList0
    def deferred_shape_spec
      elements[0]
    end

  end

  def _nt_deferred_shape_spec_list
    start_index = index
    if node_cache[:deferred_shape_spec_list].has_key?(index)
      cached = node_cache[:deferred_shape_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_deferred_shape_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_deferred_shape_spec_list_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Deferred_Shape_Spec_List,input, i0...index, s0)
      r0.extend(DeferredShapeSpecList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:deferred_shape_spec_list][start_index] = r0

    r0
  end

  module DeferredShapeSpecListPair0
    def t_comma
      elements[0]
    end

    def deferred_shape_spec
      elements[1]
    end
  end

  def _nt_deferred_shape_spec_list_pair
    start_index = index
    if node_cache[:deferred_shape_spec_list_pair].has_key?(index)
      cached = node_cache[:deferred_shape_spec_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_deferred_shape_spec
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Deferred_Shape_Spec_List_Pair,input, i0...index, s0)
      r0.extend(DeferredShapeSpecListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:deferred_shape_spec_list_pair][start_index] = r0

    r0
  end

  module DefinedBinaryOp0
    def t_dot1
      elements[0]
    end

    def t_letter
      elements[1]
    end

    def t_dot2
      elements[3]
    end
  end

  def _nt_defined_binary_op
    start_index = index
    if node_cache[:defined_binary_op].has_key?(index)
      cached = node_cache[:defined_binary_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_dot
    s0 << r1
    if r1
      r2 = _nt_t_letter
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_t_letter
          if r4
            s3 << r4
          else
            break
          end
        end
        if s3.empty?
          @index = i3
          r3 = nil
        else
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        end
        s0 << r3
        if r3
          r5 = _nt_t_dot
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(DefinedBinaryOp0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:defined_binary_op][start_index] = r0

    r0
  end

  def _nt_defined_operator
    start_index = index
    if node_cache[:defined_operator].has_key?(index)
      cached = node_cache[:defined_operator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_defined_unary_op
    if r1
      r0 = r1
    else
      r2 = _nt_defined_binary_op
      if r2
        r0 = r2
      else
        r3 = _nt_extended_intrinsic_op
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:defined_operator][start_index] = r0

    r0
  end

  module DefinedUnaryOp0
    def t_dot1
      elements[1]
    end

    def t_letter
      elements[2]
    end

    def t_dot2
      elements[4]
    end
  end

  def _nt_defined_unary_op
    start_index = index
    if node_cache[:defined_unary_op].has_key?(index)
      cached = node_cache[:defined_unary_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    i2 = index
    r3 = _nt_intrinsic_operator
    if r3
      r2 = r3
    else
      r4 = _nt_logical_literal_constant
      if r4
        r2 = r4
      else
        @index = i2
        r2 = nil
      end
    end
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r5 = _nt_t_dot
      s0 << r5
      if r5
        r6 = _nt_t_letter
        s0 << r6
        if r6
          s7, i7 = [], index
          loop do
            r8 = _nt_t_letter
            if r8
              s7 << r8
            else
              break
            end
          end
          if s7.empty?
            @index = i7
            r7 = nil
          else
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          end
          s0 << r7
          if r7
            r9 = _nt_t_dot
            s0 << r9
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(DefinedUnaryOp0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:defined_unary_op][start_index] = r0

    r0
  end

  module DerivedTypeDef0
    def derived_type_stmt
      elements[0]
    end

    def private_sequence_stmts
      elements[1]
    end

    def component_def_stmts
      elements[2]
    end

    def end_type_stmt
      elements[3]
    end
  end

  def _nt_derived_type_def
    start_index = index
    if node_cache[:derived_type_def].has_key?(index)
      cached = node_cache[:derived_type_def][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_derived_type_stmt
    s0 << r1
    if r1
      r2 = _nt_private_sequence_stmts
      s0 << r2
      if r2
        r3 = _nt_component_def_stmts
        s0 << r3
        if r3
          r4 = _nt_end_type_stmt
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(DerivedTypeDef0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:derived_type_def][start_index] = r0

    r0
  end

  module DerivedTypeStmt0
    def label
      elements[0]
    end

    def t_type
      elements[1]
    end

    def type_name
      elements[3]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_derived_type_stmt
    start_index = index
    if node_cache[:derived_type_stmt].has_key?(index)
      cached = node_cache[:derived_type_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_type
      s0 << r3
      if r3
        r5 = _nt_derived_typeaccess_spec
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_type_name
          s0 << r6
          if r6
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Derived_Type_Stmt,input, i0...index, s0)
      r0.extend(DerivedTypeStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:derived_type_stmt][start_index] = r0

    r0
  end

  module DerivedTypeaccessSpec0
    def t_comma
      elements[0]
    end

    def access_spec
      elements[1]
    end
  end

  module DerivedTypeaccessSpec1
    def double_colon
      elements[1]
    end
  end

  def _nt_derived_typeaccess_spec
    start_index = index
    if node_cache[:derived_typeaccess_spec].has_key?(index)
      cached = node_cache[:derived_typeaccess_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i2, s2 = index, []
    r3 = _nt_t_comma
    s2 << r3
    if r3
      r4 = _nt_access_spec
      s2 << r4
    end
    if s2.last
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      r2.extend(DerivedTypeaccessSpec0)
    else
      @index = i2
      r2 = nil
    end
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r5 = _nt_double_colon
      s0 << r5
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(DerivedTypeaccessSpec1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:derived_typeaccess_spec][start_index] = r0

    r0
  end

  def _nt_digit_string
    start_index = index
    if node_cache[:digit_string].has_key?(index)
      cached = node_cache[:digit_string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_t_digit
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(T,input, i0...index, s0)
    end

    node_cache[:digit_string][start_index] = r0

    r0
  end

  module DimensionStmt0
    def label
      elements[0]
    end

    def t_dimension
      elements[1]
    end

    def array_names_and_specs
      elements[3]
    end

    def t_newline
      elements[4]
    end

  end

  def _nt_dimension_stmt
    start_index = index
    if node_cache[:dimension_stmt].has_key?(index)
      cached = node_cache[:dimension_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_dimension
      s0 << r3
      if r3
        r5 = _nt_double_colon
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_array_names_and_specs
          s0 << r6
          if r6
            r7 = _nt_t_newline
            s0 << r7
            if r7
              i8 = index
              r9 = lambda { |e| sp_dimension_stmt(e[3]) }.call(s0)
              if r9
                @index = i8
                r8 = instantiate_node(SyntaxNode,input, index...index)
              else
                r8 = nil
              end
              s0 << r8
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Dimension_Stmt,input, i0...index, s0)
      r0.extend(DimensionStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:dimension_stmt][start_index] = r0

    r0
  end

  module Directive0
    def t_newline
      elements[2]
    end
  end

  def _nt_directive
    start_index = index
    if node_cache[:directive].has_key?(index)
      cached = node_cache[:directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("!", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("!")
      r1 = nil
    end
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_character
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_t_newline
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(Directive0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:directive][start_index] = r0

    r0
  end

  def _nt_do_block
    start_index = index
    if node_cache[:do_block].has_key?(index)
      cached = node_cache[:do_block][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_block

    node_cache[:do_block][start_index] = r0

    r0
  end

  def _nt_do_body
    start_index = index
    if node_cache[:do_body].has_key?(index)
      cached = node_cache[:do_body][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_execution_part_construct

    node_cache[:do_body][start_index] = r0

    r0
  end

  def _nt_do_construct
    start_index = index
    if node_cache[:do_construct].has_key?(index)
      cached = node_cache[:do_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_nonblock_do_construct
    if r1
      r0 = r1
    else
      r2 = _nt_block_do_construct
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:do_construct][start_index] = r0

    r0
  end

  def _nt_do_construct_name
    start_index = index
    if node_cache[:do_construct_name].has_key?(index)
      cached = node_cache[:do_construct_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:do_construct_name][start_index] = r0

    r0
  end

  module DoConstructNameLabel0
    def do_construct_name
      elements[0]
    end

    def t_colon
      elements[1]
    end
  end

  def _nt_do_construct_name_label
    start_index = index
    if node_cache[:do_construct_name_label].has_key?(index)
      cached = node_cache[:do_construct_name_label][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_do_construct_name
    s0 << r1
    if r1
      r2 = _nt_t_colon
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(DoConstructNameLabel0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:do_construct_name_label][start_index] = r0

    r0
  end

  def _nt_do_stmt
    start_index = index
    if node_cache[:do_stmt].has_key?(index)
      cached = node_cache[:do_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_label_do_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_nonlabel_do_stmt
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:do_stmt][start_index] = r0

    r0
  end

  module DoTermActionStmt0
    def action_stmt
      elements[1]
    end

  end

  def _nt_do_term_action_stmt
    start_index = index
    if node_cache[:do_term_action_stmt].has_key?(index)
      cached = node_cache[:do_term_action_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_do_term_action_stmt_disallowed
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_action_stmt
      s0 << r3
      if r3
        i4 = index
        r5 = lambda { |e| nonblock_do_end!(e[1]) }.call(s0)
        if r5
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        else
          r4 = nil
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(Do_Term_Action_Stmt,input, i0...index, s0)
      r0.extend(DoTermActionStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:do_term_action_stmt][start_index] = r0

    r0
  end

  def _nt_do_term_action_stmt_disallowed
    start_index = index
    if node_cache[:do_term_action_stmt_disallowed].has_key?(index)
      cached = node_cache[:do_term_action_stmt_disallowed][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_arithmetic_if_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_assigned_goto_stmt
      if r2
        r0 = r2
      else
        r3 = _nt_continue_stmt
        if r3
          r0 = r3
        else
          r4 = _nt_cycle_stmt
          if r4
            r0 = r4
          else
            r5 = _nt_end_function_stmt
            if r5
              r0 = r5
            else
              r6 = _nt_end_program_stmt
              if r6
                r0 = r6
              else
                r7 = _nt_end_subroutine_stmt
                if r7
                  r0 = r7
                else
                  r8 = _nt_exit_stmt
                  if r8
                    r0 = r8
                  else
                    r9 = _nt_goto_stmt
                    if r9
                      r0 = r9
                    else
                      r10 = _nt_return_stmt
                      if r10
                        r0 = r10
                      else
                        r11 = _nt_stop_stmt
                        if r11
                          r0 = r11
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:do_term_action_stmt_disallowed][start_index] = r0

    r0
  end

  module DoTermSharedStmt0
    def action_stmt
      elements[1]
    end

  end

  def _nt_do_term_shared_stmt
    start_index = index
    if node_cache[:do_term_shared_stmt].has_key?(index)
      cached = node_cache[:do_term_shared_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_do_term_shared_stmt_disallowed
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_action_stmt
      s0 << r3
      if r3
        i4 = index
        r5 = lambda { |e| nonblock_do_end!(e[1]) }.call(s0)
        if r5
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        else
          r4 = nil
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(Do_Term_Shared_Stmt,input, i0...index, s0)
      r0.extend(DoTermSharedStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:do_term_shared_stmt][start_index] = r0

    r0
  end

  def _nt_do_term_shared_stmt_disallowed
    start_index = index
    if node_cache[:do_term_shared_stmt_disallowed].has_key?(index)
      cached = node_cache[:do_term_shared_stmt_disallowed][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_arithmetic_if_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_assigned_goto_stmt
      if r2
        r0 = r2
      else
        r3 = _nt_cycle_stmt
        if r3
          r0 = r3
        else
          r4 = _nt_end_function_stmt
          if r4
            r0 = r4
          else
            r5 = _nt_end_program_stmt
            if r5
              r0 = r5
            else
              r6 = _nt_end_subroutine_stmt
              if r6
                r0 = r6
              else
                r7 = _nt_exit_stmt
                if r7
                  r0 = r7
                else
                  r8 = _nt_goto_stmt
                  if r8
                    r0 = r8
                  else
                    r9 = _nt_return_stmt
                    if r9
                      r0 = r9
                    else
                      r10 = _nt_stop_stmt
                      if r10
                        r0 = r10
                      else
                        @index = i0
                        r0 = nil
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:do_term_shared_stmt_disallowed][start_index] = r0

    r0
  end

  def _nt_do_variable
    start_index = index
    if node_cache[:do_variable].has_key?(index)
      cached = node_cache[:do_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_variable

    node_cache[:do_variable][start_index] = r0

    r0
  end

  module DoubleColon0
    def t_colon1
      elements[0]
    end

    def t_colon2
      elements[1]
    end
  end

  def _nt_double_colon
    start_index = index
    if node_cache[:double_colon].has_key?(index)
      cached = node_cache[:double_colon][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_colon
    s0 << r1
    if r1
      r2 = _nt_t_colon
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Double_Colon,input, i0...index, s0)
      r0.extend(DoubleColon0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:double_colon][start_index] = r0

    r0
  end

  def _nt_dummy_arg
    start_index = index
    if node_cache[:dummy_arg].has_key?(index)
      cached = node_cache[:dummy_arg][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_dummy_arg_name
    if r1
      r0 = r1
    else
      r2 = _nt_t_star
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:dummy_arg][start_index] = r0

    r0
  end

  module DummyArgList0
    def t_comma
      elements[0]
    end

    def dummy_arg
      elements[1]
    end
  end

  module DummyArgList1
    def dummy_arg
      elements[0]
    end

  end

  def _nt_dummy_arg_list
    start_index = index
    if node_cache[:dummy_arg_list].has_key?(index)
      cached = node_cache[:dummy_arg_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_dummy_arg
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_dummy_arg
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(DummyArgList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Dummy_Arg_List,input, i0...index, s0)
      r0.extend(DummyArgList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:dummy_arg_list][start_index] = r0

    r0
  end

  module DummyArgListOption0
    def t_paren_l
      elements[0]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_dummy_arg_list_option
    start_index = index
    if node_cache[:dummy_arg_list_option].has_key?(index)
      cached = node_cache[:dummy_arg_list_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r3 = _nt_dummy_arg_list
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_t_paren_r
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(DummyArgListOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:dummy_arg_list_option][start_index] = r0

    r0
  end

  def _nt_dummy_arg_name
    start_index = index
    if node_cache[:dummy_arg_name].has_key?(index)
      cached = node_cache[:dummy_arg_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:dummy_arg_name][start_index] = r0

    r0
  end

  module DummyArgNameList0
    def t_comma
      elements[0]
    end

    def dummy_arg_name
      elements[1]
    end
  end

  module DummyArgNameList1
    def dummy_arg_name
      elements[0]
    end

  end

  def _nt_dummy_arg_name_list
    start_index = index
    if node_cache[:dummy_arg_name_list].has_key?(index)
      cached = node_cache[:dummy_arg_name_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_dummy_arg_name
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_dummy_arg_name
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(DummyArgNameList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Dummy_Arg_Name_List,input, i0...index, s0)
      r0.extend(DummyArgNameList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:dummy_arg_name_list][start_index] = r0

    r0
  end

  module ElseConstruct0
    def else_stmt
      elements[0]
    end

    def block
      elements[1]
    end
  end

  def _nt_else_construct
    start_index = index
    if node_cache[:else_construct].has_key?(index)
      cached = node_cache[:else_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_else_stmt
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ElseConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:else_construct][start_index] = r0

    r0
  end

  def _nt_else_if_construct
    start_index = index
    if node_cache[:else_if_construct].has_key?(index)
      cached = node_cache[:else_if_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_else_if_construct_element
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(E,input, i0...index, s0)
    end

    node_cache[:else_if_construct][start_index] = r0

    r0
  end

  module ElseIfConstructElement0
    def else_if_stmt
      elements[0]
    end

    def block
      elements[1]
    end
  end

  def _nt_else_if_construct_element
    start_index = index
    if node_cache[:else_if_construct_element].has_key?(index)
      cached = node_cache[:else_if_construct_element][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_else_if_stmt
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ElseIfConstructElement0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:else_if_construct_element][start_index] = r0

    r0
  end

  module ElseIfStmt0
    def label
      elements[0]
    end

    def t_elseif
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def scalar_logical_expr
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_then
      elements[5]
    end

    def t_newline
      elements[6]
    end
  end

  def _nt_else_if_stmt
    start_index = index
    if node_cache[:else_if_stmt].has_key?(index)
      cached = node_cache[:else_if_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_elseif
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_scalar_logical_expr
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r7 = _nt_t_then
              s0 << r7
              if r7
                r8 = _nt_t_newline
                s0 << r8
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Else_If_Stmt,input, i0...index, s0)
      r0.extend(ElseIfStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:else_if_stmt][start_index] = r0

    r0
  end

  module ElseStmt0
    def label
      elements[0]
    end

    def t_else
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_else_stmt
    start_index = index
    if node_cache[:else_stmt].has_key?(index)
      cached = node_cache[:else_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_else
      s0 << r3
      if r3
        r5 = _nt_if_construct_name
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Else_Stmt,input, i0...index, s0)
      r0.extend(ElseStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:else_stmt][start_index] = r0

    r0
  end

  module ElsewhereConstruct0
    def elsewhere_stmt
      elements[0]
    end

    def where_assignment_stmt_block
      elements[1]
    end
  end

  def _nt_elsewhere_construct
    start_index = index
    if node_cache[:elsewhere_construct].has_key?(index)
      cached = node_cache[:elsewhere_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_elsewhere_stmt
    s0 << r1
    if r1
      r2 = _nt_where_assignment_stmt_block
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ElsewhereConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:elsewhere_construct][start_index] = r0

    r0
  end

  module ElsewhereStmt0
    def label
      elements[0]
    end

    def t_elsewhere
      elements[1]
    end

    def t_newline
      elements[2]
    end
  end

  def _nt_elsewhere_stmt
    start_index = index
    if node_cache[:elsewhere_stmt].has_key?(index)
      cached = node_cache[:elsewhere_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_elsewhere
      s0 << r3
      if r3
        r4 = _nt_t_newline
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(Elsewhere_Stmt,input, i0...index, s0)
      r0.extend(ElsewhereStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:elsewhere_stmt][start_index] = r0

    r0
  end

  module EndBlockDataOption0
    def t_block
      elements[0]
    end

    def t_data
      elements[1]
    end

  end

  def _nt_end_block_data_option
    start_index = index
    if node_cache[:end_block_data_option].has_key?(index)
      cached = node_cache[:end_block_data_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_block
    s0 << r1
    if r1
      r2 = _nt_t_data
      s0 << r2
      if r2
        r4 = _nt_block_data_name
        if r4
          r3 = r4
        else
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(End_Block_Data_Option,input, i0...index, s0)
      r0.extend(EndBlockDataOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_block_data_option][start_index] = r0

    r0
  end

  module EndBlockDataStmt0
    def label
      elements[0]
    end

    def t_end
      elements[1]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_end_block_data_stmt
    start_index = index
    if node_cache[:end_block_data_stmt].has_key?(index)
      cached = node_cache[:end_block_data_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_end
      s0 << r3
      if r3
        r5 = _nt_end_block_data_option
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
          if r6
            i7 = index
            r8 = lambda { |e| sp_end_block_data_stmt }.call(s0)
            if r8
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            else
              r7 = nil
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Block_Data_Stmt,input, i0...index, s0)
      r0.extend(EndBlockDataStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_block_data_stmt][start_index] = r0

    r0
  end

  def _nt_end_do
    start_index = index
    if node_cache[:end_do].has_key?(index)
      cached = node_cache[:end_do][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_end_do_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_end_do_continue_stmt
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:end_do][start_index] = r0

    r0
  end

  module EndDoContinueStmt0
    def label
      elements[0]
    end

    def t_continue
      elements[1]
    end

    def t_newline
      elements[2]
    end

  end

  def _nt_end_do_continue_stmt
    start_index = index
    if node_cache[:end_do_continue_stmt].has_key?(index)
      cached = node_cache[:end_do_continue_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_continue
      s0 << r3
      if r3
        r4 = _nt_t_newline
        s0 << r4
        if r4
          i5 = index
          r6 = lambda { |e| dolabel_pop(e[0]) }.call(s0)
          if r6
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          else
            r5 = nil
          end
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Do_Stmt,input, i0...index, s0)
      r0.extend(EndDoContinueStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_do_continue_stmt][start_index] = r0

    r0
  end

  module EndDoStmt0
    def label
      elements[0]
    end

    def t_enddo
      elements[1]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_end_do_stmt
    start_index = index
    if node_cache[:end_do_stmt].has_key?(index)
      cached = node_cache[:end_do_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_enddo
      s0 << r3
      if r3
        r5 = _nt_do_construct_name
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
          if r6
            i7 = index
            r8 = lambda { |e| dolabel_pop(e[0]) }.call(s0)
            if r8
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            else
              r7 = nil
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Do_Stmt,input, i0...index, s0)
      r0.extend(EndDoStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_do_stmt][start_index] = r0

    r0
  end

  module EndFunctionOption0
    def t_function
      elements[0]
    end

  end

  def _nt_end_function_option
    start_index = index
    if node_cache[:end_function_option].has_key?(index)
      cached = node_cache[:end_function_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_function
    s0 << r1
    if r1
      r3 = _nt_function_name
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(J,input, i0...index, s0)
      r0.extend(EndFunctionOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_function_option][start_index] = r0

    r0
  end

  module EndFunctionStmt0
    def label
      elements[0]
    end

    def t_end
      elements[1]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_end_function_stmt
    start_index = index
    if node_cache[:end_function_stmt].has_key?(index)
      cached = node_cache[:end_function_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_end
      s0 << r3
      if r3
        r5 = _nt_end_function_option
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
          if r6
            i7 = index
            r8 = lambda { |e| sp_end_function_stmt }.call(s0)
            if r8
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            else
              r7 = nil
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Function_Stmt,input, i0...index, s0)
      r0.extend(EndFunctionStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_function_stmt][start_index] = r0

    r0
  end

  module EndIfStmt0
    def label
      elements[0]
    end

    def t_endif
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_end_if_stmt
    start_index = index
    if node_cache[:end_if_stmt].has_key?(index)
      cached = node_cache[:end_if_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_endif
      s0 << r3
      if r3
        r5 = _nt_if_construct_name
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_If_Stmt,input, i0...index, s0)
      r0.extend(EndIfStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_if_stmt][start_index] = r0

    r0
  end

  module EndInterfaceStmt0
    def label
      elements[0]
    end

    def t_end
      elements[1]
    end

    def t_interface
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_end_interface_stmt
    start_index = index
    if node_cache[:end_interface_stmt].has_key?(index)
      cached = node_cache[:end_interface_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_end
      s0 << r3
      if r3
        r4 = _nt_t_interface
        s0 << r4
        if r4
          r5 = _nt_t_newline
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Interface_Stmt,input, i0...index, s0)
      r0.extend(EndInterfaceStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_interface_stmt][start_index] = r0

    r0
  end

  module EndModuleOption0
    def t_module
      elements[0]
    end

  end

  def _nt_end_module_option
    start_index = index
    if node_cache[:end_module_option].has_key?(index)
      cached = node_cache[:end_module_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_module
    s0 << r1
    if r1
      r3 = _nt_module_name
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(End_Module_Option,input, i0...index, s0)
      r0.extend(EndModuleOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_module_option][start_index] = r0

    r0
  end

  module EndModuleStmt0
    def label
      elements[0]
    end

    def t_end
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_end_module_stmt
    start_index = index
    if node_cache[:end_module_stmt].has_key?(index)
      cached = node_cache[:end_module_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_end
      s0 << r3
      if r3
        r5 = _nt_end_module_option
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Module_Stmt,input, i0...index, s0)
      r0.extend(EndModuleStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_module_stmt][start_index] = r0

    r0
  end

  module EndProgramStmt0
    def label
      elements[0]
    end

    def t_end
      elements[1]
    end

  end

  def _nt_end_program_stmt
    start_index = index
    if node_cache[:end_program_stmt].has_key?(index)
      cached = node_cache[:end_program_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_end
      s0 << r3
      if r3
        i4 = index
        r5 = _nt_end_program_stmt_disallowed
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r7 = _nt_t_program
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r6
          if r6
            r9 = _nt_program_name
            if r9
              r8 = r9
            else
              r8 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r8
            if r8
              r11 = _nt_t_newline
              if r11
                r10 = r11
              else
                r10 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r10
              if r10
                i12 = index
                r13 = lambda { |e| sp_end_program_stmt }.call(s0)
                if r13
                  @index = i12
                  r12 = instantiate_node(SyntaxNode,input, index...index)
                else
                  r12 = nil
                end
                s0 << r12
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Program_Stmt,input, i0...index, s0)
      r0.extend(EndProgramStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_program_stmt][start_index] = r0

    r0
  end

  def _nt_end_program_stmt_disallowed
    start_index = index
    if node_cache[:end_program_stmt_disallowed].has_key?(index)
      cached = node_cache[:end_program_stmt_disallowed][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_block
    if r1
      r0 = r1
    else
      r2 = _nt_t_function
      if r2
        r0 = r2
      else
        r3 = _nt_t_interface
        if r3
          r0 = r3
        else
          r4 = _nt_t_module
          if r4
            r0 = r4
          else
            r5 = _nt_t_select
            if r5
              r0 = r5
            else
              r6 = _nt_t_subroutine
              if r6
                r0 = r6
              else
                r7 = _nt_t_type
                if r7
                  r0 = r7
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end
      end
    end

    node_cache[:end_program_stmt_disallowed][start_index] = r0

    r0
  end

  module EndSelectStmt0
    def label
      elements[0]
    end

    def t_end
      elements[1]
    end

    def t_select
      elements[2]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_end_select_stmt
    start_index = index
    if node_cache[:end_select_stmt].has_key?(index)
      cached = node_cache[:end_select_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_end
      s0 << r3
      if r3
        r4 = _nt_t_select
        s0 << r4
        if r4
          r6 = _nt_case_construct_name
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Select_Stmt,input, i0...index, s0)
      r0.extend(EndSelectStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_select_stmt][start_index] = r0

    r0
  end

  module EndSubroutineStmt0
    def label
      elements[0]
    end

    def t_end
      elements[1]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_end_subroutine_stmt
    start_index = index
    if node_cache[:end_subroutine_stmt].has_key?(index)
      cached = node_cache[:end_subroutine_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_end
      s0 << r3
      if r3
        r5 = _nt_end_subroutine_option
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
          if r6
            i7 = index
            r8 = lambda { |e| sp_end_subroutine_stmt }.call(s0)
            if r8
              @index = i7
              r7 = instantiate_node(SyntaxNode,input, index...index)
            else
              r7 = nil
            end
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Subroutine_Stmt,input, i0...index, s0)
      r0.extend(EndSubroutineStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_subroutine_stmt][start_index] = r0

    r0
  end

  module EndSubroutineOption0
    def t_subroutine
      elements[0]
    end

  end

  def _nt_end_subroutine_option
    start_index = index
    if node_cache[:end_subroutine_option].has_key?(index)
      cached = node_cache[:end_subroutine_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_subroutine
    s0 << r1
    if r1
      r3 = _nt_subroutine_name
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(J,input, i0...index, s0)
      r0.extend(EndSubroutineOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_subroutine_option][start_index] = r0

    r0
  end

  module EndTypeStmt0
    def label
      elements[0]
    end

    def t_end
      elements[1]
    end

    def t_type
      elements[2]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_end_type_stmt
    start_index = index
    if node_cache[:end_type_stmt].has_key?(index)
      cached = node_cache[:end_type_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_end
      s0 << r3
      if r3
        r4 = _nt_t_type
        s0 << r4
        if r4
          r6 = _nt_type_name
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(End_Type_Stmt,input, i0...index, s0)
      r0.extend(EndTypeStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_type_stmt][start_index] = r0

    r0
  end

  module EndWhereStmt0
    def label
      elements[0]
    end

    def t_endwhere
      elements[1]
    end

    def t_newline
      elements[2]
    end
  end

  def _nt_end_where_stmt
    start_index = index
    if node_cache[:end_where_stmt].has_key?(index)
      cached = node_cache[:end_where_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_endwhere
      s0 << r3
      if r3
        r4 = _nt_t_newline
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(End_Where_Stmt,input, i0...index, s0)
      r0.extend(EndWhereStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:end_where_stmt][start_index] = r0

    r0
  end

  module EndfileStmt0
    def label
      elements[0]
    end

    def t_endfile
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def position_spec_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  module EndfileStmt1
    def label
      elements[0]
    end

    def t_endfile
      elements[1]
    end

    def external_file_unit
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_endfile_stmt
    start_index = index
    if node_cache[:endfile_stmt].has_key?(index)
      cached = node_cache[:endfile_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_label
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r4 = _nt_t_endfile
      s1 << r4
      if r4
        r5 = _nt_t_paren_l
        s1 << r5
        if r5
          r6 = _nt_position_spec_list
          s1 << r6
          if r6
            r7 = _nt_t_paren_r
            s1 << r7
            if r7
              r8 = _nt_t_newline
              s1 << r8
            end
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(StmtC,input, i1...index, s1)
      r1.extend(EndfileStmt0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i9, s9 = index, []
      r11 = _nt_label
      if r11
        r10 = r11
      else
        r10 = instantiate_node(SyntaxNode,input, index...index)
      end
      s9 << r10
      if r10
        r12 = _nt_t_endfile
        s9 << r12
        if r12
          r13 = _nt_external_file_unit
          s9 << r13
          if r13
            r14 = _nt_t_newline
            s9 << r14
          end
        end
      end
      if s9.last
        r9 = instantiate_node(StmtJ,input, i9...index, s9)
        r9.extend(EndfileStmt1)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r0 = r9
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:endfile_stmt][start_index] = r0

    r0
  end

  module EntityDecl0
    def object_name
      elements[0]
    end

  end

  module EntityDecl1
    def function_name
      elements[0]
    end

  end

  def _nt_entity_decl
    start_index = index
    if node_cache[:entity_decl].has_key?(index)
      cached = node_cache[:entity_decl][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_object_name
    s1 << r2
    if r2
      r4 = _nt_entity_decl_array_spec
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r3
      if r3
        r6 = _nt_char_length_pair
        if r6
          r5 = r6
        else
          r5 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r5
        if r5
          r8 = _nt_initialization
          if r8
            r7 = r8
          else
            r7 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r7
        end
      end
    end
    if s1.last
      r1 = instantiate_node(Entity_Decl_1,input, i1...index, s1)
      r1.extend(EntityDecl0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i9, s9 = index, []
      r10 = _nt_function_name
      s9 << r10
      if r10
        r12 = _nt_char_length_pair
        if r12
          r11 = r12
        else
          r11 = instantiate_node(SyntaxNode,input, index...index)
        end
        s9 << r11
      end
      if s9.last
        r9 = instantiate_node(Entity_Decl_2,input, i9...index, s9)
        r9.extend(EntityDecl1)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r0 = r9
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:entity_decl][start_index] = r0

    r0
  end

  module EntityDeclArraySpec0
    def t_paren_l
      elements[0]
    end

    def array_spec
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_entity_decl_array_spec
    start_index = index
    if node_cache[:entity_decl_array_spec].has_key?(index)
      cached = node_cache[:entity_decl_array_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_array_spec
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(Entity_Decl_Array_Spec,input, i0...index, s0)
      r0.extend(EntityDeclArraySpec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:entity_decl_array_spec][start_index] = r0

    r0
  end

  module EntityDeclList0
    def entity_decl
      elements[0]
    end

    def entity_decl_list_pairs
      elements[1]
    end
  end

  def _nt_entity_decl_list
    start_index = index
    if node_cache[:entity_decl_list].has_key?(index)
      cached = node_cache[:entity_decl_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_entity_decl
    s0 << r1
    if r1
      r2 = _nt_entity_decl_list_pairs
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Entity_Decl_List,input, i0...index, s0)
      r0.extend(EntityDeclList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:entity_decl_list][start_index] = r0

    r0
  end

  module EntityDeclListPair0
    def t_comma
      elements[0]
    end

    def entity_decl
      elements[1]
    end
  end

  def _nt_entity_decl_list_pair
    start_index = index
    if node_cache[:entity_decl_list_pair].has_key?(index)
      cached = node_cache[:entity_decl_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_entity_decl
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Entity_Decl_List_Pair,input, i0...index, s0)
      r0.extend(EntityDeclListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:entity_decl_list_pair][start_index] = r0

    r0
  end

  def _nt_entity_decl_list_pairs
    start_index = index
    if node_cache[:entity_decl_list_pairs].has_key?(index)
      cached = node_cache[:entity_decl_list_pairs][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_entity_decl_list_pair
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(Entity_Decl_List_Pairs,input, i0...index, s0)

    node_cache[:entity_decl_list_pairs][start_index] = r0

    r0
  end

  def _nt_entry_name
    start_index = index
    if node_cache[:entry_name].has_key?(index)
      cached = node_cache[:entry_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:entry_name][start_index] = r0

    r0
  end

  module EntryStmt0
    def label
      elements[0]
    end

    def t_entry
      elements[1]
    end

    def entry_name
      elements[2]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_entry_stmt
    start_index = index
    if node_cache[:entry_stmt].has_key?(index)
      cached = node_cache[:entry_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_entry
      s0 << r3
      if r3
        r4 = _nt_entry_name
        s0 << r4
        if r4
          r6 = _nt_dummy_arg_list_option
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r8 = _nt_result_option
            if r8
              r7 = r8
            else
              r7 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r7
            if r7
              r9 = _nt_t_newline
              s0 << r9
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Entry_Stmt,input, i0...index, s0)
      r0.extend(EntryStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:entry_stmt][start_index] = r0

    r0
  end

  def _nt_equiv_op
    start_index = index
    if node_cache[:equiv_op].has_key?(index)
      cached = node_cache[:equiv_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(".eqv.", false, index)
      r1 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure(".eqv.")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?(".neqv.", false, index)
        r2 = instantiate_node(T,input, index...(index + 6))
        @index += 6
      else
        terminal_parse_failure(".neqv.")
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:equiv_op][start_index] = r0

    r0
  end

  module EquivOperand0
    def level_4_expr
      elements[1]
    end
  end

  def _nt_equiv_operand
    start_index = index
    if node_cache[:equiv_operand].has_key?(index)
      cached = node_cache[:equiv_operand][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_not_op
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_level_4_expr
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(EquivOperand0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:equiv_operand][start_index] = r0

    r0
  end

  def _nt_equivalence_object
    start_index = index
    if node_cache[:equivalence_object].has_key?(index)
      cached = node_cache[:equivalence_object][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_substring
    if r1
      r0 = r1
    else
      r2 = _nt_array_element
      if r2
        r0 = r2
      else
        r3 = _nt_variable_name
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:equivalence_object][start_index] = r0

    r0
  end

  module EquivalenceObjectList0
    def t_comma
      elements[0]
    end

    def equivalence_object
      elements[1]
    end
  end

  module EquivalenceObjectList1
    def equivalence_object
      elements[0]
    end

  end

  def _nt_equivalence_object_list
    start_index = index
    if node_cache[:equivalence_object_list].has_key?(index)
      cached = node_cache[:equivalence_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_equivalence_object
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_t_comma
      s3 << r4
      if r4
        r5 = _nt_equivalence_object
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(EquivalenceObjectList0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(EquivalenceObjectList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:equivalence_object_list][start_index] = r0

    r0
  end

  module EquivalenceSet0
    def t_paren_l
      elements[0]
    end

    def equivalence_object
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def equivalence_object_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end
  end

  def _nt_equivalence_set
    start_index = index
    if node_cache[:equivalence_set].has_key?(index)
      cached = node_cache[:equivalence_set][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_equivalence_object
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_equivalence_object_list
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(EquivalenceSet0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:equivalence_set][start_index] = r0

    r0
  end

  module EquivalenceSetList0
    def t_comma
      elements[0]
    end

    def equivalence_set
      elements[1]
    end
  end

  module EquivalenceSetList1
    def equivalence_set
      elements[0]
    end

  end

  def _nt_equivalence_set_list
    start_index = index
    if node_cache[:equivalence_set_list].has_key?(index)
      cached = node_cache[:equivalence_set_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_equivalence_set
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_equivalence_set
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(EquivalenceSetList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Equivalence_Set_List,input, i0...index, s0)
      r0.extend(EquivalenceSetList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:equivalence_set_list][start_index] = r0

    r0
  end

  module EquivalenceStmt0
    def label
      elements[0]
    end

    def t_equivalence
      elements[1]
    end

    def equivalence_set_list
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_equivalence_stmt
    start_index = index
    if node_cache[:equivalence_stmt].has_key?(index)
      cached = node_cache[:equivalence_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_equivalence
      s0 << r3
      if r3
        r4 = _nt_equivalence_set_list
        s0 << r4
        if r4
          r5 = _nt_t_newline
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(EquivalenceStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:equivalence_stmt][start_index] = r0

    r0
  end

  def _nt_executable_construct
    start_index = index
    if node_cache[:executable_construct].has_key?(index)
      cached = node_cache[:executable_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_executable_construct_action_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_case_construct
      if r2
        r0 = r2
      else
        r3 = _nt_do_construct
        if r3
          r0 = r3
        else
          r4 = _nt_if_construct
          if r4
            r0 = r4
          else
            r5 = _nt_where_construct
            if r5
              r0 = r5
            else
              r6 = _nt_directive
              if r6
                r0 = r6
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end
    end

    node_cache[:executable_construct][start_index] = r0

    r0
  end

  module ExecutableConstructActionStmt0
    def action_stmt
      elements[1]
    end

  end

  def _nt_executable_construct_action_stmt
    start_index = index
    if node_cache[:executable_construct_action_stmt].has_key?(index)
      cached = node_cache[:executable_construct_action_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_execution_part_disallowed
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_action_stmt
      s0 << r3
      if r3
        i4 = index
        r5 = lambda { |e| nonblock_do_end?(e[1]) }.call(s0)
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(ExecutableConstructActionStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:executable_construct_action_stmt][start_index] = r0

    r0
  end

  module ExecutionPart0
    def executable_construct
      elements[0]
    end

    def execution_part_construct
      elements[1]
    end
  end

  def _nt_execution_part
    start_index = index
    if node_cache[:execution_part].has_key?(index)
      cached = node_cache[:execution_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_executable_construct
    s0 << r1
    if r1
      r2 = _nt_execution_part_construct
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Execution_Part,input, i0...index, s0)
      r0.extend(ExecutionPart0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:execution_part][start_index] = r0

    r0
  end

  def _nt_execution_part_disallowed
    start_index = index
    if node_cache[:execution_part_disallowed].has_key?(index)
      cached = node_cache[:execution_part_disallowed][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_end_function_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_end_program_stmt
      if r2
        r0 = r2
      else
        r3 = _nt_end_subroutine_stmt
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:execution_part_disallowed][start_index] = r0

    r0
  end

  def _nt_execution_part_construct
    start_index = index
    if node_cache[:execution_part_construct].has_key?(index)
      cached = node_cache[:execution_part_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_executable_construct
      if r2
        r1 = r2
      else
        r3 = _nt_format_stmt
        if r3
          r1 = r3
        else
          r4 = _nt_data_stmt
          if r4
            r1 = r4
          else
            r5 = _nt_entry_stmt
            if r5
              r1 = r5
            else
              @index = i1
              r1 = nil
            end
          end
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:execution_part_construct][start_index] = r0

    r0
  end

  module ExitStmt0
    def label
      elements[0]
    end

    def t_exit
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_exit_stmt
    start_index = index
    if node_cache[:exit_stmt].has_key?(index)
      cached = node_cache[:exit_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_exit
      s0 << r3
      if r3
        r5 = _nt_do_construct_name
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(ExitStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:exit_stmt][start_index] = r0

    r0
  end

  module ExplicitShapeSpec0
    def upper_bound
      elements[1]
    end
  end

  def _nt_explicit_shape_spec
    start_index = index
    if node_cache[:explicit_shape_spec].has_key?(index)
      cached = node_cache[:explicit_shape_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_lower_bound_pair
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_upper_bound
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(Explicit_Shape_Spec,input, i0...index, s0)
      r0.extend(ExplicitShapeSpec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:explicit_shape_spec][start_index] = r0

    r0
  end

  module ExplicitShapeSpecList0
    def explicit_shape_spec
      elements[0]
    end

  end

  def _nt_explicit_shape_spec_list
    start_index = index
    if node_cache[:explicit_shape_spec_list].has_key?(index)
      cached = node_cache[:explicit_shape_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_explicit_shape_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_explicit_shape_spec_list_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Explicit_Shape_Spec_List,input, i0...index, s0)
      r0.extend(ExplicitShapeSpecList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:explicit_shape_spec_list][start_index] = r0

    r0
  end

  module ExplicitShapeSpecListPair0
    def t_comma
      elements[0]
    end

    def explicit_shape_spec
      elements[1]
    end
  end

  def _nt_explicit_shape_spec_list_pair
    start_index = index
    if node_cache[:explicit_shape_spec_list_pair].has_key?(index)
      cached = node_cache[:explicit_shape_spec_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_explicit_shape_spec
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Explicit_Shape_Spec_List_Pair,input, i0...index, s0)
      r0.extend(ExplicitShapeSpecListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:explicit_shape_spec_list_pair][start_index] = r0

    r0
  end

  def _nt_exponent
    start_index = index
    if node_cache[:exponent].has_key?(index)
      cached = node_cache[:exponent][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_signed_digit_string

    node_cache[:exponent][start_index] = r0

    r0
  end

  def _nt_exponent_letter
    start_index = index
    if node_cache[:exponent_letter].has_key?(index)
      cached = node_cache[:exponent_letter][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[ed]', true, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:exponent_letter][start_index] = r0

    r0
  end

  module Expr0
    def defined_binary_op
      elements[0]
    end

    def expr
      elements[1]
    end
  end

  module Expr1
    def level_5_expr
      elements[0]
    end

  end

  def _nt_expr
    start_index = index
    if node_cache[:expr].has_key?(index)
      cached = node_cache[:expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_level_5_expr
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_defined_binary_op
      s3 << r4
      if r4
        r5 = _nt_expr
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(Expr0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Expr,input, i0...index, s0)
      r0.extend(Expr1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:expr][start_index] = r0

    r0
  end

  module ExprList0
    def t_comma
      elements[0]
    end

    def expr
      elements[1]
    end
  end

  module ExprList1
    def expr
      elements[0]
    end

  end

  def _nt_expr_list
    start_index = index
    if node_cache[:expr_list].has_key?(index)
      cached = node_cache[:expr_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_expr
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_expr
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(ExprList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Expr_List,input, i0...index, s0)
      r0.extend(ExprList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:expr_list][start_index] = r0

    r0
  end

  def _nt_extended_intrinsic_op
    start_index = index
    if node_cache[:extended_intrinsic_op].has_key?(index)
      cached = node_cache[:extended_intrinsic_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_intrinsic_operator

    node_cache[:extended_intrinsic_op][start_index] = r0

    r0
  end

  def _nt_external_file_unit
    start_index = index
    if node_cache[:external_file_unit].has_key?(index)
      cached = node_cache[:external_file_unit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_expr

    node_cache[:external_file_unit][start_index] = r0

    r0
  end

  def _nt_external_name
    start_index = index
    if node_cache[:external_name].has_key?(index)
      cached = node_cache[:external_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:external_name][start_index] = r0

    r0
  end

  module ExternalNameList0
    def t_comma
      elements[0]
    end

    def external_name
      elements[1]
    end
  end

  module ExternalNameList1
    def external_name
      elements[0]
    end

  end

  def _nt_external_name_list
    start_index = index
    if node_cache[:external_name_list].has_key?(index)
      cached = node_cache[:external_name_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_external_name
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_external_name
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(ExternalNameList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(External_Name_List,input, i0...index, s0)
      r0.extend(ExternalNameList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:external_name_list][start_index] = r0

    r0
  end

  module ExternalStmt0
    def label
      elements[0]
    end

    def t_external
      elements[1]
    end

    def external_name_list
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_external_stmt
    start_index = index
    if node_cache[:external_stmt].has_key?(index)
      cached = node_cache[:external_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_external
      s0 << r3
      if r3
        r4 = _nt_external_name_list
        s0 << r4
        if r4
          r5 = _nt_t_newline
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(ExternalStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:external_stmt][start_index] = r0

    r0
  end

  def _nt_external_subprogram
    start_index = index
    if node_cache[:external_subprogram].has_key?(index)
      cached = node_cache[:external_subprogram][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_subroutine_subprogram
    if r1
      r0 = r1
    else
      r2 = _nt_function_subprogram
      if r2
        r0 = r2
      else
        r3 = _nt_directive
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:external_subprogram][start_index] = r0

    r0
  end

  def _nt_file_name_expr
    start_index = index
    if node_cache[:file_name_expr].has_key?(index)
      cached = node_cache[:file_name_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_default_char_expr

    node_cache[:file_name_expr][start_index] = r0

    r0
  end

  def _nt_format
    start_index = index
    if node_cache[:format].has_key?(index)
      cached = node_cache[:format][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_default_char_expr
    if r1
      r0 = r1
    else
      r2 = _nt_label
      if r2
        r0 = r2
      else
        r3 = _nt_t_star
        if r3
          r0 = r3
        else
          r4 = _nt_scalar_default_int_variable
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:format][start_index] = r0

    r0
  end

  module FormatSpecification0
    def t_paren_l
      elements[0]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_format_specification
    start_index = index
    if node_cache[:format_specification].has_key?(index)
      cached = node_cache[:format_specification][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_format_specification_element
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
      if r2
        r4 = _nt_t_paren_r
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(FormatSpecification0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:format_specification][start_index] = r0

    r0
  end

  module FormatSpecificationElement0
    def character
      elements[1]
    end
  end

  def _nt_format_specification_element
    start_index = index
    if node_cache[:format_specification_element].has_key?(index)
      cached = node_cache[:format_specification_element][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_format_specification
    if r1
      r0 = r1
    else
      r2 = _nt_char_literal_constant
      if r2
        r0 = r2
      else
        s3, i3 = [], index
        loop do
          i4, s4 = index, []
          i5 = index
          i6 = index
          r7 = _nt_t_paren_l
          if r7
            r6 = r7
          else
            r8 = _nt_t_paren_r
            if r8
              r6 = r8
            else
              r9 = _nt_t_apostrophe
              if r9
                r6 = r9
              else
                r10 = _nt_t_quotemark
                if r10
                  r6 = r10
                else
                  @index = i6
                  r6 = nil
                end
              end
            end
          end
          if r6
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s4 << r5
          if r5
            r11 = _nt_character
            s4 << r11
          end
          if s4.last
            r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
            r4.extend(FormatSpecificationElement0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            s3 << r4
          else
            break
          end
        end
        if s3.empty?
          @index = i3
          r3 = nil
        else
          r3 = instantiate_node(T,input, i3...index, s3)
        end
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:format_specification_element][start_index] = r0

    r0
  end

  module FormatStmt0
    def label
      elements[0]
    end

    def t_format
      elements[1]
    end

    def format_specification
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_format_stmt
    start_index = index
    if node_cache[:format_stmt].has_key?(index)
      cached = node_cache[:format_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_label
    s0 << r1
    if r1
      r2 = _nt_t_format
      s0 << r2
      if r2
        r3 = _nt_format_specification
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(FormatStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:format_stmt][start_index] = r0

    r0
  end

  def _nt_function_name
    start_index = index
    if node_cache[:function_name].has_key?(index)
      cached = node_cache[:function_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:function_name][start_index] = r0

    r0
  end

  module FunctionReference0
    def function_name
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def t_paren_r
      elements[3]
    end

  end

  def _nt_function_reference
    start_index = index
    if node_cache[:function_reference].has_key?(index)
      cached = node_cache[:function_reference][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_function_name
    s0 << r1
    if r1
      r2 = _nt_t_paren_l
      s0 << r2
      if r2
        r4 = _nt_actual_arg_spec_list
        if r4
          r3 = r4
        else
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
        if r3
          r5 = _nt_t_paren_r
          s0 << r5
          if r5
            i6 = index
            r7 = lambda { |e| sp_is_array?(e[0]) }.call(s0)
            if r7
              r6 = nil
            else
              @index = i6
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r6
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Function_Reference,input, i0...index, s0)
      r0.extend(FunctionReference0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:function_reference][start_index] = r0

    r0
  end

  module FunctionStmt0
    def label
      elements[0]
    end

    def t_function
      elements[2]
    end

    def function_name
      elements[3]
    end

    def t_paren_l
      elements[4]
    end

    def t_paren_r
      elements[6]
    end

    def t_newline
      elements[8]
    end

  end

  def _nt_function_stmt
    start_index = index
    if node_cache[:function_stmt].has_key?(index)
      cached = node_cache[:function_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r4 = _nt_prefix_function
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r5 = _nt_t_function
        s0 << r5
        if r5
          r6 = _nt_function_name
          s0 << r6
          if r6
            r7 = _nt_t_paren_l
            s0 << r7
            if r7
              r9 = _nt_dummy_arg_name_list
              if r9
                r8 = r9
              else
                r8 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r8
              if r8
                r10 = _nt_t_paren_r
                s0 << r10
                if r10
                  r12 = _nt_result_option
                  if r12
                    r11 = r12
                  else
                    r11 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s0 << r11
                  if r11
                    r13 = _nt_t_newline
                    s0 << r13
                    if r13
                      i14 = index
                      r15 = lambda { |e| sp_function_stmt(e[5]) }.call(s0)
                      if r15
                        @index = i14
                        r14 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        r14 = nil
                      end
                      s0 << r14
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Function_Stmt,input, i0...index, s0)
      r0.extend(FunctionStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:function_stmt][start_index] = r0

    r0
  end

  module FunctionSubprogram0
    def function_stmt
      elements[0]
    end

    def end_function_stmt
      elements[4]
    end
  end

  def _nt_function_subprogram
    start_index = index
    if node_cache[:function_subprogram].has_key?(index)
      cached = node_cache[:function_subprogram][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_function_stmt
    s0 << r1
    if r1
      r3 = _nt_specification_part
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r5 = _nt_execution_part
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r7 = _nt_internal_subprogram_part
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r6
          if r6
            r8 = _nt_end_function_stmt
            s0 << r8
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Function_Subprogram,input, i0...index, s0)
      r0.extend(FunctionSubprogram0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:function_subprogram][start_index] = r0

    r0
  end

  def _nt_generic_name
    start_index = index
    if node_cache[:generic_name].has_key?(index)
      cached = node_cache[:generic_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:generic_name][start_index] = r0

    r0
  end

  module GenericSpec0
    def t_operator
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def defined_operator
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  module GenericSpec1
    def t_assignment
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def t_equal
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_generic_spec
    start_index = index
    if node_cache[:generic_spec].has_key?(index)
      cached = node_cache[:generic_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_generic_name
    if r1
      r0 = r1
    else
      i2, s2 = index, []
      r3 = _nt_t_operator
      s2 << r3
      if r3
        r4 = _nt_t_paren_l
        s2 << r4
        if r4
          r5 = _nt_defined_operator
          s2 << r5
          if r5
            r6 = _nt_t_paren_r
            s2 << r6
          end
        end
      end
      if s2.last
        r2 = instantiate_node(Generic_Spec,input, i2...index, s2)
        r2.extend(GenericSpec0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r0 = r2
      else
        i7, s7 = index, []
        r8 = _nt_t_assignment
        s7 << r8
        if r8
          r9 = _nt_t_paren_l
          s7 << r9
          if r9
            r10 = _nt_t_equal
            s7 << r10
            if r10
              r11 = _nt_t_paren_r
              s7 << r11
            end
          end
        end
        if s7.last
          r7 = instantiate_node(Generic_Spec,input, i7...index, s7)
          r7.extend(GenericSpec1)
        else
          @index = i7
          r7 = nil
        end
        if r7
          r0 = r7
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:generic_spec][start_index] = r0

    r0
  end

  module GotoStmt0
    def label1
      elements[0]
    end

    def t_goto
      elements[1]
    end

    def label2
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_goto_stmt
    start_index = index
    if node_cache[:goto_stmt].has_key?(index)
      cached = node_cache[:goto_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_goto
      s0 << r3
      if r3
        r4 = _nt_label
        s0 << r4
        if r4
          r5 = _nt_t_newline
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(GotoStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:goto_stmt][start_index] = r0

    r0
  end

  module HexConstant0
    def t_apostrophe1
      elements[0]
    end

    def t_apostrophe2
      elements[2]
    end
  end

  module HexConstant1
    def t_quotemark1
      elements[0]
    end

    def t_quotemark2
      elements[2]
    end
  end

  module HexConstant2
  end

  def _nt_hex_constant
    start_index = index
    if node_cache[:hex_constant].has_key?(index)
      cached = node_cache[:hex_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("z", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("z")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      i3, s3 = index, []
      r4 = _nt_t_apostrophe
      s3 << r4
      if r4
        s5, i5 = [], index
        loop do
          r6 = _nt_hex_digit
          if r6
            s5 << r6
          else
            break
          end
        end
        if s5.empty?
          @index = i5
          r5 = nil
        else
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        end
        s3 << r5
        if r5
          r7 = _nt_t_apostrophe
          s3 << r7
        end
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(HexConstant0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        i8, s8 = index, []
        r9 = _nt_t_quotemark
        s8 << r9
        if r9
          s10, i10 = [], index
          loop do
            r11 = _nt_hex_digit
            if r11
              s10 << r11
            else
              break
            end
          end
          if s10.empty?
            @index = i10
            r10 = nil
          else
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
          end
          s8 << r10
          if r10
            r12 = _nt_t_quotemark
            s8 << r12
          end
        end
        if s8.last
          r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
          r8.extend(HexConstant1)
        else
          @index = i8
          r8 = nil
        end
        if r8
          r2 = r8
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(HexConstant2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:hex_constant][start_index] = r0

    r0
  end

  def _nt_hex_digit
    start_index = index
    if node_cache[:hex_digit].has_key?(index)
      cached = node_cache[:hex_digit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[0123456789abcdef]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:hex_digit][start_index] = r0

    r0
  end

  module IfConstruct0
    def label
      elements[0]
    end

    def if_then_construct
      elements[1]
    end

    def end_if_stmt
      elements[4]
    end
  end

  def _nt_if_construct
    start_index = index
    if node_cache[:if_construct].has_key?(index)
      cached = node_cache[:if_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_if_then_construct
      s0 << r3
      if r3
        r5 = _nt_else_if_construct
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r7 = _nt_else_construct
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r6
          if r6
            r8 = _nt_end_if_stmt
            s0 << r8
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(IfConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:if_construct][start_index] = r0

    r0
  end

  def _nt_if_construct_name
    start_index = index
    if node_cache[:if_construct_name].has_key?(index)
      cached = node_cache[:if_construct_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:if_construct_name][start_index] = r0

    r0
  end

  module IfConstructNameLabel0
    def if_construct_name
      elements[0]
    end

    def t_colon
      elements[1]
    end
  end

  def _nt_if_construct_name_label
    start_index = index
    if node_cache[:if_construct_name_label].has_key?(index)
      cached = node_cache[:if_construct_name_label][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_if_construct_name
    s0 << r1
    if r1
      r2 = _nt_t_colon
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(IfConstructNameLabel0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:if_construct_name_label][start_index] = r0

    r0
  end

  module IfStmt0
    def label
      elements[0]
    end

    def t_if
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def scalar_logical_expr
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def action_stmt
      elements[5]
    end
  end

  def _nt_if_stmt
    start_index = index
    if node_cache[:if_stmt].has_key?(index)
      cached = node_cache[:if_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_if
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_scalar_logical_expr
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r7 = _nt_action_stmt
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(If_Stmt,input, i0...index, s0)
      r0.extend(IfStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:if_stmt][start_index] = r0

    r0
  end

  module IfThenConstruct0
    def if_then_stmt
      elements[0]
    end

    def block
      elements[1]
    end
  end

  def _nt_if_then_construct
    start_index = index
    if node_cache[:if_then_construct].has_key?(index)
      cached = node_cache[:if_then_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_if_then_stmt
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(IfThenConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:if_then_construct][start_index] = r0

    r0
  end

  module IfThenStmt0
    def label
      elements[0]
    end

    def t_if
      elements[2]
    end

    def t_paren_l
      elements[3]
    end

    def scalar_logical_expr
      elements[4]
    end

    def t_paren_r
      elements[5]
    end

    def t_then
      elements[6]
    end

    def t_newline
      elements[7]
    end
  end

  def _nt_if_then_stmt
    start_index = index
    if node_cache[:if_then_stmt].has_key?(index)
      cached = node_cache[:if_then_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r4 = _nt_if_construct_name_label
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r5 = _nt_t_if
        s0 << r5
        if r5
          r6 = _nt_t_paren_l
          s0 << r6
          if r6
            r7 = _nt_scalar_logical_expr
            s0 << r7
            if r7
              r8 = _nt_t_paren_r
              s0 << r8
              if r8
                r9 = _nt_t_then
                s0 << r9
                if r9
                  r10 = _nt_t_newline
                  s0 << r10
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(If_Then_Stmt,input, i0...index, s0)
      r0.extend(IfThenStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:if_then_stmt][start_index] = r0

    r0
  end

  def _nt_imag_part
    start_index = index
    if node_cache[:imag_part].has_key?(index)
      cached = node_cache[:imag_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_signed_real_literal_constant
    if r1
      r0 = r1
    else
      r2 = _nt_signed_int_literal_constant
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:imag_part][start_index] = r0

    r0
  end

  def _nt_implicit_part
    start_index = index
    if node_cache[:implicit_part].has_key?(index)
      cached = node_cache[:implicit_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    s1, i1 = [], index
    loop do
      r2 = _nt_implicit_part_stmt
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(E,input, i1...index, s1)
    end
    if r1
      r0 = r1
    else
      r3 = _nt_directive
      if r3
        r0 = r3
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:implicit_part][start_index] = r0

    r0
  end

  def _nt_implicit_part_stmt
    start_index = index
    if node_cache[:implicit_part_stmt].has_key?(index)
      cached = node_cache[:implicit_part_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_implicit_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_format_stmt
      if r2
        r0 = r2
      else
        r3 = _nt_parameter_stmt
        if r3
          r0 = r3
        else
          r4 = _nt_entry_stmt
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:implicit_part_stmt][start_index] = r0

    r0
  end

  module ImplicitSpec0
    def type_spec_with_kind_selector
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def letter_spec_list
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  module ImplicitSpec1
    def type_spec_without_kind_selector
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def letter_spec_list
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_implicit_spec
    start_index = index
    if node_cache[:implicit_spec].has_key?(index)
      cached = node_cache[:implicit_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_type_spec_with_kind_selector
    s1 << r2
    if r2
      r3 = _nt_t_paren_l
      s1 << r3
      if r3
        r4 = _nt_letter_spec_list
        s1 << r4
        if r4
          r5 = _nt_t_paren_r
          s1 << r5
        end
      end
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(ImplicitSpec0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i6, s6 = index, []
      r7 = _nt_type_spec_without_kind_selector
      s6 << r7
      if r7
        r8 = _nt_t_paren_l
        s6 << r8
        if r8
          r9 = _nt_letter_spec_list
          s6 << r9
          if r9
            r10 = _nt_t_paren_r
            s6 << r10
          end
        end
      end
      if s6.last
        r6 = instantiate_node(T,input, i6...index, s6)
        r6.extend(ImplicitSpec1)
      else
        @index = i6
        r6 = nil
      end
      if r6
        r0 = r6
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:implicit_spec][start_index] = r0

    r0
  end

  module ImplicitSpecList0
    def t_comma
      elements[0]
    end

    def implicit_spec
      elements[1]
    end
  end

  module ImplicitSpecList1
    def implicit_spec
      elements[0]
    end

  end

  def _nt_implicit_spec_list
    start_index = index
    if node_cache[:implicit_spec_list].has_key?(index)
      cached = node_cache[:implicit_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_implicit_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_implicit_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(ImplicitSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Implicit_Spec_List,input, i0...index, s0)
      r0.extend(ImplicitSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:implicit_spec_list][start_index] = r0

    r0
  end

  module ImplicitStmt0
    def label
      elements[0]
    end

    def t_implicit
      elements[1]
    end

    def t_none
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  module ImplicitStmt1
    def label
      elements[0]
    end

    def t_implicit
      elements[1]
    end

    def implicit_spec_list
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_implicit_stmt
    start_index = index
    if node_cache[:implicit_stmt].has_key?(index)
      cached = node_cache[:implicit_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_label
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r4 = _nt_t_implicit
      s1 << r4
      if r4
        r5 = _nt_t_none
        s1 << r5
        if r5
          r6 = _nt_t_newline
          s1 << r6
        end
      end
    end
    if s1.last
      r1 = instantiate_node(Implicit_None_Stmt,input, i1...index, s1)
      r1.extend(ImplicitStmt0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i7, s7 = index, []
      r9 = _nt_label
      if r9
        r8 = r9
      else
        r8 = instantiate_node(SyntaxNode,input, index...index)
      end
      s7 << r8
      if r8
        r10 = _nt_t_implicit
        s7 << r10
        if r10
          r11 = _nt_implicit_spec_list
          s7 << r11
          if r11
            r12 = _nt_t_newline
            s7 << r12
          end
        end
      end
      if s7.last
        r7 = instantiate_node(Implicit_Stmt,input, i7...index, s7)
        r7.extend(ImplicitStmt1)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r0 = r7
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:implicit_stmt][start_index] = r0

    r0
  end

  module Initialization0
    def t_equal
      elements[0]
    end

    def initialization_expr
      elements[1]
    end
  end

  module Initialization1
    def t_point
      elements[0]
    end

    def null_function_ref
      elements[1]
    end
  end

  def _nt_initialization
    start_index = index
    if node_cache[:initialization].has_key?(index)
      cached = node_cache[:initialization][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_equal
    s1 << r2
    if r2
      r3 = _nt_initialization_expr
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(Initialization_1,input, i1...index, s1)
      r1.extend(Initialization0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i4, s4 = index, []
      r5 = _nt_t_point
      s4 << r5
      if r5
        r6 = _nt_null_function_ref
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(Initialization_2,input, i4...index, s4)
        r4.extend(Initialization1)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r0 = r4
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:initialization][start_index] = r0

    r0
  end

  def _nt_initialization_expr
    start_index = index
    if node_cache[:initialization_expr].has_key?(index)
      cached = node_cache[:initialization_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_expr

    node_cache[:initialization_expr][start_index] = r0

    r0
  end

  module InnerSharedDoConstruct0
    def label_do_stmt
      elements[0]
    end

    def do_body
      elements[1]
    end

    def do_term_shared_stmt
      elements[2]
    end
  end

  def _nt_inner_shared_do_construct
    start_index = index
    if node_cache[:inner_shared_do_construct].has_key?(index)
      cached = node_cache[:inner_shared_do_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_label_do_stmt
    s0 << r1
    if r1
      r2 = _nt_do_body
      s0 << r2
      if r2
        r3 = _nt_do_term_shared_stmt
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(Inner_Shared_Do_Construct,input, i0...index, s0)
      r0.extend(InnerSharedDoConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:inner_shared_do_construct][start_index] = r0

    r0
  end

  def _nt_input_item
    start_index = index
    if node_cache[:input_item].has_key?(index)
      cached = node_cache[:input_item][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_io_implied_do
    if r1
      r0 = r1
    else
      r2 = _nt_variable
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:input_item][start_index] = r0

    r0
  end

  module InputItemList0
    def t_comma
      elements[0]
    end

    def input_item
      elements[1]
    end
  end

  module InputItemList1
    def input_item
      elements[0]
    end

  end

  def _nt_input_item_list
    start_index = index
    if node_cache[:input_item_list].has_key?(index)
      cached = node_cache[:input_item_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_input_item
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_input_item
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(InputItemList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Input_Item_List,input, i0...index, s0)
      r0.extend(InputItemList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:input_item_list][start_index] = r0

    r0
  end

  module InquireSpec0
    def external_file_unit
      elements[0]
    end

  end

  module InquireSpec1
    def t_unit
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def external_file_unit
      elements[2]
    end
  end

  module InquireSpec2
    def t_file
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def file_name_expr
      elements[2]
    end
  end

  module InquireSpec3
    def t_iostat
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_int_variable
      elements[2]
    end
  end

  module InquireSpec4
    def t_err
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def label
      elements[2]
    end
  end

  module InquireSpec5
    def t_exist
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_logical_variable
      elements[2]
    end
  end

  module InquireSpec6
    def t_opened
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_logical_variable
      elements[2]
    end
  end

  module InquireSpec7
    def t_number
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_int_variable
      elements[2]
    end
  end

  module InquireSpec8
    def t_named
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_logical_variable
      elements[2]
    end
  end

  module InquireSpec9
    def t_name
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec10
    def t_access
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec11
    def t_sequential
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec12
    def t_direct
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec13
    def t_form
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec14
    def t_formatted
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec15
    def t_unformatted
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec16
    def t_recl
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_int_variable
      elements[2]
    end
  end

  module InquireSpec17
    def t_nextrec
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_int_variable
      elements[2]
    end
  end

  module InquireSpec18
    def t_blank
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec19
    def t_position
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec20
    def t_action
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec21
    def t_read
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec22
    def t_write
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec23
    def t_readwrite
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec24
    def t_delim
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  module InquireSpec25
    def t_pad
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_variable
      elements[2]
    end
  end

  def _nt_inquire_spec
    start_index = index
    if node_cache[:inquire_spec].has_key?(index)
      cached = node_cache[:inquire_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_external_file_unit
    s1 << r2
    if r2
      i3 = index
      r4 = _nt_t_comma
      if r4
        @index = i3
        r3 = instantiate_node(SyntaxNode,input, index...index)
      else
        r3 = nil
      end
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(InquireSpec0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_t_unit
      s5 << r6
      if r6
        r7 = _nt_t_equal
        s5 << r7
        if r7
          r8 = _nt_external_file_unit
          s5 << r8
        end
      end
      if s5.last
        r5 = instantiate_node(T,input, i5...index, s5)
        r5.extend(InquireSpec1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        i9, s9 = index, []
        r10 = _nt_t_file
        s9 << r10
        if r10
          r11 = _nt_t_equal
          s9 << r11
          if r11
            r12 = _nt_file_name_expr
            s9 << r12
          end
        end
        if s9.last
          r9 = instantiate_node(T,input, i9...index, s9)
          r9.extend(InquireSpec2)
        else
          @index = i9
          r9 = nil
        end
        if r9
          r0 = r9
        else
          i13, s13 = index, []
          r14 = _nt_t_iostat
          s13 << r14
          if r14
            r15 = _nt_t_equal
            s13 << r15
            if r15
              r16 = _nt_scalar_default_int_variable
              s13 << r16
            end
          end
          if s13.last
            r13 = instantiate_node(T,input, i13...index, s13)
            r13.extend(InquireSpec3)
          else
            @index = i13
            r13 = nil
          end
          if r13
            r0 = r13
          else
            i17, s17 = index, []
            r18 = _nt_t_err
            s17 << r18
            if r18
              r19 = _nt_t_equal
              s17 << r19
              if r19
                r20 = _nt_label
                s17 << r20
              end
            end
            if s17.last
              r17 = instantiate_node(T,input, i17...index, s17)
              r17.extend(InquireSpec4)
            else
              @index = i17
              r17 = nil
            end
            if r17
              r0 = r17
            else
              i21, s21 = index, []
              r22 = _nt_t_exist
              s21 << r22
              if r22
                r23 = _nt_t_equal
                s21 << r23
                if r23
                  r24 = _nt_scalar_default_logical_variable
                  s21 << r24
                end
              end
              if s21.last
                r21 = instantiate_node(T,input, i21...index, s21)
                r21.extend(InquireSpec5)
              else
                @index = i21
                r21 = nil
              end
              if r21
                r0 = r21
              else
                i25, s25 = index, []
                r26 = _nt_t_opened
                s25 << r26
                if r26
                  r27 = _nt_t_equal
                  s25 << r27
                  if r27
                    r28 = _nt_scalar_default_logical_variable
                    s25 << r28
                  end
                end
                if s25.last
                  r25 = instantiate_node(T,input, i25...index, s25)
                  r25.extend(InquireSpec6)
                else
                  @index = i25
                  r25 = nil
                end
                if r25
                  r0 = r25
                else
                  i29, s29 = index, []
                  r30 = _nt_t_number
                  s29 << r30
                  if r30
                    r31 = _nt_t_equal
                    s29 << r31
                    if r31
                      r32 = _nt_scalar_default_int_variable
                      s29 << r32
                    end
                  end
                  if s29.last
                    r29 = instantiate_node(T,input, i29...index, s29)
                    r29.extend(InquireSpec7)
                  else
                    @index = i29
                    r29 = nil
                  end
                  if r29
                    r0 = r29
                  else
                    i33, s33 = index, []
                    r34 = _nt_t_named
                    s33 << r34
                    if r34
                      r35 = _nt_t_equal
                      s33 << r35
                      if r35
                        r36 = _nt_scalar_default_logical_variable
                        s33 << r36
                      end
                    end
                    if s33.last
                      r33 = instantiate_node(T,input, i33...index, s33)
                      r33.extend(InquireSpec8)
                    else
                      @index = i33
                      r33 = nil
                    end
                    if r33
                      r0 = r33
                    else
                      i37, s37 = index, []
                      r38 = _nt_t_name
                      s37 << r38
                      if r38
                        r39 = _nt_t_equal
                        s37 << r39
                        if r39
                          r40 = _nt_scalar_default_char_variable
                          s37 << r40
                        end
                      end
                      if s37.last
                        r37 = instantiate_node(T,input, i37...index, s37)
                        r37.extend(InquireSpec9)
                      else
                        @index = i37
                        r37 = nil
                      end
                      if r37
                        r0 = r37
                      else
                        i41, s41 = index, []
                        r42 = _nt_t_access
                        s41 << r42
                        if r42
                          r43 = _nt_t_equal
                          s41 << r43
                          if r43
                            r44 = _nt_scalar_default_char_variable
                            s41 << r44
                          end
                        end
                        if s41.last
                          r41 = instantiate_node(T,input, i41...index, s41)
                          r41.extend(InquireSpec10)
                        else
                          @index = i41
                          r41 = nil
                        end
                        if r41
                          r0 = r41
                        else
                          i45, s45 = index, []
                          r46 = _nt_t_sequential
                          s45 << r46
                          if r46
                            r47 = _nt_t_equal
                            s45 << r47
                            if r47
                              r48 = _nt_scalar_default_char_variable
                              s45 << r48
                            end
                          end
                          if s45.last
                            r45 = instantiate_node(T,input, i45...index, s45)
                            r45.extend(InquireSpec11)
                          else
                            @index = i45
                            r45 = nil
                          end
                          if r45
                            r0 = r45
                          else
                            i49, s49 = index, []
                            r50 = _nt_t_direct
                            s49 << r50
                            if r50
                              r51 = _nt_t_equal
                              s49 << r51
                              if r51
                                r52 = _nt_scalar_default_char_variable
                                s49 << r52
                              end
                            end
                            if s49.last
                              r49 = instantiate_node(T,input, i49...index, s49)
                              r49.extend(InquireSpec12)
                            else
                              @index = i49
                              r49 = nil
                            end
                            if r49
                              r0 = r49
                            else
                              i53, s53 = index, []
                              r54 = _nt_t_form
                              s53 << r54
                              if r54
                                r55 = _nt_t_equal
                                s53 << r55
                                if r55
                                  r56 = _nt_scalar_default_char_variable
                                  s53 << r56
                                end
                              end
                              if s53.last
                                r53 = instantiate_node(T,input, i53...index, s53)
                                r53.extend(InquireSpec13)
                              else
                                @index = i53
                                r53 = nil
                              end
                              if r53
                                r0 = r53
                              else
                                i57, s57 = index, []
                                r58 = _nt_t_formatted
                                s57 << r58
                                if r58
                                  r59 = _nt_t_equal
                                  s57 << r59
                                  if r59
                                    r60 = _nt_scalar_default_char_variable
                                    s57 << r60
                                  end
                                end
                                if s57.last
                                  r57 = instantiate_node(T,input, i57...index, s57)
                                  r57.extend(InquireSpec14)
                                else
                                  @index = i57
                                  r57 = nil
                                end
                                if r57
                                  r0 = r57
                                else
                                  i61, s61 = index, []
                                  r62 = _nt_t_unformatted
                                  s61 << r62
                                  if r62
                                    r63 = _nt_t_equal
                                    s61 << r63
                                    if r63
                                      r64 = _nt_scalar_default_char_variable
                                      s61 << r64
                                    end
                                  end
                                  if s61.last
                                    r61 = instantiate_node(T,input, i61...index, s61)
                                    r61.extend(InquireSpec15)
                                  else
                                    @index = i61
                                    r61 = nil
                                  end
                                  if r61
                                    r0 = r61
                                  else
                                    i65, s65 = index, []
                                    r66 = _nt_t_recl
                                    s65 << r66
                                    if r66
                                      r67 = _nt_t_equal
                                      s65 << r67
                                      if r67
                                        r68 = _nt_scalar_default_int_variable
                                        s65 << r68
                                      end
                                    end
                                    if s65.last
                                      r65 = instantiate_node(T,input, i65...index, s65)
                                      r65.extend(InquireSpec16)
                                    else
                                      @index = i65
                                      r65 = nil
                                    end
                                    if r65
                                      r0 = r65
                                    else
                                      i69, s69 = index, []
                                      r70 = _nt_t_nextrec
                                      s69 << r70
                                      if r70
                                        r71 = _nt_t_equal
                                        s69 << r71
                                        if r71
                                          r72 = _nt_scalar_default_int_variable
                                          s69 << r72
                                        end
                                      end
                                      if s69.last
                                        r69 = instantiate_node(T,input, i69...index, s69)
                                        r69.extend(InquireSpec17)
                                      else
                                        @index = i69
                                        r69 = nil
                                      end
                                      if r69
                                        r0 = r69
                                      else
                                        i73, s73 = index, []
                                        r74 = _nt_t_blank
                                        s73 << r74
                                        if r74
                                          r75 = _nt_t_equal
                                          s73 << r75
                                          if r75
                                            r76 = _nt_scalar_default_char_variable
                                            s73 << r76
                                          end
                                        end
                                        if s73.last
                                          r73 = instantiate_node(T,input, i73...index, s73)
                                          r73.extend(InquireSpec18)
                                        else
                                          @index = i73
                                          r73 = nil
                                        end
                                        if r73
                                          r0 = r73
                                        else
                                          i77, s77 = index, []
                                          r78 = _nt_t_position
                                          s77 << r78
                                          if r78
                                            r79 = _nt_t_equal
                                            s77 << r79
                                            if r79
                                              r80 = _nt_scalar_default_char_variable
                                              s77 << r80
                                            end
                                          end
                                          if s77.last
                                            r77 = instantiate_node(T,input, i77...index, s77)
                                            r77.extend(InquireSpec19)
                                          else
                                            @index = i77
                                            r77 = nil
                                          end
                                          if r77
                                            r0 = r77
                                          else
                                            i81, s81 = index, []
                                            r82 = _nt_t_action
                                            s81 << r82
                                            if r82
                                              r83 = _nt_t_equal
                                              s81 << r83
                                              if r83
                                                r84 = _nt_scalar_default_char_variable
                                                s81 << r84
                                              end
                                            end
                                            if s81.last
                                              r81 = instantiate_node(T,input, i81...index, s81)
                                              r81.extend(InquireSpec20)
                                            else
                                              @index = i81
                                              r81 = nil
                                            end
                                            if r81
                                              r0 = r81
                                            else
                                              i85, s85 = index, []
                                              r86 = _nt_t_read
                                              s85 << r86
                                              if r86
                                                r87 = _nt_t_equal
                                                s85 << r87
                                                if r87
                                                  r88 = _nt_scalar_default_char_variable
                                                  s85 << r88
                                                end
                                              end
                                              if s85.last
                                                r85 = instantiate_node(T,input, i85...index, s85)
                                                r85.extend(InquireSpec21)
                                              else
                                                @index = i85
                                                r85 = nil
                                              end
                                              if r85
                                                r0 = r85
                                              else
                                                i89, s89 = index, []
                                                r90 = _nt_t_write
                                                s89 << r90
                                                if r90
                                                  r91 = _nt_t_equal
                                                  s89 << r91
                                                  if r91
                                                    r92 = _nt_scalar_default_char_variable
                                                    s89 << r92
                                                  end
                                                end
                                                if s89.last
                                                  r89 = instantiate_node(T,input, i89...index, s89)
                                                  r89.extend(InquireSpec22)
                                                else
                                                  @index = i89
                                                  r89 = nil
                                                end
                                                if r89
                                                  r0 = r89
                                                else
                                                  i93, s93 = index, []
                                                  r94 = _nt_t_readwrite
                                                  s93 << r94
                                                  if r94
                                                    r95 = _nt_t_equal
                                                    s93 << r95
                                                    if r95
                                                      r96 = _nt_scalar_default_char_variable
                                                      s93 << r96
                                                    end
                                                  end
                                                  if s93.last
                                                    r93 = instantiate_node(T,input, i93...index, s93)
                                                    r93.extend(InquireSpec23)
                                                  else
                                                    @index = i93
                                                    r93 = nil
                                                  end
                                                  if r93
                                                    r0 = r93
                                                  else
                                                    i97, s97 = index, []
                                                    r98 = _nt_t_delim
                                                    s97 << r98
                                                    if r98
                                                      r99 = _nt_t_equal
                                                      s97 << r99
                                                      if r99
                                                        r100 = _nt_scalar_default_char_variable
                                                        s97 << r100
                                                      end
                                                    end
                                                    if s97.last
                                                      r97 = instantiate_node(T,input, i97...index, s97)
                                                      r97.extend(InquireSpec24)
                                                    else
                                                      @index = i97
                                                      r97 = nil
                                                    end
                                                    if r97
                                                      r0 = r97
                                                    else
                                                      i101, s101 = index, []
                                                      r102 = _nt_t_pad
                                                      s101 << r102
                                                      if r102
                                                        r103 = _nt_t_equal
                                                        s101 << r103
                                                        if r103
                                                          r104 = _nt_scalar_default_char_variable
                                                          s101 << r104
                                                        end
                                                      end
                                                      if s101.last
                                                        r101 = instantiate_node(T,input, i101...index, s101)
                                                        r101.extend(InquireSpec25)
                                                      else
                                                        @index = i101
                                                        r101 = nil
                                                      end
                                                      if r101
                                                        r0 = r101
                                                      else
                                                        @index = i0
                                                        r0 = nil
                                                      end
                                                    end
                                                  end
                                                end
                                              end
                                            end
                                          end
                                        end
                                      end
                                    end
                                  end
                                end
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:inquire_spec][start_index] = r0

    r0
  end

  module InquireSpecList0
    def t_comma
      elements[0]
    end

    def inquire_spec
      elements[1]
    end
  end

  module InquireSpecList1
    def inquire_spec
      elements[0]
    end

  end

  def _nt_inquire_spec_list
    start_index = index
    if node_cache[:inquire_spec_list].has_key?(index)
      cached = node_cache[:inquire_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_inquire_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_inquire_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(InquireSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Inquire_Spec_List,input, i0...index, s0)
      r0.extend(InquireSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:inquire_spec_list][start_index] = r0

    r0
  end

  module InquireStmt0
    def label
      elements[0]
    end

    def t_inquire
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def inquire_spec_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  module InquireStmt1
    def label
      elements[0]
    end

    def t_inquire
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def t_iolength
      elements[3]
    end

    def t_equal
      elements[4]
    end

    def scalar_default_int_variable
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def output_item_list
      elements[7]
    end

    def t_newline
      elements[8]
    end
  end

  def _nt_inquire_stmt
    start_index = index
    if node_cache[:inquire_stmt].has_key?(index)
      cached = node_cache[:inquire_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_label
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r4 = _nt_t_inquire
      s1 << r4
      if r4
        r5 = _nt_t_paren_l
        s1 << r5
        if r5
          r6 = _nt_inquire_spec_list
          s1 << r6
          if r6
            r7 = _nt_t_paren_r
            s1 << r7
            if r7
              r8 = _nt_t_newline
              s1 << r8
            end
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(StmtC,input, i1...index, s1)
      r1.extend(InquireStmt0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i9, s9 = index, []
      r11 = _nt_label
      if r11
        r10 = r11
      else
        r10 = instantiate_node(SyntaxNode,input, index...index)
      end
      s9 << r10
      if r10
        r12 = _nt_t_inquire
        s9 << r12
        if r12
          r13 = _nt_t_paren_l
          s9 << r13
          if r13
            r14 = _nt_t_iolength
            s9 << r14
            if r14
              r15 = _nt_t_equal
              s9 << r15
              if r15
                r16 = _nt_scalar_default_int_variable
                s9 << r16
                if r16
                  r17 = _nt_t_paren_r
                  s9 << r17
                  if r17
                    r18 = _nt_output_item_list
                    s9 << r18
                    if r18
                      r19 = _nt_t_newline
                      s9 << r19
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s9.last
        r9 = instantiate_node(StmtC,input, i9...index, s9)
        r9.extend(InquireStmt1)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r0 = r9
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:inquire_stmt][start_index] = r0

    r0
  end

  def _nt_int_expr
    start_index = index
    if node_cache[:int_expr].has_key?(index)
      cached = node_cache[:int_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_expr

    node_cache[:int_expr][start_index] = r0

    r0
  end

  def _nt_int_initialization_expr
    start_index = index
    if node_cache[:int_initialization_expr].has_key?(index)
      cached = node_cache[:int_initialization_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_int_expr

    node_cache[:int_initialization_expr][start_index] = r0

    r0
  end

  module IntLiteralConstant0
    def t_underscore
      elements[0]
    end

    def kind_param
      elements[1]
    end
  end

  module IntLiteralConstant1
    def digit_string
      elements[0]
    end

  end

  def _nt_int_literal_constant
    start_index = index
    if node_cache[:int_literal_constant].has_key?(index)
      cached = node_cache[:int_literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_digit_string
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_t_underscore
      s3 << r4
      if r4
        r5 = _nt_kind_param
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(IntLiteralConstant0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(IntLiteralConstant1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:int_literal_constant][start_index] = r0

    r0
  end

  def _nt_int_variable
    start_index = index
    if node_cache[:int_variable].has_key?(index)
      cached = node_cache[:int_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable

    node_cache[:int_variable][start_index] = r0

    r0
  end

  def _nt_intent_spec
    start_index = index
    if node_cache[:intent_spec].has_key?(index)
      cached = node_cache[:intent_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_in
    if r1
      r0 = r1
    else
      r2 = _nt_t_out
      if r2
        r0 = r2
      else
        r3 = _nt_t_inout
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:intent_spec][start_index] = r0

    r0
  end

  module IntentStmt0
    def label
      elements[0]
    end

    def t_intent
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def intent_spec
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def dummy_arg_name_list
      elements[6]
    end

    def t_newline
      elements[7]
    end
  end

  def _nt_intent_stmt
    start_index = index
    if node_cache[:intent_stmt].has_key?(index)
      cached = node_cache[:intent_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_intent
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_intent_spec
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r8 = _nt_double_colon
              if r8
                r7 = r8
              else
                r7 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r7
              if r7
                r9 = _nt_dummy_arg_name_list
                s0 << r9
                if r9
                  r10 = _nt_t_newline
                  s0 << r10
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Intent_Stmt,input, i0...index, s0)
      r0.extend(IntentStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:intent_stmt][start_index] = r0

    r0
  end

  module InterfaceBlock0
    def interface_stmt
      elements[0]
    end

    def interface_bodies
      elements[1]
    end

    def module_procedure_stmts
      elements[2]
    end

    def end_interface_stmt
      elements[3]
    end
  end

  def _nt_interface_block
    start_index = index
    if node_cache[:interface_block].has_key?(index)
      cached = node_cache[:interface_block][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_interface_stmt
    s0 << r1
    if r1
      r2 = _nt_interface_bodies
      s0 << r2
      if r2
        r3 = _nt_module_procedure_stmts
        s0 << r3
        if r3
          r4 = _nt_end_interface_stmt
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(InterfaceBlock0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:interface_block][start_index] = r0

    r0
  end

  def _nt_interface_bodies
    start_index = index
    if node_cache[:interface_bodies].has_key?(index)
      cached = node_cache[:interface_bodies][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_interface_body
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:interface_bodies][start_index] = r0

    r0
  end

  module InterfaceBody0
    def subroutine_stmt
      elements[0]
    end

    def end_subroutine_stmt
      elements[2]
    end
  end

  module InterfaceBody1
    def function_stmt
      elements[0]
    end

    def end_function_stmt
      elements[2]
    end
  end

  def _nt_interface_body
    start_index = index
    if node_cache[:interface_body].has_key?(index)
      cached = node_cache[:interface_body][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_subroutine_stmt
    s1 << r2
    if r2
      r4 = _nt_specification_part
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r3
      if r3
        r5 = _nt_end_subroutine_stmt
        s1 << r5
      end
    end
    if s1.last
      r1 = instantiate_node(Interface_Body_1,input, i1...index, s1)
      r1.extend(InterfaceBody0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i6, s6 = index, []
      r7 = _nt_function_stmt
      s6 << r7
      if r7
        r9 = _nt_specification_part
        if r9
          r8 = r9
        else
          r8 = instantiate_node(SyntaxNode,input, index...index)
        end
        s6 << r8
        if r8
          r10 = _nt_end_function_stmt
          s6 << r10
        end
      end
      if s6.last
        r6 = instantiate_node(Interface_Body_2,input, i6...index, s6)
        r6.extend(InterfaceBody1)
      else
        @index = i6
        r6 = nil
      end
      if r6
        r0 = r6
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:interface_body][start_index] = r0

    r0
  end

  module InterfaceStmt0
    def label
      elements[0]
    end

    def t_interface
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_interface_stmt
    start_index = index
    if node_cache[:interface_stmt].has_key?(index)
      cached = node_cache[:interface_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_interface
      s0 << r3
      if r3
        r5 = _nt_generic_spec
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Interface_Stmt,input, i0...index, s0)
      r0.extend(InterfaceStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:interface_stmt][start_index] = r0

    r0
  end

  def _nt_internal_file_unit
    start_index = index
    if node_cache[:internal_file_unit].has_key?(index)
      cached = node_cache[:internal_file_unit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_default_char_variable

    node_cache[:internal_file_unit][start_index] = r0

    r0
  end

  module InternalSubprogramPart0
    def contains_stmt
      elements[0]
    end

    def internal_subprograms
      elements[1]
    end
  end

  def _nt_internal_subprogram_part
    start_index = index
    if node_cache[:internal_subprogram_part].has_key?(index)
      cached = node_cache[:internal_subprogram_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_contains_stmt
    s0 << r1
    if r1
      r2 = _nt_internal_subprograms
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(InternalSubprogramPart0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:internal_subprogram_part][start_index] = r0

    r0
  end

  def _nt_internal_subprogram
    start_index = index
    if node_cache[:internal_subprogram].has_key?(index)
      cached = node_cache[:internal_subprogram][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_subroutine_subprogram
    if r1
      r0 = r1
    else
      r2 = _nt_function_subprogram
      if r2
        r0 = r2
      else
        r3 = _nt_directive
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:internal_subprogram][start_index] = r0

    r0
  end

  def _nt_internal_subprograms
    start_index = index
    if node_cache[:internal_subprograms].has_key?(index)
      cached = node_cache[:internal_subprograms][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_internal_subprogram
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(Internal_Subprograms,input, i0...index, s0)
    end

    node_cache[:internal_subprograms][start_index] = r0

    r0
  end

  def _nt_intrinsic_operator
    start_index = index
    if node_cache[:intrinsic_operator].has_key?(index)
      cached = node_cache[:intrinsic_operator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_power_op
    if r1
      r0 = r1
    else
      r2 = _nt_mult_op
      if r2
        r0 = r2
      else
        r3 = _nt_add_op
        if r3
          r0 = r3
        else
          r4 = _nt_concat_op
          if r4
            r0 = r4
          else
            r5 = _nt_rel_op
            if r5
              r0 = r5
            else
              r6 = _nt_not_op
              if r6
                r0 = r6
              else
                r7 = _nt_and_op
                if r7
                  r0 = r7
                else
                  r8 = _nt_or_op
                  if r8
                    r0 = r8
                  else
                    r9 = _nt_equiv_op
                    if r9
                      r0 = r9
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:intrinsic_operator][start_index] = r0

    r0
  end

  def _nt_intrinsic_procedure_name
    start_index = index
    if node_cache[:intrinsic_procedure_name].has_key?(index)
      cached = node_cache[:intrinsic_procedure_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:intrinsic_procedure_name][start_index] = r0

    r0
  end

  module IntrinsicProcedureNameList0
    def t_comma
      elements[0]
    end

    def intrinsic_procedure_name
      elements[1]
    end
  end

  module IntrinsicProcedureNameList1
    def intrinsic_procedure_name
      elements[0]
    end

  end

  def _nt_intrinsic_procedure_name_list
    start_index = index
    if node_cache[:intrinsic_procedure_name_list].has_key?(index)
      cached = node_cache[:intrinsic_procedure_name_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_intrinsic_procedure_name
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_intrinsic_procedure_name
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(IntrinsicProcedureNameList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Intrinsic_Procedure_Name_List,input, i0...index, s0)
      r0.extend(IntrinsicProcedureNameList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:intrinsic_procedure_name_list][start_index] = r0

    r0
  end

  module IntrinsicStmt0
    def label
      elements[0]
    end

    def t_intrinsic
      elements[1]
    end

    def intrinsic_procedure_name_list
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_intrinsic_stmt
    start_index = index
    if node_cache[:intrinsic_stmt].has_key?(index)
      cached = node_cache[:intrinsic_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_intrinsic
      s0 << r3
      if r3
        r4 = _nt_intrinsic_procedure_name_list
        s0 << r4
        if r4
          r5 = _nt_t_newline
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(IntrinsicStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:intrinsic_stmt][start_index] = r0

    r0
  end

  module IoControlSpec0
    def io_unit
      elements[0]
    end

    def t_comma
      elements[1]
    end

    def format
      elements[2]
    end

  end

  module IoControlSpec1
    def io_unit
      elements[0]
    end

    def t_comma
      elements[1]
    end

    def namelist_group_name
      elements[2]
    end

  end

  module IoControlSpec2
    def t_advance
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_char_expr
      elements[2]
    end
  end

  module IoControlSpec3
    def t_end
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def label
      elements[2]
    end
  end

  module IoControlSpec4
    def t_eor
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def label
      elements[2]
    end
  end

  module IoControlSpec5
    def t_err
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def label
      elements[2]
    end
  end

  module IoControlSpec6
    def t_fmt
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def format
      elements[2]
    end
  end

  module IoControlSpec7
    def t_iostat
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_int_variable
      elements[2]
    end
  end

  module IoControlSpec8
    def t_nml
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def namelist_group_name
      elements[2]
    end
  end

  module IoControlSpec9
    def t_rec
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_int_expr
      elements[2]
    end
  end

  module IoControlSpec10
    def t_size
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_int_variable
      elements[2]
    end
  end

  module IoControlSpec11
    def t_unit
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def io_unit
      elements[2]
    end
  end

  def _nt_io_control_spec
    start_index = index
    if node_cache[:io_control_spec].has_key?(index)
      cached = node_cache[:io_control_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_io_unit
    s1 << r2
    if r2
      r3 = _nt_t_comma
      s1 << r3
      if r3
        r4 = _nt_format
        s1 << r4
        if r4
          i5 = index
          r6 = _nt_t_equal
          if r6
            r5 = nil
          else
            @index = i5
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r5
        end
      end
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(IoControlSpec0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i7, s7 = index, []
      r8 = _nt_io_unit
      s7 << r8
      if r8
        r9 = _nt_t_comma
        s7 << r9
        if r9
          r10 = _nt_namelist_group_name
          s7 << r10
          if r10
            i11 = index
            r12 = _nt_t_equal
            if r12
              r11 = nil
            else
              @index = i11
              r11 = instantiate_node(SyntaxNode,input, index...index)
            end
            s7 << r11
          end
        end
      end
      if s7.last
        r7 = instantiate_node(T,input, i7...index, s7)
        r7.extend(IoControlSpec1)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r0 = r7
      else
        i13, s13 = index, []
        r14 = _nt_t_advance
        s13 << r14
        if r14
          r15 = _nt_t_equal
          s13 << r15
          if r15
            r16 = _nt_scalar_default_char_expr
            s13 << r16
          end
        end
        if s13.last
          r13 = instantiate_node(T,input, i13...index, s13)
          r13.extend(IoControlSpec2)
        else
          @index = i13
          r13 = nil
        end
        if r13
          r0 = r13
        else
          i17, s17 = index, []
          r18 = _nt_t_end
          s17 << r18
          if r18
            r19 = _nt_t_equal
            s17 << r19
            if r19
              r20 = _nt_label
              s17 << r20
            end
          end
          if s17.last
            r17 = instantiate_node(T,input, i17...index, s17)
            r17.extend(IoControlSpec3)
          else
            @index = i17
            r17 = nil
          end
          if r17
            r0 = r17
          else
            i21, s21 = index, []
            r22 = _nt_t_eor
            s21 << r22
            if r22
              r23 = _nt_t_equal
              s21 << r23
              if r23
                r24 = _nt_label
                s21 << r24
              end
            end
            if s21.last
              r21 = instantiate_node(T,input, i21...index, s21)
              r21.extend(IoControlSpec4)
            else
              @index = i21
              r21 = nil
            end
            if r21
              r0 = r21
            else
              i25, s25 = index, []
              r26 = _nt_t_err
              s25 << r26
              if r26
                r27 = _nt_t_equal
                s25 << r27
                if r27
                  r28 = _nt_label
                  s25 << r28
                end
              end
              if s25.last
                r25 = instantiate_node(T,input, i25...index, s25)
                r25.extend(IoControlSpec5)
              else
                @index = i25
                r25 = nil
              end
              if r25
                r0 = r25
              else
                i29, s29 = index, []
                r30 = _nt_t_fmt
                s29 << r30
                if r30
                  r31 = _nt_t_equal
                  s29 << r31
                  if r31
                    r32 = _nt_format
                    s29 << r32
                  end
                end
                if s29.last
                  r29 = instantiate_node(T,input, i29...index, s29)
                  r29.extend(IoControlSpec6)
                else
                  @index = i29
                  r29 = nil
                end
                if r29
                  r0 = r29
                else
                  i33, s33 = index, []
                  r34 = _nt_t_iostat
                  s33 << r34
                  if r34
                    r35 = _nt_t_equal
                    s33 << r35
                    if r35
                      r36 = _nt_scalar_default_int_variable
                      s33 << r36
                    end
                  end
                  if s33.last
                    r33 = instantiate_node(T,input, i33...index, s33)
                    r33.extend(IoControlSpec7)
                  else
                    @index = i33
                    r33 = nil
                  end
                  if r33
                    r0 = r33
                  else
                    i37, s37 = index, []
                    r38 = _nt_t_nml
                    s37 << r38
                    if r38
                      r39 = _nt_t_equal
                      s37 << r39
                      if r39
                        r40 = _nt_namelist_group_name
                        s37 << r40
                      end
                    end
                    if s37.last
                      r37 = instantiate_node(T,input, i37...index, s37)
                      r37.extend(IoControlSpec8)
                    else
                      @index = i37
                      r37 = nil
                    end
                    if r37
                      r0 = r37
                    else
                      i41, s41 = index, []
                      r42 = _nt_t_rec
                      s41 << r42
                      if r42
                        r43 = _nt_t_equal
                        s41 << r43
                        if r43
                          r44 = _nt_scalar_int_expr
                          s41 << r44
                        end
                      end
                      if s41.last
                        r41 = instantiate_node(T,input, i41...index, s41)
                        r41.extend(IoControlSpec9)
                      else
                        @index = i41
                        r41 = nil
                      end
                      if r41
                        r0 = r41
                      else
                        i45, s45 = index, []
                        r46 = _nt_t_size
                        s45 << r46
                        if r46
                          r47 = _nt_t_equal
                          s45 << r47
                          if r47
                            r48 = _nt_scalar_default_int_variable
                            s45 << r48
                          end
                        end
                        if s45.last
                          r45 = instantiate_node(T,input, i45...index, s45)
                          r45.extend(IoControlSpec10)
                        else
                          @index = i45
                          r45 = nil
                        end
                        if r45
                          r0 = r45
                        else
                          i49, s49 = index, []
                          r50 = _nt_t_unit
                          s49 << r50
                          if r50
                            r51 = _nt_t_equal
                            s49 << r51
                            if r51
                              r52 = _nt_io_unit
                              s49 << r52
                            end
                          end
                          if s49.last
                            r49 = instantiate_node(T,input, i49...index, s49)
                            r49.extend(IoControlSpec11)
                          else
                            @index = i49
                            r49 = nil
                          end
                          if r49
                            r0 = r49
                          else
                            r53 = _nt_io_unit
                            if r53
                              r0 = r53
                            else
                              @index = i0
                              r0 = nil
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:io_control_spec][start_index] = r0

    r0
  end

  module IoControlSpecList0
    def t_comma
      elements[0]
    end

    def io_control_spec
      elements[1]
    end
  end

  module IoControlSpecList1
    def io_control_spec
      elements[0]
    end

  end

  def _nt_io_control_spec_list
    start_index = index
    if node_cache[:io_control_spec_list].has_key?(index)
      cached = node_cache[:io_control_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_io_control_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_io_control_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(IoControlSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(IO_Control_Spec_List,input, i0...index, s0)
      r0.extend(IoControlSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:io_control_spec_list][start_index] = r0

    r0
  end

  module IoImpliedDo0
    def t_paren_l
      elements[0]
    end

    def io_implied_do_object_list
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def io_implied_do_control
      elements[3]
    end

    def t_paren_r
      elements[4]
    end
  end

  def _nt_io_implied_do
    start_index = index
    if node_cache[:io_implied_do].has_key?(index)
      cached = node_cache[:io_implied_do][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_io_implied_do_object_list
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_io_implied_do_control
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(IoImpliedDo0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:io_implied_do][start_index] = r0

    r0
  end

  module IoImpliedDoControl0
    def t_comma
      elements[0]
    end

    def scalar_numeric_expr
      elements[1]
    end
  end

  module IoImpliedDoControl1
    def do_variable
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_numeric_expr1
      elements[2]
    end

    def t_comma
      elements[3]
    end

    def scalar_numeric_expr2
      elements[4]
    end

  end

  def _nt_io_implied_do_control
    start_index = index
    if node_cache[:io_implied_do_control].has_key?(index)
      cached = node_cache[:io_implied_do_control][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_do_variable
    s0 << r1
    if r1
      r2 = _nt_t_equal
      s0 << r2
      if r2
        r3 = _nt_scalar_numeric_expr
        s0 << r3
        if r3
          r4 = _nt_t_comma
          s0 << r4
          if r4
            r5 = _nt_scalar_numeric_expr
            s0 << r5
            if r5
              i7, s7 = index, []
              r8 = _nt_t_comma
              s7 << r8
              if r8
                r9 = _nt_scalar_numeric_expr
                s7 << r9
              end
              if s7.last
                r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
                r7.extend(IoImpliedDoControl0)
              else
                @index = i7
                r7 = nil
              end
              if r7
                r6 = r7
              else
                r6 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r6
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(IoImpliedDoControl1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:io_implied_do_control][start_index] = r0

    r0
  end

  module IoImpliedDoObject0
    def output_item
      elements[0]
    end

  end

  module IoImpliedDoObject1
    def input_item
      elements[0]
    end

  end

  def _nt_io_implied_do_object
    start_index = index
    if node_cache[:io_implied_do_object].has_key?(index)
      cached = node_cache[:io_implied_do_object][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_output_item
    s1 << r2
    if r2
      i3 = index
      r4 = _nt_t_equal
      if r4
        r3 = nil
      else
        @index = i3
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(E,input, i1...index, s1)
      r1.extend(IoImpliedDoObject0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_input_item
      s5 << r6
      if r6
        i7 = index
        r8 = _nt_t_equal
        if r8
          r7 = nil
        else
          @index = i7
          r7 = instantiate_node(SyntaxNode,input, index...index)
        end
        s5 << r7
      end
      if s5.last
        r5 = instantiate_node(E,input, i5...index, s5)
        r5.extend(IoImpliedDoObject1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:io_implied_do_object][start_index] = r0

    r0
  end

  module IoImpliedDoObjectList0
    def t_comma
      elements[0]
    end

    def io_implied_do_object
      elements[1]
    end
  end

  module IoImpliedDoObjectList1
    def io_implied_do_object
      elements[0]
    end

  end

  def _nt_io_implied_do_object_list
    start_index = index
    if node_cache[:io_implied_do_object_list].has_key?(index)
      cached = node_cache[:io_implied_do_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_io_implied_do_object
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_io_implied_do_object
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(IoImpliedDoObjectList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(IO_Implied_Do_Object_List,input, i0...index, s0)
      r0.extend(IoImpliedDoObjectList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:io_implied_do_object_list][start_index] = r0

    r0
  end

  def _nt_io_unit
    start_index = index
    if node_cache[:io_unit].has_key?(index)
      cached = node_cache[:io_unit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_star
    if r1
      r0 = r1
    else
      r2 = _nt_external_file_unit
      if r2
        r0 = r2
      else
        r3 = _nt_internal_file_unit
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:io_unit][start_index] = r0

    r0
  end

  def _nt_keyword
    start_index = index
    if node_cache[:keyword].has_key?(index)
      cached = node_cache[:keyword][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_dummy_arg_name

    node_cache[:keyword][start_index] = r0

    r0
  end

  def _nt_keyword_option
    start_index = index
    if node_cache[:keyword_option].has_key?(index)
      cached = node_cache[:keyword_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r1 = _nt_keyword_pair
    if r1
      r0 = r1
    else
      r0 = instantiate_node(SyntaxNode,input, index...index)
    end

    node_cache[:keyword_option][start_index] = r0

    r0
  end

  module KeywordPair0
    def keyword
      elements[0]
    end

    def t_equal
      elements[1]
    end
  end

  def _nt_keyword_pair
    start_index = index
    if node_cache[:keyword_pair].has_key?(index)
      cached = node_cache[:keyword_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_keyword
    s0 << r1
    if r1
      r2 = _nt_t_equal
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(KeywordPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:keyword_pair][start_index] = r0

    r0
  end

  module KindPair0
    def t_kind
      elements[0]
    end

    def t_equal
      elements[1]
    end
  end

  def _nt_kind_pair
    start_index = index
    if node_cache[:kind_pair].has_key?(index)
      cached = node_cache[:kind_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_kind
    s0 << r1
    if r1
      r2 = _nt_t_equal
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(KindPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:kind_pair][start_index] = r0

    r0
  end

  def _nt_kind_param
    start_index = index
    if node_cache[:kind_param].has_key?(index)
      cached = node_cache[:kind_param][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_digit_string
    if r1
      r0 = r1
    else
      r2 = _nt_scalar_int_constant_name
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:kind_param][start_index] = r0

    r0
  end

  module KindSelector0
    def t_paren_l
      elements[0]
    end

    def scalar_int_initialization_expr
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_kind_selector
    start_index = index
    if node_cache[:kind_selector].has_key?(index)
      cached = node_cache[:kind_selector][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r3 = _nt_kind_pair
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_scalar_int_initialization_expr
        s0 << r4
        if r4
          r5 = _nt_t_paren_r
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Kind_Selector,input, i0...index, s0)
      r0.extend(KindSelector0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:kind_selector][start_index] = r0

    r0
  end

  def _nt_label
    start_index = index
    if node_cache[:label].has_key?(index)
      cached = node_cache[:label][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_t_digit
      if r1
        s0 << r1
      else
        break
      end
      if s0.size == 5
        break
      end
    end
    if s0.size < 1
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(T,input, i0...index, s0)
    end

    node_cache[:label][start_index] = r0

    r0
  end

  module LabelDoStmt0
    def label
      elements[0]
    end

    def t_do
      elements[2]
    end

    def dolabel
      elements[3]
    end

    def t_newline
      elements[5]
    end

  end

  def _nt_label_do_stmt
    start_index = index
    if node_cache[:label_do_stmt].has_key?(index)
      cached = node_cache[:label_do_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r4 = _nt_do_construct_name_label
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r5 = _nt_t_do
        s0 << r5
        if r5
          r6 = _nt_label
          s0 << r6
          if r6
            r8 = _nt_loop_control
            if r8
              r7 = r8
            else
              r7 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r7
            if r7
              r9 = _nt_t_newline
              s0 << r9
              if r9
                i10 = index
                r11 = lambda { |e| dolabel_push(e[3]) }.call(s0)
                if r11
                  @index = i10
                  r10 = instantiate_node(SyntaxNode,input, index...index)
                else
                  r10 = nil
                end
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Label_Do_Stmt,input, i0...index, s0)
      r0.extend(LabelDoStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:label_do_stmt][start_index] = r0

    r0
  end

  module LabelList0
    def t_comma
      elements[0]
    end

    def label
      elements[1]
    end
  end

  module LabelList1
    def label
      elements[0]
    end

  end

  def _nt_label_list
    start_index = index
    if node_cache[:label_list].has_key?(index)
      cached = node_cache[:label_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_label
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_label
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(LabelList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Label_List,input, i0...index, s0)
      r0.extend(LabelList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:label_list][start_index] = r0

    r0
  end

  module LenPair0
    def t_len
      elements[0]
    end

    def t_equal
      elements[1]
    end
  end

  def _nt_len_pair
    start_index = index
    if node_cache[:len_pair].has_key?(index)
      cached = node_cache[:len_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_len
    s0 << r1
    if r1
      r2 = _nt_t_equal
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(LenPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:len_pair][start_index] = r0

    r0
  end

  module LengthSelector0
    def t_paren_l
      elements[0]
    end

    def type_param_value
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  module LengthSelector1
    def double_colon
      elements[1]
    end
  end

  module LengthSelector2
    def char_length_pair
      elements[0]
    end

  end

  module LengthSelector3
    def char_length_pair
      elements[0]
    end

  end

  def _nt_length_selector
    start_index = index
    if node_cache[:length_selector].has_key?(index)
      cached = node_cache[:length_selector][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_paren_l
    s1 << r2
    if r2
      r4 = _nt_len_pair
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r3
      if r3
        r5 = _nt_type_param_value
        s1 << r5
        if r5
          r6 = _nt_t_paren_r
          s1 << r6
        end
      end
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(LengthSelector0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i7, s7 = index, []
      r8 = _nt_char_length_pair
      s7 << r8
      if r8
        i9 = index
        i10, s10 = index, []
        s11, i11 = [], index
        loop do
          if has_terminal?('\G[^\\:\\n]', true, index)
            r12 = true
            @index += 1
          else
            r12 = nil
          end
          if r12
            s11 << r12
          else
            break
          end
        end
        r11 = instantiate_node(SyntaxNode,input, i11...index, s11)
        s10 << r11
        if r11
          r13 = _nt_double_colon
          s10 << r13
        end
        if s10.last
          r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
          r10.extend(LengthSelector1)
        else
          @index = i10
          r10 = nil
        end
        if r10
          @index = i9
          r9 = instantiate_node(SyntaxNode,input, index...index)
        else
          r9 = nil
        end
        s7 << r9
      end
      if s7.last
        r7 = instantiate_node(T,input, i7...index, s7)
        r7.extend(LengthSelector2)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r0 = r7
      else
        i14, s14 = index, []
        r15 = _nt_char_length_pair
        s14 << r15
        if r15
          r17 = _nt_t_comma
          if r17
            r16 = r17
          else
            r16 = instantiate_node(SyntaxNode,input, index...index)
          end
          s14 << r16
        end
        if s14.last
          r14 = instantiate_node(T,input, i14...index, s14)
          r14.extend(LengthSelector3)
        else
          @index = i14
          r14 = nil
        end
        if r14
          r0 = r14
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:length_selector][start_index] = r0

    r0
  end

  module LetterSpec0
    def t_minus
      elements[0]
    end

    def t_letter
      elements[1]
    end
  end

  module LetterSpec1
    def t_letter
      elements[0]
    end

  end

  def _nt_letter_spec
    start_index = index
    if node_cache[:letter_spec].has_key?(index)
      cached = node_cache[:letter_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_letter
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_t_minus
      s3 << r4
      if r4
        r5 = _nt_t_letter
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(LetterSpec0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(LetterSpec1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:letter_spec][start_index] = r0

    r0
  end

  module LetterSpecList0
    def t_comma
      elements[0]
    end

    def letter_spec
      elements[1]
    end
  end

  module LetterSpecList1
    def letter_spec
      elements[0]
    end

  end

  def _nt_letter_spec_list
    start_index = index
    if node_cache[:letter_spec_list].has_key?(index)
      cached = node_cache[:letter_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_letter_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_letter_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(LetterSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Letter_Spec_List,input, i0...index, s0)
      r0.extend(LetterSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:letter_spec_list][start_index] = r0

    r0
  end

  module Level1Expr0
    def primary
      elements[1]
    end
  end

  def _nt_level_1_expr
    start_index = index
    if node_cache[:level_1_expr].has_key?(index)
      cached = node_cache[:level_1_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_defined_unary_op
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_primary
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(Level1Expr0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:level_1_expr][start_index] = r0

    r0
  end

  module Level2Expr0
    def add_operand
      elements[1]
    end

  end

  def _nt_level_2_expr
    start_index = index
    if node_cache[:level_2_expr].has_key?(index)
      cached = node_cache[:level_2_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_add_op
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_add_operand
      s0 << r3
      if r3
        r5 = _nt_level_2_expr
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(Level2Expr0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:level_2_expr][start_index] = r0

    r0
  end

  module Level3Expr0
    def level_2_expr
      elements[0]
    end

  end

  def _nt_level_3_expr
    start_index = index
    if node_cache[:level_3_expr].has_key?(index)
      cached = node_cache[:level_3_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_level_2_expr
    s0 << r1
    if r1
      r3 = _nt_level_3_expr_option
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(Level3Expr0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:level_3_expr][start_index] = r0

    r0
  end

  module Level3ExprOption0
    def concat_op
      elements[0]
    end

    def level_3_expr
      elements[1]
    end
  end

  def _nt_level_3_expr_option
    start_index = index
    if node_cache[:level_3_expr_option].has_key?(index)
      cached = node_cache[:level_3_expr_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_concat_op
    s0 << r1
    if r1
      r2 = _nt_level_3_expr
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(Level3ExprOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:level_3_expr_option][start_index] = r0

    r0
  end

  module Level4Expr0
    def level_3_expr
      elements[0]
    end

  end

  def _nt_level_4_expr
    start_index = index
    if node_cache[:level_4_expr].has_key?(index)
      cached = node_cache[:level_4_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_level_3_expr
    s0 << r1
    if r1
      r3 = _nt_level_4_expr_option
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(Level4Expr0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:level_4_expr][start_index] = r0

    r0
  end

  module Level4ExprOption0
    def rel_op
      elements[0]
    end

    def level_3_expr
      elements[1]
    end
  end

  def _nt_level_4_expr_option
    start_index = index
    if node_cache[:level_4_expr_option].has_key?(index)
      cached = node_cache[:level_4_expr_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_rel_op
    s0 << r1
    if r1
      r2 = _nt_level_3_expr
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(Level4ExprOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:level_4_expr_option][start_index] = r0

    r0
  end

  module Level5Expr0
    def equiv_operand
      elements[0]
    end

  end

  def _nt_level_5_expr
    start_index = index
    if node_cache[:level_5_expr].has_key?(index)
      cached = node_cache[:level_5_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_equiv_operand
    s0 << r1
    if r1
      r3 = _nt_level_5_expr_option
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(Level5Expr0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:level_5_expr][start_index] = r0

    r0
  end

  module Level5ExprOption0
    def equiv_op
      elements[0]
    end

    def level_5_expr
      elements[1]
    end
  end

  def _nt_level_5_expr_option
    start_index = index
    if node_cache[:level_5_expr_option].has_key?(index)
      cached = node_cache[:level_5_expr_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_equiv_op
    s0 << r1
    if r1
      r2 = _nt_level_5_expr
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(Level5ExprOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:level_5_expr_option][start_index] = r0

    r0
  end

  def _nt_literal_constant
    start_index = index
    if node_cache[:literal_constant].has_key?(index)
      cached = node_cache[:literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_complex_literal_constant
    if r1
      r0 = r1
    else
      r2 = _nt_signed_real_literal_constant
      if r2
        r0 = r2
      else
        r3 = _nt_signed_int_literal_constant
        if r3
          r0 = r3
        else
          r4 = _nt_logical_literal_constant
          if r4
            r0 = r4
          else
            r5 = _nt_char_literal_constant
            if r5
              r0 = r5
            else
              r6 = _nt_boz_literal_constant
              if r6
                r0 = r6
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end
    end

    node_cache[:literal_constant][start_index] = r0

    r0
  end

  def _nt_local_name
    start_index = index
    if node_cache[:local_name].has_key?(index)
      cached = node_cache[:local_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:local_name][start_index] = r0

    r0
  end

  def _nt_logical_expr
    start_index = index
    if node_cache[:logical_expr].has_key?(index)
      cached = node_cache[:logical_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_expr

    node_cache[:logical_expr][start_index] = r0

    r0
  end

  def _nt_logical_initialization_expr
    start_index = index
    if node_cache[:logical_initialization_expr].has_key?(index)
      cached = node_cache[:logical_initialization_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_logical_expr

    node_cache[:logical_initialization_expr][start_index] = r0

    r0
  end

  module LogicalLiteralConstant0
    def t_underscore
      elements[0]
    end

    def kind_param
      elements[1]
    end
  end

  module LogicalLiteralConstant1
  end

  def _nt_logical_literal_constant
    start_index = index
    if node_cache[:logical_literal_constant].has_key?(index)
      cached = node_cache[:logical_literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_t_true
    if r2
      r1 = r2
    else
      r3 = _nt_t_false
      if r3
        r1 = r3
      else
        @index = i1
        r1 = nil
      end
    end
    s0 << r1
    if r1
      i5, s5 = index, []
      r6 = _nt_t_underscore
      s5 << r6
      if r6
        r7 = _nt_kind_param
        s5 << r7
      end
      if s5.last
        r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        r5.extend(LogicalLiteralConstant0)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r4 = r5
      else
        r4 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r4
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(LogicalLiteralConstant1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:logical_literal_constant][start_index] = r0

    r0
  end

  def _nt_logical_variable
    start_index = index
    if node_cache[:logical_variable].has_key?(index)
      cached = node_cache[:logical_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable

    node_cache[:logical_variable][start_index] = r0

    r0
  end

  module LoopControl0
    def do_variable
      elements[1]
    end

    def t_equal
      elements[2]
    end

    def scalar_numeric_expr
      elements[3]
    end

    def loop_control_pair
      elements[4]
    end

  end

  module LoopControl1
    def t_while
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def scalar_logical_expr
      elements[3]
    end

    def t_paren_r
      elements[4]
    end
  end

  def _nt_loop_control
    start_index = index
    if node_cache[:loop_control].has_key?(index)
      cached = node_cache[:loop_control][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_t_comma
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r4 = _nt_do_variable
      s1 << r4
      if r4
        r5 = _nt_t_equal
        s1 << r5
        if r5
          r6 = _nt_scalar_numeric_expr
          s1 << r6
          if r6
            r7 = _nt_loop_control_pair
            s1 << r7
            if r7
              r9 = _nt_loop_control_pair
              if r9
                r8 = r9
              else
                r8 = instantiate_node(SyntaxNode,input, index...index)
              end
              s1 << r8
            end
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(Loop_Control_1,input, i1...index, s1)
      r1.extend(LoopControl0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i10, s10 = index, []
      r12 = _nt_t_comma
      if r12
        r11 = r12
      else
        r11 = instantiate_node(SyntaxNode,input, index...index)
      end
      s10 << r11
      if r11
        r13 = _nt_t_while
        s10 << r13
        if r13
          r14 = _nt_t_paren_l
          s10 << r14
          if r14
            r15 = _nt_scalar_logical_expr
            s10 << r15
            if r15
              r16 = _nt_t_paren_r
              s10 << r16
            end
          end
        end
      end
      if s10.last
        r10 = instantiate_node(Loop_Control_2,input, i10...index, s10)
        r10.extend(LoopControl1)
      else
        @index = i10
        r10 = nil
      end
      if r10
        r0 = r10
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:loop_control][start_index] = r0

    r0
  end

  module LoopControlPair0
    def t_comma
      elements[0]
    end

    def scalar_numeric_expr
      elements[1]
    end
  end

  def _nt_loop_control_pair
    start_index = index
    if node_cache[:loop_control_pair].has_key?(index)
      cached = node_cache[:loop_control_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_scalar_numeric_expr
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Loop_Control_Pair,input, i0...index, s0)
      r0.extend(LoopControlPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:loop_control_pair][start_index] = r0

    r0
  end

  def _nt_lower_bound
    start_index = index
    if node_cache[:lower_bound].has_key?(index)
      cached = node_cache[:lower_bound][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_specification_expr

    node_cache[:lower_bound][start_index] = r0

    r0
  end

  module LowerBoundPair0
    def lower_bound
      elements[0]
    end

    def t_colon
      elements[1]
    end
  end

  def _nt_lower_bound_pair
    start_index = index
    if node_cache[:lower_bound_pair].has_key?(index)
      cached = node_cache[:lower_bound_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_lower_bound
    s0 << r1
    if r1
      r2 = _nt_t_colon
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Lower_Bound_Pair,input, i0...index, s0)
      r0.extend(LowerBoundPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:lower_bound_pair][start_index] = r0

    r0
  end

  module MainProgram0
    def end_program_stmt
      elements[4]
    end
  end

  def _nt_main_program
    start_index = index
    if node_cache[:main_program].has_key?(index)
      cached = node_cache[:main_program][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_program_stmt
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r4 = _nt_specification_part
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r6 = _nt_execution_part
        if r6
          r5 = r6
        else
          r5 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r5
        if r5
          r8 = _nt_internal_subprogram_part
          if r8
            r7 = r8
          else
            r7 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r7
          if r7
            r9 = _nt_end_program_stmt
            s0 << r9
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Main_Program,input, i0...index, s0)
      r0.extend(MainProgram0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:main_program][start_index] = r0

    r0
  end

  def _nt_mask_expr
    start_index = index
    if node_cache[:mask_expr].has_key?(index)
      cached = node_cache[:mask_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_logical_expr

    node_cache[:mask_expr][start_index] = r0

    r0
  end

  module Module0
    def module_stmt
      elements[0]
    end

    def end_module_stmt
      elements[3]
    end
  end

  def _nt_module
    start_index = index
    if node_cache[:module].has_key?(index)
      cached = node_cache[:module][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_module_stmt
    s0 << r1
    if r1
      r3 = _nt_specification_part
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r5 = _nt_module_subprogram_part
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_end_module_stmt
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Module,input, i0...index, s0)
      r0.extend(Module0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:module][start_index] = r0

    r0
  end

  def _nt_module_name
    start_index = index
    if node_cache[:module_name].has_key?(index)
      cached = node_cache[:module_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:module_name][start_index] = r0

    r0
  end

  module ModuleProcedureStmt0
    def label
      elements[0]
    end

    def t_module
      elements[1]
    end

    def t_procedure
      elements[2]
    end

    def procedure_name_list
      elements[3]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_module_procedure_stmt
    start_index = index
    if node_cache[:module_procedure_stmt].has_key?(index)
      cached = node_cache[:module_procedure_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_module
      s0 << r3
      if r3
        r4 = _nt_t_procedure
        s0 << r4
        if r4
          r5 = _nt_procedure_name_list
          s0 << r5
          if r5
            r6 = _nt_t_newline
            s0 << r6
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(ModuleProcedureStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:module_procedure_stmt][start_index] = r0

    r0
  end

  def _nt_module_procedure_stmts
    start_index = index
    if node_cache[:module_procedure_stmts].has_key?(index)
      cached = node_cache[:module_procedure_stmts][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_module_procedure_stmt
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:module_procedure_stmts][start_index] = r0

    r0
  end

  module ModuleStmt0
    def label
      elements[0]
    end

    def t_module
      elements[1]
    end

    def module_name
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_module_stmt
    start_index = index
    if node_cache[:module_stmt].has_key?(index)
      cached = node_cache[:module_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_module
      s0 << r3
      if r3
        r4 = _nt_module_name
        s0 << r4
        if r4
          r5 = _nt_t_newline
          s0 << r5
          if r5
            i6 = index
            r7 = lambda { |e| sp_module_stmt }.call(s0)
            if r7
              @index = i6
              r6 = instantiate_node(SyntaxNode,input, index...index)
            else
              r6 = nil
            end
            s0 << r6
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Module_Stmt,input, i0...index, s0)
      r0.extend(ModuleStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:module_stmt][start_index] = r0

    r0
  end

  def _nt_module_subprogram
    start_index = index
    if node_cache[:module_subprogram].has_key?(index)
      cached = node_cache[:module_subprogram][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_subroutine_subprogram
    if r1
      r0 = r1
    else
      r2 = _nt_function_subprogram
      if r2
        r0 = r2
      else
        r3 = _nt_directive
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:module_subprogram][start_index] = r0

    r0
  end

  module ModuleSubprogramPart0
    def contains_stmt
      elements[0]
    end

  end

  def _nt_module_subprogram_part
    start_index = index
    if node_cache[:module_subprogram_part].has_key?(index)
      cached = node_cache[:module_subprogram_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_contains_stmt
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_module_subprogram
        if r3
          s2 << r3
        else
          break
        end
      end
      if s2.empty?
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Module_Subprogram_Part,input, i0...index, s0)
      r0.extend(ModuleSubprogramPart0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:module_subprogram_part][start_index] = r0

    r0
  end

  def _nt_mult_op
    start_index = index
    if node_cache[:mult_op].has_key?(index)
      cached = node_cache[:mult_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_star
    if r1
      r0 = r1
    else
      r2 = _nt_t_slash
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:mult_op][start_index] = r0

    r0
  end

  module MultOperand0
    def power_op
      elements[0]
    end

    def mult_operand
      elements[1]
    end
  end

  module MultOperand1
    def level_1_expr
      elements[0]
    end

  end

  def _nt_mult_operand
    start_index = index
    if node_cache[:mult_operand].has_key?(index)
      cached = node_cache[:mult_operand][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_level_1_expr
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_power_op
      s3 << r4
      if r4
        r5 = _nt_mult_operand
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(MultOperand0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Mult_Operand,input, i0...index, s0)
      r0.extend(MultOperand1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:mult_operand][start_index] = r0

    r0
  end

  module Name0
    def t_letter
      elements[0]
    end

  end

  def _nt_name
    start_index = index
    if node_cache[:name].has_key?(index)
      cached = node_cache[:name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_letter
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_alphanumeric_character
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Name,input, i0...index, s0)
      r0.extend(Name0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:name][start_index] = r0

    r0
  end

  def _nt_named_constant
    start_index = index
    if node_cache[:named_constant].has_key?(index)
      cached = node_cache[:named_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:named_constant][start_index] = r0

    r0
  end

  module NamedConstantDef0
    def named_constant
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def initialization_expr
      elements[2]
    end
  end

  def _nt_named_constant_def
    start_index = index
    if node_cache[:named_constant_def].has_key?(index)
      cached = node_cache[:named_constant_def][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_named_constant
    s0 << r1
    if r1
      r2 = _nt_t_equal
      s0 << r2
      if r2
        r3 = _nt_initialization_expr
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(NamedConstantDef0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:named_constant_def][start_index] = r0

    r0
  end

  module NamedConstantDefList0
    def t_comma
      elements[0]
    end

    def named_constant_def
      elements[1]
    end
  end

  module NamedConstantDefList1
    def named_constant_def
      elements[0]
    end

  end

  def _nt_named_constant_def_list
    start_index = index
    if node_cache[:named_constant_def_list].has_key?(index)
      cached = node_cache[:named_constant_def_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_named_constant_def
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_named_constant_def
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(NamedConstantDefList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Named_Constant_Def_List,input, i0...index, s0)
      r0.extend(NamedConstantDefList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:named_constant_def_list][start_index] = r0

    r0
  end

  def _nt_namelist_group_name
    start_index = index
    if node_cache[:namelist_group_name].has_key?(index)
      cached = node_cache[:namelist_group_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:namelist_group_name][start_index] = r0

    r0
  end

  def _nt_namelist_group_object
    start_index = index
    if node_cache[:namelist_group_object].has_key?(index)
      cached = node_cache[:namelist_group_object][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable_name

    node_cache[:namelist_group_object][start_index] = r0

    r0
  end

  module NamelistGroupObjectList0
    def t_comma
      elements[0]
    end

    def namelist_group_object
      elements[1]
    end
  end

  module NamelistGroupObjectList1
    def namelist_group_object
      elements[0]
    end

  end

  def _nt_namelist_group_object_list
    start_index = index
    if node_cache[:namelist_group_object_list].has_key?(index)
      cached = node_cache[:namelist_group_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_namelist_group_object
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_namelist_group_object
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(NamelistGroupObjectList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Namelist_Group_Object_List,input, i0...index, s0)
      r0.extend(NamelistGroupObjectList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:namelist_group_object_list][start_index] = r0

    r0
  end

  module NamelistGroupSet0
    def t_slash1
      elements[0]
    end

    def namelist_group_name
      elements[1]
    end

    def t_slash2
      elements[2]
    end

    def namelist_group_object_list
      elements[3]
    end
  end

  def _nt_namelist_group_set
    start_index = index
    if node_cache[:namelist_group_set].has_key?(index)
      cached = node_cache[:namelist_group_set][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_slash
    s0 << r1
    if r1
      r2 = _nt_namelist_group_name
      s0 << r2
      if r2
        r3 = _nt_t_slash
        s0 << r3
        if r3
          r4 = _nt_namelist_group_object_list
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(NamelistGroupSet0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:namelist_group_set][start_index] = r0

    r0
  end

  module NamelistGroupSetPair0
    def namelist_group_set
      elements[1]
    end
  end

  def _nt_namelist_group_set_pair
    start_index = index
    if node_cache[:namelist_group_set_pair].has_key?(index)
      cached = node_cache[:namelist_group_set_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_t_comma
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_namelist_group_set
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(Namelist_Group_Set_Pair,input, i0...index, s0)
      r0.extend(NamelistGroupSetPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:namelist_group_set_pair][start_index] = r0

    r0
  end

  def _nt_namelist_group_sets
    start_index = index
    if node_cache[:namelist_group_sets].has_key?(index)
      cached = node_cache[:namelist_group_sets][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_namelist_group_set_pair
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:namelist_group_sets][start_index] = r0

    r0
  end

  module NamelistStmt0
    def label
      elements[0]
    end

    def t_namelist
      elements[1]
    end

    def namelist_group_set
      elements[2]
    end

    def namelist_group_sets
      elements[3]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_namelist_stmt
    start_index = index
    if node_cache[:namelist_stmt].has_key?(index)
      cached = node_cache[:namelist_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_namelist
      s0 << r3
      if r3
        r4 = _nt_namelist_group_set
        s0 << r4
        if r4
          r5 = _nt_namelist_group_sets
          s0 << r5
          if r5
            r6 = _nt_t_newline
            s0 << r6
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Namelist_Stmt,input, i0...index, s0)
      r0.extend(NamelistStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:namelist_stmt][start_index] = r0

    r0
  end

  def _nt_nonblock_do_construct
    start_index = index
    if node_cache[:nonblock_do_construct].has_key?(index)
      cached = node_cache[:nonblock_do_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_outer_shared_do_construct
    if r1
      r0 = r1
    else
      r2 = _nt_action_term_do_construct
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:nonblock_do_construct][start_index] = r0

    r0
  end

  module NonlabelDoStmt0
    def label
      elements[0]
    end

    def t_do
      elements[2]
    end

    def t_newline
      elements[4]
    end

  end

  def _nt_nonlabel_do_stmt
    start_index = index
    if node_cache[:nonlabel_do_stmt].has_key?(index)
      cached = node_cache[:nonlabel_do_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r4 = _nt_do_construct_name_label
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r5 = _nt_t_do
        s0 << r5
        if r5
          r7 = _nt_loop_control
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r6
          if r6
            r8 = _nt_t_newline
            s0 << r8
            if r8
              i9 = index
              r10 = lambda { |e| dolabel_push(:nolabel) }.call(s0)
              if r10
                @index = i9
                r9 = instantiate_node(SyntaxNode,input, index...index)
              else
                r9 = nil
              end
              s0 << r9
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Nonlabel_Do_Stmt,input, i0...index, s0)
      r0.extend(NonlabelDoStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:nonlabel_do_stmt][start_index] = r0

    r0
  end

  def _nt_not_op
    start_index = index
    if node_cache[:not_op].has_key?(index)
      cached = node_cache[:not_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(".not.", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure(".not.")
      r0 = nil
    end

    node_cache[:not_op][start_index] = r0

    r0
  end

  module NullFunctionRef0
    def t_null
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_null_function_ref
    start_index = index
    if node_cache[:null_function_ref].has_key?(index)
      cached = node_cache[:null_function_ref][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_null
    s0 << r1
    if r1
      r2 = _nt_t_paren_l
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(NullFunctionRef0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:null_function_ref][start_index] = r0

    r0
  end

  module NullifyStmt0
    def label
      elements[0]
    end

    def t_nullify
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def pointer_object_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_nullify_stmt
    start_index = index
    if node_cache[:nullify_stmt].has_key?(index)
      cached = node_cache[:nullify_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_nullify
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_pointer_object_list
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r7 = _nt_t_newline
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtC,input, i0...index, s0)
      r0.extend(NullifyStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:nullify_stmt][start_index] = r0

    r0
  end

  def _nt_numeric_expr
    start_index = index
    if node_cache[:numeric_expr].has_key?(index)
      cached = node_cache[:numeric_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_expr

    node_cache[:numeric_expr][start_index] = r0

    r0
  end

  def _nt_object_name
    start_index = index
    if node_cache[:object_name].has_key?(index)
      cached = node_cache[:object_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:object_name][start_index] = r0

    r0
  end

  module ObjectNameAndSpecList0
    def object_name
      elements[0]
    end

  end

  def _nt_object_name_and_spec_list
    start_index = index
    if node_cache[:object_name_and_spec_list].has_key?(index)
      cached = node_cache[:object_name_and_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_object_name
    s0 << r1
    if r1
      r3 = _nt_parenthesized_deferred_shape_spec_list
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ObjectNameAndSpecList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:object_name_and_spec_list][start_index] = r0

    r0
  end

  module ObjectNameAndSpecListPair0
    def t_comma
      elements[0]
    end

    def object_name_and_spec_list
      elements[1]
    end
  end

  def _nt_object_name_and_spec_list_pair
    start_index = index
    if node_cache[:object_name_and_spec_list_pair].has_key?(index)
      cached = node_cache[:object_name_and_spec_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_object_name_and_spec_list
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ObjectNameAndSpecListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:object_name_and_spec_list_pair][start_index] = r0

    r0
  end

  module ObjectNamesAndSpecLists0
    def object_name_and_spec_list
      elements[0]
    end

  end

  def _nt_object_names_and_spec_lists
    start_index = index
    if node_cache[:object_names_and_spec_lists].has_key?(index)
      cached = node_cache[:object_names_and_spec_lists][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_object_name_and_spec_list
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_object_name_and_spec_list_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(ObjectNamesAndSpecLists0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:object_names_and_spec_lists][start_index] = r0

    r0
  end

  module OctalConstant0
    def t_apostrophe1
      elements[0]
    end

    def t_apostrophe2
      elements[2]
    end
  end

  module OctalConstant1
    def t_quotemark1
      elements[0]
    end

    def t_quotemark2
      elements[2]
    end
  end

  module OctalConstant2
  end

  def _nt_octal_constant
    start_index = index
    if node_cache[:octal_constant].has_key?(index)
      cached = node_cache[:octal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("o", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("o")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      i3, s3 = index, []
      r4 = _nt_t_apostrophe
      s3 << r4
      if r4
        s5, i5 = [], index
        loop do
          r6 = _nt_t_octal
          if r6
            s5 << r6
          else
            break
          end
        end
        if s5.empty?
          @index = i5
          r5 = nil
        else
          r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
        end
        s3 << r5
        if r5
          r7 = _nt_t_apostrophe
          s3 << r7
        end
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(OctalConstant0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        i8, s8 = index, []
        r9 = _nt_t_quotemark
        s8 << r9
        if r9
          s10, i10 = [], index
          loop do
            r11 = _nt_t_octal
            if r11
              s10 << r11
            else
              break
            end
          end
          if s10.empty?
            @index = i10
            r10 = nil
          else
            r10 = instantiate_node(SyntaxNode,input, i10...index, s10)
          end
          s8 << r10
          if r10
            r12 = _nt_t_quotemark
            s8 << r12
          end
        end
        if s8.last
          r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
          r8.extend(OctalConstant1)
        else
          @index = i8
          r8 = nil
        end
        if r8
          r2 = r8
        else
          @index = i2
          r2 = nil
        end
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(OctalConstant2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:octal_constant][start_index] = r0

    r0
  end

  module Only0
    def use_name
      elements[1]
    end
  end

  def _nt_only
    start_index = index
    if node_cache[:only].has_key?(index)
      cached = node_cache[:only][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_only_option
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r4 = _nt_use_name
      s1 << r4
    end
    if s1.last
      r1 = instantiate_node(Only,input, i1...index, s1)
      r1.extend(Only0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r5 = _nt_access_id
      if r5
        r0 = r5
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:only][start_index] = r0

    r0
  end

  module OnlyList0
    def only
      elements[0]
    end

  end

  def _nt_only_list
    start_index = index
    if node_cache[:only_list].has_key?(index)
      cached = node_cache[:only_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_only
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_only_list_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Only_List,input, i0...index, s0)
      r0.extend(OnlyList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:only_list][start_index] = r0

    r0
  end

  module OnlyListPair0
    def t_comma
      elements[0]
    end

    def only
      elements[1]
    end
  end

  def _nt_only_list_pair
    start_index = index
    if node_cache[:only_list_pair].has_key?(index)
      cached = node_cache[:only_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_only
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Only_List_Pair,input, i0...index, s0)
      r0.extend(OnlyListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:only_list_pair][start_index] = r0

    r0
  end

  module OnlyOption0
    def local_name
      elements[0]
    end

    def t_point
      elements[1]
    end
  end

  def _nt_only_option
    start_index = index
    if node_cache[:only_option].has_key?(index)
      cached = node_cache[:only_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_local_name
    s0 << r1
    if r1
      r2 = _nt_t_point
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Only_Option,input, i0...index, s0)
      r0.extend(OnlyOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:only_option][start_index] = r0

    r0
  end

  module OpenStmt0
    def label
      elements[0]
    end

    def t_open
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def connect_spec_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_open_stmt
    start_index = index
    if node_cache[:open_stmt].has_key?(index)
      cached = node_cache[:open_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_open
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_connect_spec_list
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r7 = _nt_t_newline
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtC,input, i0...index, s0)
      r0.extend(OpenStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:open_stmt][start_index] = r0

    r0
  end

  module OptionalStmt0
    def label
      elements[0]
    end

    def t_optional
      elements[1]
    end

    def dummy_arg_name_list
      elements[3]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_optional_stmt
    start_index = index
    if node_cache[:optional_stmt].has_key?(index)
      cached = node_cache[:optional_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_optional
      s0 << r3
      if r3
        r5 = _nt_double_colon
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_dummy_arg_name_list
          s0 << r6
          if r6
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Optional_Stmt,input, i0...index, s0)
      r0.extend(OptionalStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:optional_stmt][start_index] = r0

    r0
  end

  def _nt_or_op
    start_index = index
    if node_cache[:or_op].has_key?(index)
      cached = node_cache[:or_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(".or.", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure(".or.")
      r0 = nil
    end

    node_cache[:or_op][start_index] = r0

    r0
  end

  module OuterSharedDoConstruct0
    def label_do_stmt
      elements[0]
    end

    def do_body
      elements[2]
    end

    def shared_term_do_construct
      elements[3]
    end
  end

  def _nt_outer_shared_do_construct
    start_index = index
    if node_cache[:outer_shared_do_construct].has_key?(index)
      cached = node_cache[:outer_shared_do_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_label_do_stmt
    s0 << r1
    if r1
      i2 = index
      r3 = lambda { |e| dolabel_dupe? }.call(s0)
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_do_body
        s0 << r4
        if r4
          r5 = _nt_shared_term_do_construct
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(OuterSharedDoConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:outer_shared_do_construct][start_index] = r0

    r0
  end

  def _nt_output_item
    start_index = index
    if node_cache[:output_item].has_key?(index)
      cached = node_cache[:output_item][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_io_implied_do
    if r1
      r0 = r1
    else
      r2 = _nt_expr
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:output_item][start_index] = r0

    r0
  end

  module OutputItemList0
    def t_comma
      elements[0]
    end

    def output_item
      elements[1]
    end
  end

  module OutputItemList1
    def output_item
      elements[0]
    end

  end

  def _nt_output_item_list
    start_index = index
    if node_cache[:output_item_list].has_key?(index)
      cached = node_cache[:output_item_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_output_item
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_output_item
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(OutputItemList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Output_Item_List,input, i0...index, s0)
      r0.extend(OutputItemList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:output_item_list][start_index] = r0

    r0
  end

  module ParameterStmt0
    def label
      elements[0]
    end

    def t_parameter
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def named_constant_def_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_parameter_stmt
    start_index = index
    if node_cache[:parameter_stmt].has_key?(index)
      cached = node_cache[:parameter_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_parameter
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_named_constant_def_list
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r7 = _nt_t_newline
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtC,input, i0...index, s0)
      r0.extend(ParameterStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parameter_stmt][start_index] = r0

    r0
  end

  def _nt_parent_string
    start_index = index
    if node_cache[:parent_string].has_key?(index)
      cached = node_cache[:parent_string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_array_element
    if r1
      r0 = r1
    else
      r2 = _nt_scalar_structure_component
      if r2
        r0 = r2
      else
        r3 = _nt_scalar_variable_name
        if r3
          r0 = r3
        else
          r4 = _nt_scalar_constant
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:parent_string][start_index] = r0

    r0
  end

  module ParenthesizedAllocateShapeSpecList0
    def t_paren_l
      elements[0]
    end

    def allocate_shape_spec_list
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_parenthesized_allocate_shape_spec_list
    start_index = index
    if node_cache[:parenthesized_allocate_shape_spec_list].has_key?(index)
      cached = node_cache[:parenthesized_allocate_shape_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_allocate_shape_spec_list
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(ParenthesizedAllocateShapeSpecList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parenthesized_allocate_shape_spec_list][start_index] = r0

    r0
  end

  module ParenthesizedArgs0
    def t_paren_l
      elements[0]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_parenthesized_args
    start_index = index
    if node_cache[:parenthesized_args].has_key?(index)
      cached = node_cache[:parenthesized_args][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r3 = _nt_actual_arg_spec_list
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_t_paren_r
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(ParenthesizedArgs0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parenthesized_args][start_index] = r0

    r0
  end

  module ParenthesizedComponentArraySpec0
    def t_paren_l
      elements[0]
    end

    def component_array_spec
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_parenthesized_component_array_spec
    start_index = index
    if node_cache[:parenthesized_component_array_spec].has_key?(index)
      cached = node_cache[:parenthesized_component_array_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_component_array_spec
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(ParenthesizedComponentArraySpec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parenthesized_component_array_spec][start_index] = r0

    r0
  end

  module ParenthesizedDeferredShapeSpecList0
    def t_paren_l
      elements[0]
    end

    def deferred_shape_spec_list
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_parenthesized_deferred_shape_spec_list
    start_index = index
    if node_cache[:parenthesized_deferred_shape_spec_list].has_key?(index)
      cached = node_cache[:parenthesized_deferred_shape_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_deferred_shape_spec_list
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(Parenthesized_Deferred_Shape_Spec_List,input, i0...index, s0)
      r0.extend(ParenthesizedDeferredShapeSpecList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parenthesized_deferred_shape_spec_list][start_index] = r0

    r0
  end

  module ParenthesizedExplicitShapeSpecList0
    def t_paren_l
      elements[0]
    end

    def explicit_shape_spec_list
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_parenthesized_explicit_shape_spec_list
    start_index = index
    if node_cache[:parenthesized_explicit_shape_spec_list].has_key?(index)
      cached = node_cache[:parenthesized_explicit_shape_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_explicit_shape_spec_list
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(Parenthesized_Explicit_Shape_Spec_List,input, i0...index, s0)
      r0.extend(ParenthesizedExplicitShapeSpecList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parenthesized_explicit_shape_spec_list][start_index] = r0

    r0
  end

  module ParenthesizedExpr0
    def t_paren_l
      elements[0]
    end

    def expr
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_parenthesized_expr
    start_index = index
    if node_cache[:parenthesized_expr].has_key?(index)
      cached = node_cache[:parenthesized_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_expr
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(ParenthesizedExpr0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parenthesized_expr][start_index] = r0

    r0
  end

  module ParenthesizedSectionSubscriptList0
    def t_paren_l
      elements[0]
    end

    def section_subscript_list
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_parenthesized_section_subscript_list
    start_index = index
    if node_cache[:parenthesized_section_subscript_list].has_key?(index)
      cached = node_cache[:parenthesized_section_subscript_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_section_subscript_list
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(Parenthesized_Section_Subscript_List,input, i0...index, s0)
      r0.extend(ParenthesizedSectionSubscriptList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:parenthesized_section_subscript_list][start_index] = r0

    r0
  end

  def _nt_part_name
    start_index = index
    if node_cache[:part_name].has_key?(index)
      cached = node_cache[:part_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:part_name][start_index] = r0

    r0
  end

  module PartRef0
    def part_name
      elements[0]
    end

  end

  def _nt_part_ref
    start_index = index
    if node_cache[:part_ref].has_key?(index)
      cached = node_cache[:part_ref][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_part_name
    s0 << r1
    if r1
      r3 = _nt_parenthesized_section_subscript_list
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Part_Ref,input, i0...index, s0)
      r0.extend(PartRef0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:part_ref][start_index] = r0

    r0
  end

  module PauseStmt0
    def label
      elements[0]
    end

    def t_pause
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_pause_stmt
    start_index = index
    if node_cache[:pause_stmt].has_key?(index)
      cached = node_cache[:pause_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_pause
      s0 << r3
      if r3
        r5 = _nt_stop_code
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(PauseStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:pause_stmt][start_index] = r0

    r0
  end

  module PointerAssignmentStmt0
    def label
      elements[0]
    end

    def pointer_object
      elements[1]
    end

    def t_point
      elements[2]
    end

    def target
      elements[3]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_pointer_assignment_stmt
    start_index = index
    if node_cache[:pointer_assignment_stmt].has_key?(index)
      cached = node_cache[:pointer_assignment_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_pointer_object
      s0 << r3
      if r3
        r4 = _nt_t_point
        s0 << r4
        if r4
          r5 = _nt_target
          s0 << r5
          if r5
            r6 = _nt_t_newline
            s0 << r6
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtC,input, i0...index, s0)
      r0.extend(PointerAssignmentStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:pointer_assignment_stmt][start_index] = r0

    r0
  end

  def _nt_pointer_object
    start_index = index
    if node_cache[:pointer_object].has_key?(index)
      cached = node_cache[:pointer_object][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_structure_component
    if r1
      r0 = r1
    else
      r2 = _nt_variable_name
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:pointer_object][start_index] = r0

    r0
  end

  module PointerObjectList0
    def t_comma
      elements[0]
    end

    def pointer_object
      elements[1]
    end
  end

  module PointerObjectList1
    def pointer_object
      elements[0]
    end

  end

  def _nt_pointer_object_list
    start_index = index
    if node_cache[:pointer_object_list].has_key?(index)
      cached = node_cache[:pointer_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_pointer_object
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_pointer_object
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(PointerObjectList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Pointer_Object_List,input, i0...index, s0)
      r0.extend(PointerObjectList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:pointer_object_list][start_index] = r0

    r0
  end

  module PointerStmt0
    def label
      elements[0]
    end

    def t_pointer
      elements[1]
    end

    def object_names_and_spec_lists
      elements[3]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_pointer_stmt
    start_index = index
    if node_cache[:pointer_stmt].has_key?(index)
      cached = node_cache[:pointer_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_pointer
      s0 << r3
      if r3
        r5 = _nt_double_colon
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_object_names_and_spec_lists
          s0 << r6
          if r6
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Pointer_Stmt,input, i0...index, s0)
      r0.extend(PointerStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:pointer_stmt][start_index] = r0

    r0
  end

  module PositionSpec0
    def external_file_unit
      elements[0]
    end

  end

  module PositionSpec1
    def t_unit
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def external_file_unit
      elements[2]
    end
  end

  module PositionSpec2
    def t_iostat
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def scalar_default_int_variable
      elements[2]
    end
  end

  module PositionSpec3
    def t_err
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def label
      elements[2]
    end
  end

  def _nt_position_spec
    start_index = index
    if node_cache[:position_spec].has_key?(index)
      cached = node_cache[:position_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_external_file_unit
    s1 << r2
    if r2
      i3 = index
      r4 = _nt_t_comma
      if r4
        @index = i3
        r3 = instantiate_node(SyntaxNode,input, index...index)
      else
        r3 = nil
      end
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(PositionSpec0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_t_unit
      s5 << r6
      if r6
        r7 = _nt_t_equal
        s5 << r7
        if r7
          r8 = _nt_external_file_unit
          s5 << r8
        end
      end
      if s5.last
        r5 = instantiate_node(T,input, i5...index, s5)
        r5.extend(PositionSpec1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        i9, s9 = index, []
        r10 = _nt_t_iostat
        s9 << r10
        if r10
          r11 = _nt_t_equal
          s9 << r11
          if r11
            r12 = _nt_scalar_default_int_variable
            s9 << r12
          end
        end
        if s9.last
          r9 = instantiate_node(T,input, i9...index, s9)
          r9.extend(PositionSpec2)
        else
          @index = i9
          r9 = nil
        end
        if r9
          r0 = r9
        else
          i13, s13 = index, []
          r14 = _nt_t_err
          s13 << r14
          if r14
            r15 = _nt_t_equal
            s13 << r15
            if r15
              r16 = _nt_label
              s13 << r16
            end
          end
          if s13.last
            r13 = instantiate_node(SyntaxNode,input, i13...index, s13)
            r13.extend(PositionSpec3)
          else
            @index = i13
            r13 = nil
          end
          if r13
            r0 = r13
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:position_spec][start_index] = r0

    r0
  end

  module PositionSpecList0
    def t_comma
      elements[0]
    end

    def position_spec
      elements[1]
    end
  end

  module PositionSpecList1
    def position_spec
      elements[0]
    end

  end

  def _nt_position_spec_list
    start_index = index
    if node_cache[:position_spec_list].has_key?(index)
      cached = node_cache[:position_spec_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_position_spec
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_position_spec
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(PositionSpecList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Position_Spec_List,input, i0...index, s0)
      r0.extend(PositionSpecList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:position_spec_list][start_index] = r0

    r0
  end

  def _nt_power_op
    start_index = index
    if node_cache[:power_op].has_key?(index)
      cached = node_cache[:power_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("**", false, index)
      r0 = instantiate_node(Power_Op,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("**")
      r0 = nil
    end

    node_cache[:power_op][start_index] = r0

    r0
  end

  def _nt_prefix_function
    start_index = index
    if node_cache[:prefix_function].has_key?(index)
      cached = node_cache[:prefix_function][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_prefix_function_option
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(Prefix_Function,input, i0...index, s0)
    end

    node_cache[:prefix_function][start_index] = r0

    r0
  end

  def _nt_prefix_function_option
    start_index = index
    if node_cache[:prefix_function_option].has_key?(index)
      cached = node_cache[:prefix_function_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_type_spec
    if r1
      r0 = r1
    else
      r2 = _nt_t_elemental
      if r2
        r0 = r2
      else
        r3 = _nt_t_pure
        if r3
          r0 = r3
        else
          r4 = _nt_t_recursive
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:prefix_function_option][start_index] = r0

    r0
  end

  def _nt_prefix_subroutine
    start_index = index
    if node_cache[:prefix_subroutine].has_key?(index)
      cached = node_cache[:prefix_subroutine][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_prefix_subroutine_option
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(Prefix_Subroutine,input, i0...index, s0)
    end

    node_cache[:prefix_subroutine][start_index] = r0

    r0
  end

  def _nt_prefix_subroutine_option
    start_index = index
    if node_cache[:prefix_subroutine_option].has_key?(index)
      cached = node_cache[:prefix_subroutine_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_elemental
    if r1
      r0 = r1
    else
      r2 = _nt_t_pure
      if r2
        r0 = r2
      else
        r3 = _nt_t_recursive
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:prefix_subroutine_option][start_index] = r0

    r0
  end

  def _nt_primary
    start_index = index
    if node_cache[:primary].has_key?(index)
      cached = node_cache[:primary][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_function_reference
    if r1
      r0 = r1
    else
      r2 = _nt_variable
      if r2
        r0 = r2
      else
        r3 = _nt_constant
        if r3
          r0 = r3
        else
          r4 = _nt_constant_subobject
          if r4
            r0 = r4
          else
            r5 = _nt_array_constructor
            if r5
              r0 = r5
            else
              r6 = _nt_structure_constructor
              if r6
                r0 = r6
              else
                r7 = _nt_parenthesized_expr
                if r7
                  r0 = r7
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end
      end
    end

    node_cache[:primary][start_index] = r0

    r0
  end

  module PrintStmt0
    def label
      elements[0]
    end

    def t_print
      elements[1]
    end

    def format
      elements[2]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_print_stmt
    start_index = index
    if node_cache[:print_stmt].has_key?(index)
      cached = node_cache[:print_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_print
      s0 << r3
      if r3
        r4 = _nt_format
        s0 << r4
        if r4
          r6 = _nt_print_stmt_output_item_list
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r7 = _nt_t_newline
            s0 << r7
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Print_Stmt,input, i0...index, s0)
      r0.extend(PrintStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:print_stmt][start_index] = r0

    r0
  end

  module PrintStmtOutputItemList0
    def t_comma
      elements[0]
    end

    def output_item_list
      elements[1]
    end
  end

  def _nt_print_stmt_output_item_list
    start_index = index
    if node_cache[:print_stmt_output_item_list].has_key?(index)
      cached = node_cache[:print_stmt_output_item_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_output_item_list
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Print_Stmt_Output_Item_List,input, i0...index, s0)
      r0.extend(PrintStmtOutputItemList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:print_stmt_output_item_list][start_index] = r0

    r0
  end

  module PrivateSequenceStmt0
    def label
      elements[0]
    end

    def t_newline
      elements[2]
    end
  end

  def _nt_private_sequence_stmt
    start_index = index
    if node_cache[:private_sequence_stmt].has_key?(index)
      cached = node_cache[:private_sequence_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      i3 = index
      r4 = _nt_t_private
      if r4
        r3 = r4
      else
        r5 = _nt_t_sequence
        if r5
          r3 = r5
        else
          @index = i3
          r3 = nil
        end
      end
      s0 << r3
      if r3
        r6 = _nt_t_newline
        s0 << r6
      end
    end
    if s0.last
      r0 = instantiate_node(StmtC,input, i0...index, s0)
      r0.extend(PrivateSequenceStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:private_sequence_stmt][start_index] = r0

    r0
  end

  def _nt_private_sequence_stmts
    start_index = index
    if node_cache[:private_sequence_stmts].has_key?(index)
      cached = node_cache[:private_sequence_stmts][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_private_sequence_stmt
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:private_sequence_stmts][start_index] = r0

    r0
  end

  def _nt_procedure_name
    start_index = index
    if node_cache[:procedure_name].has_key?(index)
      cached = node_cache[:procedure_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:procedure_name][start_index] = r0

    r0
  end

  module ProcedureNameList0
    def t_comma
      elements[0]
    end

    def procedure_name
      elements[1]
    end
  end

  module ProcedureNameList1
    def procedure_name
      elements[0]
    end

  end

  def _nt_procedure_name_list
    start_index = index
    if node_cache[:procedure_name_list].has_key?(index)
      cached = node_cache[:procedure_name_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_procedure_name
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_procedure_name
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(ProcedureNameList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Procedure_Name_List,input, i0...index, s0)
      r0.extend(ProcedureNameList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:procedure_name_list][start_index] = r0

    r0
  end

  def _nt_program_name
    start_index = index
    if node_cache[:program_name].has_key?(index)
      cached = node_cache[:program_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:program_name][start_index] = r0

    r0
  end

  module ProgramStmt0
    def label
      elements[0]
    end

    def t_program
      elements[1]
    end

    def program_name
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_program_stmt
    start_index = index
    if node_cache[:program_stmt].has_key?(index)
      cached = node_cache[:program_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_program
      s0 << r3
      if r3
        r4 = _nt_program_name
        s0 << r4
        if r4
          r5 = _nt_t_newline
          s0 << r5
          if r5
            i6 = index
            r7 = lambda { |e| sp_program_stmt }.call(s0)
            if r7
              @index = i6
              r6 = instantiate_node(SyntaxNode,input, index...index)
            else
              r6 = nil
            end
            s0 << r6
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Program_Stmt,input, i0...index, s0)
      r0.extend(ProgramStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:program_stmt][start_index] = r0

    r0
  end

  module ProgramUnit0
    def module
      elements[0]
    end

  end

  def _nt_program_unit
    start_index = index
    if node_cache[:program_unit].has_key?(index)
      cached = node_cache[:program_unit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_external_subprogram
    if r1
      r0 = r1
    else
      i2, s2 = index, []
      r3 = _nt_module
      s2 << r3
      if r3
        i4 = index
        r5 = lambda { |e| sp_module(e[0]) }.call(s2)
        if r5
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        else
          r4 = nil
        end
        s2 << r4
      end
      if s2.last
        r2 = instantiate_node(E,input, i2...index, s2)
        r2.extend(ProgramUnit0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r0 = r2
      else
        r6 = _nt_block_data
        if r6
          r0 = r6
        else
          r7 = _nt_main_program
          if r7
            r0 = r7
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:program_unit][start_index] = r0

    r0
  end

  def _nt_program_units
    start_index = index
    if node_cache[:program_units].has_key?(index)
      cached = node_cache[:program_units][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_program_unit
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(Program_Units,input, i0...index, s0)
    end

    node_cache[:program_units][start_index] = r0

    r0
  end

  module ReadStmt0
    def label
      elements[0]
    end

    def t_read
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def io_control_spec_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[6]
    end
  end

  module ReadStmt1
    def label
      elements[0]
    end

    def t_read
      elements[1]
    end

    def format
      elements[2]
    end

    def t_newline
      elements[4]
    end
  end

  def _nt_read_stmt
    start_index = index
    if node_cache[:read_stmt].has_key?(index)
      cached = node_cache[:read_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_label
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r4 = _nt_t_read
      s1 << r4
      if r4
        r5 = _nt_t_paren_l
        s1 << r5
        if r5
          r6 = _nt_io_control_spec_list
          s1 << r6
          if r6
            r7 = _nt_t_paren_r
            s1 << r7
            if r7
              r9 = _nt_input_item_list
              if r9
                r8 = r9
              else
                r8 = instantiate_node(SyntaxNode,input, index...index)
              end
              s1 << r8
              if r8
                r10 = _nt_t_newline
                s1 << r10
              end
            end
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(Read_Stmt_1,input, i1...index, s1)
      r1.extend(ReadStmt0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i11, s11 = index, []
      r13 = _nt_label
      if r13
        r12 = r13
      else
        r12 = instantiate_node(SyntaxNode,input, index...index)
      end
      s11 << r12
      if r12
        r14 = _nt_t_read
        s11 << r14
        if r14
          r15 = _nt_format
          s11 << r15
          if r15
            r17 = _nt_read_stmt_input_item_list_option
            if r17
              r16 = r17
            else
              r16 = instantiate_node(SyntaxNode,input, index...index)
            end
            s11 << r16
            if r16
              r18 = _nt_t_newline
              s11 << r18
            end
          end
        end
      end
      if s11.last
        r11 = instantiate_node(Read_Stmt_2,input, i11...index, s11)
        r11.extend(ReadStmt1)
      else
        @index = i11
        r11 = nil
      end
      if r11
        r0 = r11
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:read_stmt][start_index] = r0

    r0
  end

  module ReadStmtInputItemListOption0
    def t_comma
      elements[0]
    end

    def input_item_list
      elements[1]
    end
  end

  def _nt_read_stmt_input_item_list_option
    start_index = index
    if node_cache[:read_stmt_input_item_list_option].has_key?(index)
      cached = node_cache[:read_stmt_input_item_list_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_input_item_list
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(ReadStmtInputItemListOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:read_stmt_input_item_list_option][start_index] = r0

    r0
  end

  module RealLiteralConstant0
    def exponent_letter
      elements[0]
    end

    def exponent
      elements[1]
    end
  end

  module RealLiteralConstant1
    def t_underscore
      elements[0]
    end

    def kind_param
      elements[1]
    end
  end

  module RealLiteralConstant2
    def significand
      elements[0]
    end

  end

  module RealLiteralConstant3
    def t_underscore
      elements[0]
    end

    def kind_param
      elements[1]
    end
  end

  module RealLiteralConstant4
    def digit_string
      elements[0]
    end

    def exponent_letter
      elements[1]
    end

    def exponent
      elements[2]
    end

  end

  def _nt_real_literal_constant
    start_index = index
    if node_cache[:real_literal_constant].has_key?(index)
      cached = node_cache[:real_literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_significand
    s1 << r2
    if r2
      i4, s4 = index, []
      r5 = _nt_exponent_letter
      s4 << r5
      if r5
        r6 = _nt_exponent
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        r4.extend(RealLiteralConstant0)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r3
      if r3
        i8, s8 = index, []
        r9 = _nt_t_underscore
        s8 << r9
        if r9
          r10 = _nt_kind_param
          s8 << r10
        end
        if s8.last
          r8 = instantiate_node(SyntaxNode,input, i8...index, s8)
          r8.extend(RealLiteralConstant1)
        else
          @index = i8
          r8 = nil
        end
        if r8
          r7 = r8
        else
          r7 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r7
      end
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(RealLiteralConstant2)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i11, s11 = index, []
      r12 = _nt_digit_string
      s11 << r12
      if r12
        r13 = _nt_exponent_letter
        s11 << r13
        if r13
          r14 = _nt_exponent
          s11 << r14
          if r14
            i16, s16 = index, []
            r17 = _nt_t_underscore
            s16 << r17
            if r17
              r18 = _nt_kind_param
              s16 << r18
            end
            if s16.last
              r16 = instantiate_node(SyntaxNode,input, i16...index, s16)
              r16.extend(RealLiteralConstant3)
            else
              @index = i16
              r16 = nil
            end
            if r16
              r15 = r16
            else
              r15 = instantiate_node(SyntaxNode,input, index...index)
            end
            s11 << r15
          end
        end
      end
      if s11.last
        r11 = instantiate_node(T,input, i11...index, s11)
        r11.extend(RealLiteralConstant4)
      else
        @index = i11
        r11 = nil
      end
      if r11
        r0 = r11
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:real_literal_constant][start_index] = r0

    r0
  end

  def _nt_real_part
    start_index = index
    if node_cache[:real_part].has_key?(index)
      cached = node_cache[:real_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_signed_real_literal_constant
    if r1
      r0 = r1
    else
      r2 = _nt_signed_int_literal_constant
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:real_part][start_index] = r0

    r0
  end

  def _nt_rel_op_eq
    start_index = index
    if node_cache[:rel_op_eq].has_key?(index)
      cached = node_cache[:rel_op_eq][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(".eq.", false, index)
      r1 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure(".eq.")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?("==", false, index)
        r2 = instantiate_node(T,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("==")
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:rel_op_eq][start_index] = r0

    r0
  end

  def _nt_rel_op_ge
    start_index = index
    if node_cache[:rel_op_ge].has_key?(index)
      cached = node_cache[:rel_op_ge][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(".ge.", false, index)
      r1 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure(".ge.")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?(">=", false, index)
        r2 = instantiate_node(T,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure(">=")
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:rel_op_ge][start_index] = r0

    r0
  end

  def _nt_rel_op_gt
    start_index = index
    if node_cache[:rel_op_gt].has_key?(index)
      cached = node_cache[:rel_op_gt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(".gt.", false, index)
      r1 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure(".gt.")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r2 = _nt_t_gt
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:rel_op_gt][start_index] = r0

    r0
  end

  def _nt_rel_op_le
    start_index = index
    if node_cache[:rel_op_le].has_key?(index)
      cached = node_cache[:rel_op_le][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(".le.", false, index)
      r1 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure(".le.")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?("<=", false, index)
        r2 = instantiate_node(T,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("<=")
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:rel_op_le][start_index] = r0

    r0
  end

  def _nt_rel_op_lt
    start_index = index
    if node_cache[:rel_op_lt].has_key?(index)
      cached = node_cache[:rel_op_lt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(".lt.", false, index)
      r1 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure(".lt.")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      r2 = _nt_t_lt
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:rel_op_lt][start_index] = r0

    r0
  end

  def _nt_rel_op_ne
    start_index = index
    if node_cache[:rel_op_ne].has_key?(index)
      cached = node_cache[:rel_op_ne][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?(".ne.", false, index)
      r1 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure(".ne.")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?("/=", false, index)
        r2 = instantiate_node(T,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("/=")
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:rel_op_ne][start_index] = r0

    r0
  end

  def _nt_rel_op
    start_index = index
    if node_cache[:rel_op].has_key?(index)
      cached = node_cache[:rel_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_rel_op_eq
    if r1
      r0 = r1
    else
      r2 = _nt_rel_op_ne
      if r2
        r0 = r2
      else
        r3 = _nt_rel_op_le
        if r3
          r0 = r3
        else
          r4 = _nt_rel_op_lt
          if r4
            r0 = r4
          else
            r5 = _nt_rel_op_ge
            if r5
              r0 = r5
            else
              r6 = _nt_rel_op_gt
              if r6
                r0 = r6
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end
    end

    node_cache[:rel_op][start_index] = r0

    r0
  end

  module Rename0
    def local_name
      elements[0]
    end

    def t_point
      elements[1]
    end

    def use_name
      elements[2]
    end
  end

  def _nt_rename
    start_index = index
    if node_cache[:rename].has_key?(index)
      cached = node_cache[:rename][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_local_name
    s0 << r1
    if r1
      r2 = _nt_t_point
      s0 << r2
      if r2
        r3 = _nt_use_name
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(Rename,input, i0...index, s0)
      r0.extend(Rename0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:rename][start_index] = r0

    r0
  end

  module RenameList0
    def rename
      elements[0]
    end

  end

  def _nt_rename_list
    start_index = index
    if node_cache[:rename_list].has_key?(index)
      cached = node_cache[:rename_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_rename
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_rename_list_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Rename_List,input, i0...index, s0)
      r0.extend(RenameList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:rename_list][start_index] = r0

    r0
  end

  module RenameListPair0
    def t_comma
      elements[0]
    end

    def rename
      elements[1]
    end
  end

  def _nt_rename_list_pair
    start_index = index
    if node_cache[:rename_list_pair].has_key?(index)
      cached = node_cache[:rename_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_rename
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Rename_List_Pair,input, i0...index, s0)
      r0.extend(RenameListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:rename_list_pair][start_index] = r0

    r0
  end

  module RenameListOption0
    def t_comma
      elements[0]
    end

    def rename_list
      elements[1]
    end
  end

  def _nt_rename_list_option
    start_index = index
    if node_cache[:rename_list_option].has_key?(index)
      cached = node_cache[:rename_list_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_rename_list
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Rename_List_Option,input, i0...index, s0)
      r0.extend(RenameListOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:rename_list_option][start_index] = r0

    r0
  end

  def _nt_rep_char
    start_index = index
    if node_cache[:rep_char].has_key?(index)
      cached = node_cache[:rep_char][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_character
    if r1
      r0 = r1
    else
      if has_terminal?('\G[\\[\\]\\~\\`\\@\\#\\^\\|\\{\\}]', true, index)
        r2 = true
        @index += 1
      else
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:rep_char][start_index] = r0

    r0
  end

  def _nt_result_name
    start_index = index
    if node_cache[:result_name].has_key?(index)
      cached = node_cache[:result_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:result_name][start_index] = r0

    r0
  end

  module ResultOption0
    def t_result
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def result_name
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_result_option
    start_index = index
    if node_cache[:result_option].has_key?(index)
      cached = node_cache[:result_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_result
    s0 << r1
    if r1
      r2 = _nt_t_paren_l
      s0 << r2
      if r2
        r3 = _nt_result_name
        s0 << r3
        if r3
          r4 = _nt_t_paren_r
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(ResultOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:result_option][start_index] = r0

    r0
  end

  module ReturnStmt0
    def label
      elements[0]
    end

    def t_return
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_return_stmt
    start_index = index
    if node_cache[:return_stmt].has_key?(index)
      cached = node_cache[:return_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_return
      s0 << r3
      if r3
        r5 = _nt_scalar_int_expr
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(J,input, i0...index, s0)
      r0.extend(ReturnStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:return_stmt][start_index] = r0

    r0
  end

  module RewindStmt0
    def label
      elements[0]
    end

    def t_rewind
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def position_spec_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  module RewindStmt1
    def label
      elements[0]
    end

    def t_rewind
      elements[1]
    end

    def external_file_unit
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_rewind_stmt
    start_index = index
    if node_cache[:rewind_stmt].has_key?(index)
      cached = node_cache[:rewind_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_label
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r4 = _nt_t_rewind
      s1 << r4
      if r4
        r5 = _nt_t_paren_l
        s1 << r5
        if r5
          r6 = _nt_position_spec_list
          s1 << r6
          if r6
            r7 = _nt_t_paren_r
            s1 << r7
            if r7
              r8 = _nt_t_newline
              s1 << r8
            end
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(StmtC,input, i1...index, s1)
      r1.extend(RewindStmt0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i9, s9 = index, []
      r11 = _nt_label
      if r11
        r10 = r11
      else
        r10 = instantiate_node(SyntaxNode,input, index...index)
      end
      s9 << r10
      if r10
        r12 = _nt_t_rewind
        s9 << r12
        if r12
          r13 = _nt_external_file_unit
          s9 << r13
          if r13
            r14 = _nt_t_newline
            s9 << r14
          end
        end
      end
      if s9.last
        r9 = instantiate_node(StmtJ,input, i9...index, s9)
        r9.extend(RewindStmt1)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r0 = r9
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:rewind_stmt][start_index] = r0

    r0
  end

  module SaveStmt0
    def label
      elements[0]
    end

    def t_save
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_save_stmt
    start_index = index
    if node_cache[:save_stmt].has_key?(index)
      cached = node_cache[:save_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_save
      s0 << r3
      if r3
        r5 = _nt_save_stmt_entity_list
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Save_Stmt,input, i0...index, s0)
      r0.extend(SaveStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:save_stmt][start_index] = r0

    r0
  end

  module SaveStmtEntityList0
    def saved_entity_list
      elements[1]
    end
  end

  def _nt_save_stmt_entity_list
    start_index = index
    if node_cache[:save_stmt_entity_list].has_key?(index)
      cached = node_cache[:save_stmt_entity_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_double_colon
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_saved_entity_list
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(Save_Stmt_Entity_List,input, i0...index, s0)
      r0.extend(SaveStmtEntityList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:save_stmt_entity_list][start_index] = r0

    r0
  end

  module SavedEntity0
    def t_slash1
      elements[0]
    end

    def common_block_name
      elements[1]
    end

    def t_slash2
      elements[2]
    end
  end

  def _nt_saved_entity
    start_index = index
    if node_cache[:saved_entity].has_key?(index)
      cached = node_cache[:saved_entity][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_object_name
    if r1
      r0 = r1
    else
      i2, s2 = index, []
      r3 = _nt_t_slash
      s2 << r3
      if r3
        r4 = _nt_common_block_name
        s2 << r4
        if r4
          r5 = _nt_t_slash
          s2 << r5
        end
      end
      if s2.last
        r2 = instantiate_node(E,input, i2...index, s2)
        r2.extend(SavedEntity0)
      else
        @index = i2
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:saved_entity][start_index] = r0

    r0
  end

  module SavedEntityList0
    def t_comma
      elements[0]
    end

    def saved_entity
      elements[1]
    end
  end

  module SavedEntityList1
    def saved_entity
      elements[0]
    end

  end

  def _nt_saved_entity_list
    start_index = index
    if node_cache[:saved_entity_list].has_key?(index)
      cached = node_cache[:saved_entity_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_saved_entity
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_saved_entity
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(SavedEntityList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Saved_Entity_List,input, i0...index, s0)
      r0.extend(SavedEntityList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:saved_entity_list][start_index] = r0

    r0
  end

  def _nt_scalar_char_constant
    start_index = index
    if node_cache[:scalar_char_constant].has_key?(index)
      cached = node_cache[:scalar_char_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_char_literal_constant
    if r1
      r0 = r1
    else
      r2 = _nt_named_constant
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:scalar_char_constant][start_index] = r0

    r0
  end

  def _nt_scalar_char_expr
    start_index = index
    if node_cache[:scalar_char_expr].has_key?(index)
      cached = node_cache[:scalar_char_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_char_expr

    node_cache[:scalar_char_expr][start_index] = r0

    r0
  end

  def _nt_scalar_char_initialization_expr
    start_index = index
    if node_cache[:scalar_char_initialization_expr].has_key?(index)
      cached = node_cache[:scalar_char_initialization_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_initialization_expr

    node_cache[:scalar_char_initialization_expr][start_index] = r0

    r0
  end

  def _nt_scalar_constant
    start_index = index
    if node_cache[:scalar_constant].has_key?(index)
      cached = node_cache[:scalar_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_literal_constant
    if r1
      r0 = r1
    else
      r2 = _nt_named_constant
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:scalar_constant][start_index] = r0

    r0
  end

  def _nt_scalar_default_char_expr
    start_index = index
    if node_cache[:scalar_default_char_expr].has_key?(index)
      cached = node_cache[:scalar_default_char_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_default_char_expr

    node_cache[:scalar_default_char_expr][start_index] = r0

    r0
  end

  def _nt_scalar_default_char_variable
    start_index = index
    if node_cache[:scalar_default_char_variable].has_key?(index)
      cached = node_cache[:scalar_default_char_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_default_char_variable

    node_cache[:scalar_default_char_variable][start_index] = r0

    r0
  end

  def _nt_scalar_default_int_variable
    start_index = index
    if node_cache[:scalar_default_int_variable].has_key?(index)
      cached = node_cache[:scalar_default_int_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable

    node_cache[:scalar_default_int_variable][start_index] = r0

    r0
  end

  def _nt_scalar_default_logical_variable
    start_index = index
    if node_cache[:scalar_default_logical_variable].has_key?(index)
      cached = node_cache[:scalar_default_logical_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_default_logical_variable

    node_cache[:scalar_default_logical_variable][start_index] = r0

    r0
  end

  def _nt_scalar_expr
    start_index = index
    if node_cache[:scalar_expr].has_key?(index)
      cached = node_cache[:scalar_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_expr

    node_cache[:scalar_expr][start_index] = r0

    r0
  end

  def _nt_scalar_int_constant
    start_index = index
    if node_cache[:scalar_int_constant].has_key?(index)
      cached = node_cache[:scalar_int_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_scalar_int_literal_constant
    if r1
      r0 = r1
    else
      r2 = _nt_scalar_int_constant_name
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:scalar_int_constant][start_index] = r0

    r0
  end

  def _nt_scalar_int_constant_name
    start_index = index
    if node_cache[:scalar_int_constant_name].has_key?(index)
      cached = node_cache[:scalar_int_constant_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_named_constant

    node_cache[:scalar_int_constant_name][start_index] = r0

    r0
  end

  def _nt_scalar_int_expr
    start_index = index
    if node_cache[:scalar_int_expr].has_key?(index)
      cached = node_cache[:scalar_int_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_expr

    node_cache[:scalar_int_expr][start_index] = r0

    r0
  end

  def _nt_scalar_int_initialization_expr
    start_index = index
    if node_cache[:scalar_int_initialization_expr].has_key?(index)
      cached = node_cache[:scalar_int_initialization_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_initialization_expr

    node_cache[:scalar_int_initialization_expr][start_index] = r0

    r0
  end

  def _nt_scalar_int_literal_constant
    start_index = index
    if node_cache[:scalar_int_literal_constant].has_key?(index)
      cached = node_cache[:scalar_int_literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_signed_int_literal_constant

    node_cache[:scalar_int_literal_constant][start_index] = r0

    r0
  end

  def _nt_scalar_int_variable
    start_index = index
    if node_cache[:scalar_int_variable].has_key?(index)
      cached = node_cache[:scalar_int_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable

    node_cache[:scalar_int_variable][start_index] = r0

    r0
  end

  def _nt_scalar_logical_expr
    start_index = index
    if node_cache[:scalar_logical_expr].has_key?(index)
      cached = node_cache[:scalar_logical_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_logical_expr

    node_cache[:scalar_logical_expr][start_index] = r0

    r0
  end

  def _nt_scalar_logical_initialization_expr
    start_index = index
    if node_cache[:scalar_logical_initialization_expr].has_key?(index)
      cached = node_cache[:scalar_logical_initialization_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_initialization_expr

    node_cache[:scalar_logical_initialization_expr][start_index] = r0

    r0
  end

  def _nt_scalar_numeric_expr
    start_index = index
    if node_cache[:scalar_numeric_expr].has_key?(index)
      cached = node_cache[:scalar_numeric_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_numeric_expr

    node_cache[:scalar_numeric_expr][start_index] = r0

    r0
  end

  def _nt_scalar_structure_component
    start_index = index
    if node_cache[:scalar_structure_component].has_key?(index)
      cached = node_cache[:scalar_structure_component][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_structure_component

    node_cache[:scalar_structure_component][start_index] = r0

    r0
  end

  def _nt_scalar_variable
    start_index = index
    if node_cache[:scalar_variable].has_key?(index)
      cached = node_cache[:scalar_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_variable_name

    node_cache[:scalar_variable][start_index] = r0

    r0
  end

  def _nt_scalar_variable_name
    start_index = index
    if node_cache[:scalar_variable_name].has_key?(index)
      cached = node_cache[:scalar_variable_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_variable_name

    node_cache[:scalar_variable_name][start_index] = r0

    r0
  end

  def _nt_section_subscript
    start_index = index
    if node_cache[:section_subscript].has_key?(index)
      cached = node_cache[:section_subscript][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_subscript_triplet
    if r1
      r0 = r1
    else
      r2 = _nt_vector_subscript
      if r2
        r0 = r2
      else
        r3 = _nt_subscript
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:section_subscript][start_index] = r0

    r0
  end

  module SectionSubscriptList0
    def t_comma
      elements[0]
    end

    def section_subscript
      elements[1]
    end
  end

  module SectionSubscriptList1
    def section_subscript
      elements[0]
    end

  end

  def _nt_section_subscript_list
    start_index = index
    if node_cache[:section_subscript_list].has_key?(index)
      cached = node_cache[:section_subscript_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_section_subscript
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_section_subscript
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(SectionSubscriptList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Section_Subscript_List,input, i0...index, s0)
      r0.extend(SectionSubscriptList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:section_subscript_list][start_index] = r0

    r0
  end

  module SelectCaseStmt0
    def label
      elements[0]
    end

    def t_select
      elements[2]
    end

    def t_case
      elements[3]
    end

    def t_paren_l
      elements[4]
    end

    def case_expr
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def t_newline
      elements[7]
    end
  end

  def _nt_select_case_stmt
    start_index = index
    if node_cache[:select_case_stmt].has_key?(index)
      cached = node_cache[:select_case_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r4 = _nt_case_construct_name_pair
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r5 = _nt_t_select
        s0 << r5
        if r5
          r6 = _nt_t_case
          s0 << r6
          if r6
            r7 = _nt_t_paren_l
            s0 << r7
            if r7
              r8 = _nt_case_expr
              s0 << r8
              if r8
                r9 = _nt_t_paren_r
                s0 << r9
                if r9
                  r10 = _nt_t_newline
                  s0 << r10
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Select_Case_Stmt,input, i0...index, s0)
      r0.extend(SelectCaseStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:select_case_stmt][start_index] = r0

    r0
  end

  def _nt_shared_term_do_construct
    start_index = index
    if node_cache[:shared_term_do_construct].has_key?(index)
      cached = node_cache[:shared_term_do_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_outer_shared_do_construct
    if r1
      r0 = r1
    else
      r2 = _nt_inner_shared_do_construct
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:shared_term_do_construct][start_index] = r0

    r0
  end

  def _nt_sign
    start_index = index
    if node_cache[:sign].has_key?(index)
      cached = node_cache[:sign][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_t_plus
    if r1
      r0 = r1
    else
      r2 = _nt_t_minus
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sign][start_index] = r0

    r0
  end

  module SignedDigitString0
    def digit_string
      elements[1]
    end
  end

  def _nt_signed_digit_string
    start_index = index
    if node_cache[:signed_digit_string].has_key?(index)
      cached = node_cache[:signed_digit_string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_sign
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_digit_string
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(SignedDigitString0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:signed_digit_string][start_index] = r0

    r0
  end

  module SignedIntLiteralConstant0
    def int_literal_constant
      elements[1]
    end
  end

  def _nt_signed_int_literal_constant
    start_index = index
    if node_cache[:signed_int_literal_constant].has_key?(index)
      cached = node_cache[:signed_int_literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_sign
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_int_literal_constant
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(SignedIntLiteralConstant0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:signed_int_literal_constant][start_index] = r0

    r0
  end

  module SignedRealLiteralConstant0
    def real_literal_constant
      elements[1]
    end
  end

  def _nt_signed_real_literal_constant
    start_index = index
    if node_cache[:signed_real_literal_constant].has_key?(index)
      cached = node_cache[:signed_real_literal_constant][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_sign
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_real_literal_constant
      s0 << r3
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(SignedRealLiteralConstant0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:signed_real_literal_constant][start_index] = r0

    r0
  end

  module Significand0
    def digit_string
      elements[0]
    end

    def t_dot
      elements[1]
    end

  end

  module Significand1
    def t_dot
      elements[0]
    end

    def digit_string
      elements[1]
    end
  end

  def _nt_significand
    start_index = index
    if node_cache[:significand].has_key?(index)
      cached = node_cache[:significand][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_digit_string
    s1 << r2
    if r2
      r3 = _nt_t_dot
      s1 << r3
      if r3
        i4 = index
        r5 = _nt_significand_disallowed
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s1 << r4
        if r4
          r7 = _nt_digit_string
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r6
        end
      end
    end
    if s1.last
      r1 = instantiate_node(T,input, i1...index, s1)
      r1.extend(Significand0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i8, s8 = index, []
      r9 = _nt_t_dot
      s8 << r9
      if r9
        r10 = _nt_digit_string
        s8 << r10
      end
      if s8.last
        r8 = instantiate_node(T,input, i8...index, s8)
        r8.extend(Significand1)
      else
        @index = i8
        r8 = nil
      end
      if r8
        r0 = r8
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:significand][start_index] = r0

    r0
  end

  def _nt_significand_disallowed
    start_index = index
    if node_cache[:significand_disallowed].has_key?(index)
      cached = node_cache[:significand_disallowed][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?("and.", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("and.")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?("or.", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure("or.")
        r2 = nil
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:significand_disallowed][start_index] = r0

    r0
  end

  def _nt_special_character
    start_index = index
    if node_cache[:special_character].has_key?(index)
      cached = node_cache[:special_character][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[\\ \\=\\+\\-\\*\\/\\(\\)\\,\\.\\\'\\:\\!\\"\\%\\&\\;\\<\\>\\?\\$]', true, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:special_character][start_index] = r0

    r0
  end

  def _nt_specification_expr
    start_index = index
    if node_cache[:specification_expr].has_key?(index)
      cached = node_cache[:specification_expr][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_expr

    node_cache[:specification_expr][start_index] = r0

    r0
  end

  module SpecificationPart0
    def use_part
      elements[0]
    end

    def declaration_constructs
      elements[2]
    end
  end

  def _nt_specification_part
    start_index = index
    if node_cache[:specification_part].has_key?(index)
      cached = node_cache[:specification_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_use_part
    s0 << r1
    if r1
      r3 = _nt_implicit_part
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r4 = _nt_declaration_constructs
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(Specification_Part,input, i0...index, s0)
      r0.extend(SpecificationPart0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:specification_part][start_index] = r0

    r0
  end

  def _nt_specification_stmt
    start_index = index
    if node_cache[:specification_stmt].has_key?(index)
      cached = node_cache[:specification_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_access_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_allocatable_stmt
      if r2
        r0 = r2
      else
        r3 = _nt_common_stmt
        if r3
          r0 = r3
        else
          r4 = _nt_data_stmt
          if r4
            r0 = r4
          else
            r5 = _nt_dimension_stmt
            if r5
              r0 = r5
            else
              r6 = _nt_equivalence_stmt
              if r6
                r0 = r6
              else
                r7 = _nt_external_stmt
                if r7
                  r0 = r7
                else
                  r8 = _nt_intent_stmt
                  if r8
                    r0 = r8
                  else
                    r9 = _nt_intrinsic_stmt
                    if r9
                      r0 = r9
                    else
                      r10 = _nt_namelist_stmt
                      if r10
                        r0 = r10
                      else
                        r11 = _nt_optional_stmt
                        if r11
                          r0 = r11
                        else
                          r12 = _nt_pointer_stmt
                          if r12
                            r0 = r12
                          else
                            r13 = _nt_save_stmt
                            if r13
                              r0 = r13
                            else
                              r14 = _nt_target_stmt
                              if r14
                                r0 = r14
                              else
                                @index = i0
                                r0 = nil
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:specification_stmt][start_index] = r0

    r0
  end

  module StarInt0
    def t_star
      elements[0]
    end

    def int_literal_constant
      elements[1]
    end
  end

  def _nt_star_int
    start_index = index
    if node_cache[:star_int].has_key?(index)
      cached = node_cache[:star_int][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_star
    s0 << r1
    if r1
      r2 = _nt_int_literal_constant
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Star_Int,input, i0...index, s0)
      r0.extend(StarInt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:star_int][start_index] = r0

    r0
  end

  def _nt_stat_variable
    start_index = index
    if node_cache[:stat_variable].has_key?(index)
      cached = node_cache[:stat_variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_variable

    node_cache[:stat_variable][start_index] = r0

    r0
  end

  module StmtFunctionStmt0
    def label
      elements[0]
    end

    def function_name
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def t_paren_r
      elements[4]
    end

    def t_equal
      elements[5]
    end

    def scalar_expr
      elements[6]
    end

    def t_newline
      elements[7]
    end
  end

  def _nt_stmt_function_stmt
    start_index = index
    if node_cache[:stmt_function_stmt].has_key?(index)
      cached = node_cache[:stmt_function_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_function_name
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r6 = _nt_dummy_arg_name_list
          if r6
            r5 = r6
          else
            r5 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r5
          if r5
            r7 = _nt_t_paren_r
            s0 << r7
            if r7
              r8 = _nt_t_equal
              s0 << r8
              if r8
                r9 = _nt_scalar_expr
                s0 << r9
                if r9
                  r10 = _nt_t_newline
                  s0 << r10
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Stmt_Function_Stmt,input, i0...index, s0)
      r0.extend(StmtFunctionStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:stmt_function_stmt][start_index] = r0

    r0
  end

  def _nt_stop_code
    start_index = index
    if node_cache[:stop_code].has_key?(index)
      cached = node_cache[:stop_code][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_scalar_char_constant
    if r1
      r0 = r1
    else
      s2, i2 = [], index
      loop do
        r3 = _nt_t_digit
        if r3
          s2 << r3
        else
          break
        end
        if s2.size == 5
          break
        end
      end
      if s2.size < 1
        @index = i2
        r2 = nil
      else
        r2 = instantiate_node(T,input, i2...index, s2)
      end
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:stop_code][start_index] = r0

    r0
  end

  module StopStmt0
    def label
      elements[0]
    end

    def t_stop
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_stop_stmt
    start_index = index
    if node_cache[:stop_stmt].has_key?(index)
      cached = node_cache[:stop_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_stop
      s0 << r3
      if r3
        r5 = _nt_stop_code
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(StmtJ,input, i0...index, s0)
      r0.extend(StopStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:stop_stmt][start_index] = r0

    r0
  end

  def _nt_stride
    start_index = index
    if node_cache[:stride].has_key?(index)
      cached = node_cache[:stride][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_expr

    node_cache[:stride][start_index] = r0

    r0
  end

  def _nt_structure_component
    start_index = index
    if node_cache[:structure_component].has_key?(index)
      cached = node_cache[:structure_component][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_data_ref

    node_cache[:structure_component][start_index] = r0

    r0
  end

  module StructureConstructor0
    def type_name
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def expr_list
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_structure_constructor
    start_index = index
    if node_cache[:structure_constructor].has_key?(index)
      cached = node_cache[:structure_constructor][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_type_name
    s0 << r1
    if r1
      r2 = _nt_t_paren_l
      s0 << r2
      if r2
        r3 = _nt_expr_list
        s0 << r3
        if r3
          r4 = _nt_t_paren_r
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(StructureConstructor0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:structure_constructor][start_index] = r0

    r0
  end

  def _nt_subroutine_name
    start_index = index
    if node_cache[:subroutine_name].has_key?(index)
      cached = node_cache[:subroutine_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:subroutine_name][start_index] = r0

    r0
  end

  module SubroutineStmt0
    def label
      elements[0]
    end

    def t_subroutine
      elements[2]
    end

    def subroutine_name
      elements[3]
    end

    def t_newline
      elements[5]
    end

  end

  def _nt_subroutine_stmt
    start_index = index
    if node_cache[:subroutine_stmt].has_key?(index)
      cached = node_cache[:subroutine_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r4 = _nt_prefix_subroutine
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r3
      if r3
        r5 = _nt_t_subroutine
        s0 << r5
        if r5
          r6 = _nt_subroutine_name
          s0 << r6
          if r6
            r8 = _nt_dummy_arg_list_option
            if r8
              r7 = r8
            else
              r7 = instantiate_node(SyntaxNode,input, index...index)
            end
            s0 << r7
            if r7
              r9 = _nt_t_newline
              s0 << r9
              if r9
                i10 = index
                r11 = lambda { |e| sp_subroutine_stmt(e[4]) }.call(s0)
                if r11
                  @index = i10
                  r10 = instantiate_node(SyntaxNode,input, index...index)
                else
                  r10 = nil
                end
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Subroutine_Stmt,input, i0...index, s0)
      r0.extend(SubroutineStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:subroutine_stmt][start_index] = r0

    r0
  end

  module SubroutineSubprogram0
    def subroutine_stmt
      elements[0]
    end

    def end_subroutine_stmt
      elements[4]
    end
  end

  def _nt_subroutine_subprogram
    start_index = index
    if node_cache[:subroutine_subprogram].has_key?(index)
      cached = node_cache[:subroutine_subprogram][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_subroutine_stmt
    s0 << r1
    if r1
      r3 = _nt_specification_part
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        r5 = _nt_execution_part
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r7 = _nt_internal_subprogram_part
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r6
          if r6
            r8 = _nt_end_subroutine_stmt
            s0 << r8
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Subroutine_Subprogram,input, i0...index, s0)
      r0.extend(SubroutineSubprogram0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:subroutine_subprogram][start_index] = r0

    r0
  end

  def _nt_subscript
    start_index = index
    if node_cache[:subscript].has_key?(index)
      cached = node_cache[:subscript][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_expr

    node_cache[:subscript][start_index] = r0

    r0
  end

  module SubscriptTriplet0
    def t_colon
      elements[0]
    end

    def stride
      elements[1]
    end
  end

  module SubscriptTriplet1
    def t_colon
      elements[1]
    end

  end

  def _nt_subscript_triplet
    start_index = index
    if node_cache[:subscript_triplet].has_key?(index)
      cached = node_cache[:subscript_triplet][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_subscript
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_colon
      s0 << r3
      if r3
        r5 = _nt_subscript
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          i7, s7 = index, []
          r8 = _nt_t_colon
          s7 << r8
          if r8
            r9 = _nt_stride
            s7 << r9
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(SubscriptTriplet0)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(SubscriptTriplet1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:subscript_triplet][start_index] = r0

    r0
  end

  def _nt_subobject
    start_index = index
    if node_cache[:subobject].has_key?(index)
      cached = node_cache[:subobject][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_array_section
    if r1
      r0 = r1
    else
      r2 = _nt_array_element
      if r2
        r0 = r2
      else
        r3 = _nt_structure_component
        if r3
          r0 = r3
        else
          r4 = _nt_substring
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:subobject][start_index] = r0

    r0
  end

  module Substring0
    def parent_string
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def substring_range
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_substring
    start_index = index
    if node_cache[:substring].has_key?(index)
      cached = node_cache[:substring][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_parent_string
    s0 << r1
    if r1
      r2 = _nt_t_paren_l
      s0 << r2
      if r2
        r3 = _nt_substring_range
        s0 << r3
        if r3
          r4 = _nt_t_paren_r
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Substring,input, i0...index, s0)
      r0.extend(Substring0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:substring][start_index] = r0

    r0
  end

  module SubstringRange0
    def t_colon
      elements[1]
    end

  end

  def _nt_substring_range
    start_index = index
    if node_cache[:substring_range].has_key?(index)
      cached = node_cache[:substring_range][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_scalar_int_expr
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_colon
      s0 << r3
      if r3
        r5 = _nt_scalar_int_expr
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(SubstringRange0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:substring_range][start_index] = r0

    r0
  end

  module SubstringRangeTriplet0
    def t_paren_l
      elements[0]
    end

    def substring_range
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_substring_range_triplet
    start_index = index
    if node_cache[:substring_range_triplet].has_key?(index)
      cached = node_cache[:substring_range_triplet][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_substring_range
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(SubstringRangeTriplet0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:substring_range_triplet][start_index] = r0

    r0
  end

  def _nt_t_access
    start_index = index
    if node_cache[:t_access].has_key?(index)
      cached = node_cache[:t_access][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("access", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("access")
      r0 = nil
    end

    node_cache[:t_access][start_index] = r0

    r0
  end

  def _nt_t_action
    start_index = index
    if node_cache[:t_action].has_key?(index)
      cached = node_cache[:t_action][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("action", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("action")
      r0 = nil
    end

    node_cache[:t_action][start_index] = r0

    r0
  end

  def _nt_t_advance
    start_index = index
    if node_cache[:t_advance].has_key?(index)
      cached = node_cache[:t_advance][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("advance", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("advance")
      r0 = nil
    end

    node_cache[:t_advance][start_index] = r0

    r0
  end

  def _nt_t_allocatable
    start_index = index
    if node_cache[:t_allocatable].has_key?(index)
      cached = node_cache[:t_allocatable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("allocatable", false, index)
      r0 = instantiate_node(T,input, index...(index + 11))
      @index += 11
    else
      terminal_parse_failure("allocatable")
      r0 = nil
    end

    node_cache[:t_allocatable][start_index] = r0

    r0
  end

  def _nt_t_allocate
    start_index = index
    if node_cache[:t_allocate].has_key?(index)
      cached = node_cache[:t_allocate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("allocate", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("allocate")
      r0 = nil
    end

    node_cache[:t_allocate][start_index] = r0

    r0
  end

  def _nt_t_apostrophe
    start_index = index
    if node_cache[:t_apostrophe].has_key?(index)
      cached = node_cache[:t_apostrophe][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("'", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("'")
      r0 = nil
    end

    node_cache[:t_apostrophe][start_index] = r0

    r0
  end

  module TAssign0
  end

  def _nt_t_assign
    start_index = index
    if node_cache[:t_assign].has_key?(index)
      cached = node_cache[:t_assign][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("assign", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("assign")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      if has_terminal?("ment", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 4))
        @index += 4
      else
        terminal_parse_failure("ment")
        r3 = nil
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TAssign0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_assign][start_index] = r0

    r0
  end

  def _nt_t_assignment
    start_index = index
    if node_cache[:t_assignment].has_key?(index)
      cached = node_cache[:t_assignment][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("assignment", false, index)
      r0 = instantiate_node(T,input, index...(index + 10))
      @index += 10
    else
      terminal_parse_failure("assignment")
      r0 = nil
    end

    node_cache[:t_assignment][start_index] = r0

    r0
  end

  def _nt_t_backspace
    start_index = index
    if node_cache[:t_backspace].has_key?(index)
      cached = node_cache[:t_backspace][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("backspace", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("backspace")
      r0 = nil
    end

    node_cache[:t_backspace][start_index] = r0

    r0
  end

  def _nt_t_binary
    start_index = index
    if node_cache[:t_binary].has_key?(index)
      cached = node_cache[:t_binary][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[01]', true, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:t_binary][start_index] = r0

    r0
  end

  def _nt_t_blank
    start_index = index
    if node_cache[:t_blank].has_key?(index)
      cached = node_cache[:t_blank][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("blank", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("blank")
      r0 = nil
    end

    node_cache[:t_blank][start_index] = r0

    r0
  end

  def _nt_t_block
    start_index = index
    if node_cache[:t_block].has_key?(index)
      cached = node_cache[:t_block][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("block", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("block")
      r0 = nil
    end

    node_cache[:t_block][start_index] = r0

    r0
  end

  def _nt_t_call
    start_index = index
    if node_cache[:t_call].has_key?(index)
      cached = node_cache[:t_call][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("call", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("call")
      r0 = nil
    end

    node_cache[:t_call][start_index] = r0

    r0
  end

  def _nt_t_case
    start_index = index
    if node_cache[:t_case].has_key?(index)
      cached = node_cache[:t_case][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("case", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("case")
      r0 = nil
    end

    node_cache[:t_case][start_index] = r0

    r0
  end

  def _nt_t_character
    start_index = index
    if node_cache[:t_character].has_key?(index)
      cached = node_cache[:t_character][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("character", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("character")
      r0 = nil
    end

    node_cache[:t_character][start_index] = r0

    r0
  end

  def _nt_t_close
    start_index = index
    if node_cache[:t_close].has_key?(index)
      cached = node_cache[:t_close][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("close", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("close")
      r0 = nil
    end

    node_cache[:t_close][start_index] = r0

    r0
  end

  def _nt_t_colon
    start_index = index
    if node_cache[:t_colon].has_key?(index)
      cached = node_cache[:t_colon][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(":", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure(":")
      r0 = nil
    end

    node_cache[:t_colon][start_index] = r0

    r0
  end

  def _nt_t_comma
    start_index = index
    if node_cache[:t_comma].has_key?(index)
      cached = node_cache[:t_comma][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(",", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure(",")
      r0 = nil
    end

    node_cache[:t_comma][start_index] = r0

    r0
  end

  def _nt_t_common
    start_index = index
    if node_cache[:t_common].has_key?(index)
      cached = node_cache[:t_common][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("common", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("common")
      r0 = nil
    end

    node_cache[:t_common][start_index] = r0

    r0
  end

  def _nt_t_contains
    start_index = index
    if node_cache[:t_contains].has_key?(index)
      cached = node_cache[:t_contains][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("contains", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("contains")
      r0 = nil
    end

    node_cache[:t_contains][start_index] = r0

    r0
  end

  def _nt_t_complex
    start_index = index
    if node_cache[:t_complex].has_key?(index)
      cached = node_cache[:t_complex][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("complex", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("complex")
      r0 = nil
    end

    node_cache[:t_complex][start_index] = r0

    r0
  end

  def _nt_t_continue
    start_index = index
    if node_cache[:t_continue].has_key?(index)
      cached = node_cache[:t_continue][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("continue", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("continue")
      r0 = nil
    end

    node_cache[:t_continue][start_index] = r0

    r0
  end

  def _nt_t_cycle
    start_index = index
    if node_cache[:t_cycle].has_key?(index)
      cached = node_cache[:t_cycle][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("cycle", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("cycle")
      r0 = nil
    end

    node_cache[:t_cycle][start_index] = r0

    r0
  end

  def _nt_t_data
    start_index = index
    if node_cache[:t_data].has_key?(index)
      cached = node_cache[:t_data][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("data", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("data")
      r0 = nil
    end

    node_cache[:t_data][start_index] = r0

    r0
  end

  def _nt_t_deallocate
    start_index = index
    if node_cache[:t_deallocate].has_key?(index)
      cached = node_cache[:t_deallocate][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("deallocate", false, index)
      r0 = instantiate_node(T,input, index...(index + 10))
      @index += 10
    else
      terminal_parse_failure("deallocate")
      r0 = nil
    end

    node_cache[:t_deallocate][start_index] = r0

    r0
  end

  def _nt_t_default
    start_index = index
    if node_cache[:t_default].has_key?(index)
      cached = node_cache[:t_default][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("default", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("default")
      r0 = nil
    end

    node_cache[:t_default][start_index] = r0

    r0
  end

  def _nt_t_delim
    start_index = index
    if node_cache[:t_delim].has_key?(index)
      cached = node_cache[:t_delim][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("delim", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("delim")
      r0 = nil
    end

    node_cache[:t_delim][start_index] = r0

    r0
  end

  def _nt_t_digit
    start_index = index
    if node_cache[:t_digit].has_key?(index)
      cached = node_cache[:t_digit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[0-9]', true, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:t_digit][start_index] = r0

    r0
  end

  def _nt_t_dimension
    start_index = index
    if node_cache[:t_dimension].has_key?(index)
      cached = node_cache[:t_dimension][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("dimension", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("dimension")
      r0 = nil
    end

    node_cache[:t_dimension][start_index] = r0

    r0
  end

  def _nt_t_direct
    start_index = index
    if node_cache[:t_direct].has_key?(index)
      cached = node_cache[:t_direct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("direct", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("direct")
      r0 = nil
    end

    node_cache[:t_direct][start_index] = r0

    r0
  end

  def _nt_t_do
    start_index = index
    if node_cache[:t_do].has_key?(index)
      cached = node_cache[:t_do][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("do", false, index)
      r0 = instantiate_node(T,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("do")
      r0 = nil
    end

    node_cache[:t_do][start_index] = r0

    r0
  end

  def _nt_t_dot
    start_index = index
    if node_cache[:t_dot].has_key?(index)
      cached = node_cache[:t_dot][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(".", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure(".")
      r0 = nil
    end

    node_cache[:t_dot][start_index] = r0

    r0
  end

  def _nt_t_doubleprecision
    start_index = index
    if node_cache[:t_doubleprecision].has_key?(index)
      cached = node_cache[:t_doubleprecision][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("doubleprecision", false, index)
      r0 = instantiate_node(T,input, index...(index + 15))
      @index += 15
    else
      terminal_parse_failure("doubleprecision")
      r0 = nil
    end

    node_cache[:t_doubleprecision][start_index] = r0

    r0
  end

  def _nt_t_elemental
    start_index = index
    if node_cache[:t_elemental].has_key?(index)
      cached = node_cache[:t_elemental][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("elemental", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("elemental")
      r0 = nil
    end

    node_cache[:t_elemental][start_index] = r0

    r0
  end

  module TElse0
  end

  def _nt_t_else
    start_index = index
    if node_cache[:t_else].has_key?(index)
      cached = node_cache[:t_else][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("else", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("else")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      i3 = index
      if has_terminal?("if", false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("if")
        r4 = nil
      end
      if r4
        r3 = r4
      else
        if has_terminal?("where", false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 5))
          @index += 5
        else
          terminal_parse_failure("where")
          r5 = nil
        end
        if r5
          r3 = r5
        else
          @index = i3
          r3 = nil
        end
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TElse0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_else][start_index] = r0

    r0
  end

  def _nt_t_elseif
    start_index = index
    if node_cache[:t_elseif].has_key?(index)
      cached = node_cache[:t_elseif][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("elseif", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("elseif")
      r0 = nil
    end

    node_cache[:t_elseif][start_index] = r0

    r0
  end

  def _nt_t_elsewhere
    start_index = index
    if node_cache[:t_elsewhere].has_key?(index)
      cached = node_cache[:t_elsewhere][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("elsewhere", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("elsewhere")
      r0 = nil
    end

    node_cache[:t_elsewhere][start_index] = r0

    r0
  end

  module TEnd0
  end

  def _nt_t_end
    start_index = index
    if node_cache[:t_end].has_key?(index)
      cached = node_cache[:t_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("end", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("end")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      r3 = _nt_t_end_disallowed
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_end][start_index] = r0

    r0
  end

  module TEndDisallowed0
    def t_equal
      elements[1]
    end
  end

  def _nt_t_end_disallowed
    start_index = index
    if node_cache[:t_end_disallowed].has_key?(index)
      cached = node_cache[:t_end_disallowed][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    if has_terminal?("file", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("file")
      r1 = nil
    end
    if r1
      r0 = r1
    else
      if has_terminal?("do", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("do")
        r2 = nil
      end
      if r2
        r0 = r2
      else
        if has_terminal?("if", false, index)
          r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
          @index += 2
        else
          terminal_parse_failure("if")
          r3 = nil
        end
        if r3
          r0 = r3
        else
          if has_terminal?("where", false, index)
            r4 = instantiate_node(SyntaxNode,input, index...(index + 5))
            @index += 5
          else
            terminal_parse_failure("where")
            r4 = nil
          end
          if r4
            r0 = r4
          else
            i5, s5 = index, []
            s6, i6 = [], index
            loop do
              r7 = _nt_alphanumeric_character
              if r7
                s6 << r7
              else
                break
              end
            end
            r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
            s5 << r6
            if r6
              r8 = _nt_t_equal
              s5 << r8
            end
            if s5.last
              r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
              r5.extend(TEndDisallowed0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              r0 = r5
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:t_end_disallowed][start_index] = r0

    r0
  end

  def _nt_t_enddo
    start_index = index
    if node_cache[:t_enddo].has_key?(index)
      cached = node_cache[:t_enddo][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("enddo", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("enddo")
      r0 = nil
    end

    node_cache[:t_enddo][start_index] = r0

    r0
  end

  def _nt_t_endfile
    start_index = index
    if node_cache[:t_endfile].has_key?(index)
      cached = node_cache[:t_endfile][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("endfile", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("endfile")
      r0 = nil
    end

    node_cache[:t_endfile][start_index] = r0

    r0
  end

  def _nt_t_endif
    start_index = index
    if node_cache[:t_endif].has_key?(index)
      cached = node_cache[:t_endif][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("endif", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("endif")
      r0 = nil
    end

    node_cache[:t_endif][start_index] = r0

    r0
  end

  def _nt_t_endwhere
    start_index = index
    if node_cache[:t_endwhere].has_key?(index)
      cached = node_cache[:t_endwhere][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("endwhere", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("endwhere")
      r0 = nil
    end

    node_cache[:t_endwhere][start_index] = r0

    r0
  end

  def _nt_t_entry
    start_index = index
    if node_cache[:t_entry].has_key?(index)
      cached = node_cache[:t_entry][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("entry", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("entry")
      r0 = nil
    end

    node_cache[:t_entry][start_index] = r0

    r0
  end

  def _nt_t_eor
    start_index = index
    if node_cache[:t_eor].has_key?(index)
      cached = node_cache[:t_eor][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("eor", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("eor")
      r0 = nil
    end

    node_cache[:t_eor][start_index] = r0

    r0
  end

  def _nt_t_equal
    start_index = index
    if node_cache[:t_equal].has_key?(index)
      cached = node_cache[:t_equal][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("=", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("=")
      r0 = nil
    end

    node_cache[:t_equal][start_index] = r0

    r0
  end

  def _nt_t_equivalence
    start_index = index
    if node_cache[:t_equivalence].has_key?(index)
      cached = node_cache[:t_equivalence][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("equivalence", false, index)
      r0 = instantiate_node(T,input, index...(index + 11))
      @index += 11
    else
      terminal_parse_failure("equivalence")
      r0 = nil
    end

    node_cache[:t_equivalence][start_index] = r0

    r0
  end

  def _nt_t_err
    start_index = index
    if node_cache[:t_err].has_key?(index)
      cached = node_cache[:t_err][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("err", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("err")
      r0 = nil
    end

    node_cache[:t_err][start_index] = r0

    r0
  end

  def _nt_t_exist
    start_index = index
    if node_cache[:t_exist].has_key?(index)
      cached = node_cache[:t_exist][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("exist", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("exist")
      r0 = nil
    end

    node_cache[:t_exist][start_index] = r0

    r0
  end

  def _nt_t_exit
    start_index = index
    if node_cache[:t_exit].has_key?(index)
      cached = node_cache[:t_exit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("exit", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("exit")
      r0 = nil
    end

    node_cache[:t_exit][start_index] = r0

    r0
  end

  def _nt_t_external
    start_index = index
    if node_cache[:t_external].has_key?(index)
      cached = node_cache[:t_external][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("external", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("external")
      r0 = nil
    end

    node_cache[:t_external][start_index] = r0

    r0
  end

  def _nt_t_false
    start_index = index
    if node_cache[:t_false].has_key?(index)
      cached = node_cache[:t_false][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(".false.", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure(".false.")
      r0 = nil
    end

    node_cache[:t_false][start_index] = r0

    r0
  end

  def _nt_t_file
    start_index = index
    if node_cache[:t_file].has_key?(index)
      cached = node_cache[:t_file][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("file", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("file")
      r0 = nil
    end

    node_cache[:t_file][start_index] = r0

    r0
  end

  def _nt_t_fmt
    start_index = index
    if node_cache[:t_fmt].has_key?(index)
      cached = node_cache[:t_fmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("fmt", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("fmt")
      r0 = nil
    end

    node_cache[:t_fmt][start_index] = r0

    r0
  end

  module TForm0
  end

  def _nt_t_form
    start_index = index
    if node_cache[:t_form].has_key?(index)
      cached = node_cache[:t_form][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("form", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("form")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      if has_terminal?("at", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("at")
        r3 = nil
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TForm0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_form][start_index] = r0

    r0
  end

  module TFormat0
  end

  def _nt_t_format
    start_index = index
    if node_cache[:t_format].has_key?(index)
      cached = node_cache[:t_format][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("format", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("format")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      if has_terminal?("ted", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure("ted")
        r3 = nil
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TFormat0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_format][start_index] = r0

    r0
  end

  def _nt_t_formatted
    start_index = index
    if node_cache[:t_formatted].has_key?(index)
      cached = node_cache[:t_formatted][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("formatted", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("formatted")
      r0 = nil
    end

    node_cache[:t_formatted][start_index] = r0

    r0
  end

  def _nt_t_function
    start_index = index
    if node_cache[:t_function].has_key?(index)
      cached = node_cache[:t_function][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("function", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("function")
      r0 = nil
    end

    node_cache[:t_function][start_index] = r0

    r0
  end

  def _nt_t_goto
    start_index = index
    if node_cache[:t_goto].has_key?(index)
      cached = node_cache[:t_goto][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("goto", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("goto")
      r0 = nil
    end

    node_cache[:t_goto][start_index] = r0

    r0
  end

  def _nt_t_gt
    start_index = index
    if node_cache[:t_gt].has_key?(index)
      cached = node_cache[:t_gt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(">", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure(">")
      r0 = nil
    end

    node_cache[:t_gt][start_index] = r0

    r0
  end

  def _nt_t_if
    start_index = index
    if node_cache[:t_if].has_key?(index)
      cached = node_cache[:t_if][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("if", false, index)
      r0 = instantiate_node(T,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("if")
      r0 = nil
    end

    node_cache[:t_if][start_index] = r0

    r0
  end

  def _nt_t_implicit
    start_index = index
    if node_cache[:t_implicit].has_key?(index)
      cached = node_cache[:t_implicit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("implicit", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("implicit")
      r0 = nil
    end

    node_cache[:t_implicit][start_index] = r0

    r0
  end

  module TIn0
  end

  def _nt_t_in
    start_index = index
    if node_cache[:t_in].has_key?(index)
      cached = node_cache[:t_in][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("in", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("in")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      i3 = index
      if has_terminal?("out", false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 3))
        @index += 3
      else
        terminal_parse_failure("out")
        r4 = nil
      end
      if r4
        r3 = r4
      else
        if has_terminal?("quire", false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 5))
          @index += 5
        else
          terminal_parse_failure("quire")
          r5 = nil
        end
        if r5
          r3 = r5
        else
          if has_terminal?("teger", false, index)
            r6 = instantiate_node(SyntaxNode,input, index...(index + 5))
            @index += 5
          else
            terminal_parse_failure("teger")
            r6 = nil
          end
          if r6
            r3 = r6
          else
            if has_terminal?("tent", false, index)
              r7 = instantiate_node(SyntaxNode,input, index...(index + 4))
              @index += 4
            else
              terminal_parse_failure("tent")
              r7 = nil
            end
            if r7
              r3 = r7
            else
              if has_terminal?("trinsic", false, index)
                r8 = instantiate_node(SyntaxNode,input, index...(index + 7))
                @index += 7
              else
                terminal_parse_failure("trinsic")
                r8 = nil
              end
              if r8
                r3 = r8
              else
                @index = i3
                r3 = nil
              end
            end
          end
        end
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TIn0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_in][start_index] = r0

    r0
  end

  def _nt_t_inout
    start_index = index
    if node_cache[:t_inout].has_key?(index)
      cached = node_cache[:t_inout][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("inout", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("inout")
      r0 = nil
    end

    node_cache[:t_inout][start_index] = r0

    r0
  end

  def _nt_t_inquire
    start_index = index
    if node_cache[:t_inquire].has_key?(index)
      cached = node_cache[:t_inquire][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("inquire", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("inquire")
      r0 = nil
    end

    node_cache[:t_inquire][start_index] = r0

    r0
  end

  def _nt_t_integer
    start_index = index
    if node_cache[:t_integer].has_key?(index)
      cached = node_cache[:t_integer][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("integer", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("integer")
      r0 = nil
    end

    node_cache[:t_integer][start_index] = r0

    r0
  end

  def _nt_t_intent
    start_index = index
    if node_cache[:t_intent].has_key?(index)
      cached = node_cache[:t_intent][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("intent", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("intent")
      r0 = nil
    end

    node_cache[:t_intent][start_index] = r0

    r0
  end

  def _nt_t_interface
    start_index = index
    if node_cache[:t_interface].has_key?(index)
      cached = node_cache[:t_interface][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("interface", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("interface")
      r0 = nil
    end

    node_cache[:t_interface][start_index] = r0

    r0
  end

  def _nt_t_intrinsic
    start_index = index
    if node_cache[:t_intrinsic].has_key?(index)
      cached = node_cache[:t_intrinsic][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("intrinsic", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("intrinsic")
      r0 = nil
    end

    node_cache[:t_intrinsic][start_index] = r0

    r0
  end

  def _nt_t_iolength
    start_index = index
    if node_cache[:t_iolength].has_key?(index)
      cached = node_cache[:t_iolength][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("iolength", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("iolength")
      r0 = nil
    end

    node_cache[:t_iolength][start_index] = r0

    r0
  end

  def _nt_t_iostat
    start_index = index
    if node_cache[:t_iostat].has_key?(index)
      cached = node_cache[:t_iostat][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("iostat", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("iostat")
      r0 = nil
    end

    node_cache[:t_iostat][start_index] = r0

    r0
  end

  def _nt_t_kind
    start_index = index
    if node_cache[:t_kind].has_key?(index)
      cached = node_cache[:t_kind][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("kind", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("kind")
      r0 = nil
    end

    node_cache[:t_kind][start_index] = r0

    r0
  end

  def _nt_t_len
    start_index = index
    if node_cache[:t_len].has_key?(index)
      cached = node_cache[:t_len][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("len", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("len")
      r0 = nil
    end

    node_cache[:t_len][start_index] = r0

    r0
  end

  def _nt_t_letter
    start_index = index
    if node_cache[:t_letter].has_key?(index)
      cached = node_cache[:t_letter][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[a-zA-Z]', true, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:t_letter][start_index] = r0

    r0
  end

  def _nt_t_logical
    start_index = index
    if node_cache[:t_logical].has_key?(index)
      cached = node_cache[:t_logical][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("logical", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("logical")
      r0 = nil
    end

    node_cache[:t_logical][start_index] = r0

    r0
  end

  def _nt_t_lt
    start_index = index
    if node_cache[:t_lt].has_key?(index)
      cached = node_cache[:t_lt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("<", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("<")
      r0 = nil
    end

    node_cache[:t_lt][start_index] = r0

    r0
  end

  def _nt_t_minus
    start_index = index
    if node_cache[:t_minus].has_key?(index)
      cached = node_cache[:t_minus][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("-", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("-")
      r0 = nil
    end

    node_cache[:t_minus][start_index] = r0

    r0
  end

  def _nt_t_module
    start_index = index
    if node_cache[:t_module].has_key?(index)
      cached = node_cache[:t_module][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("module", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("module")
      r0 = nil
    end

    node_cache[:t_module][start_index] = r0

    r0
  end

  module TName0
  end

  def _nt_t_name
    start_index = index
    if node_cache[:t_name].has_key?(index)
      cached = node_cache[:t_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("name", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("name")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      i3 = index
      if has_terminal?("d", false, index)
        r4 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("d")
        r4 = nil
      end
      if r4
        r3 = r4
      else
        if has_terminal?("list", false, index)
          r5 = instantiate_node(SyntaxNode,input, index...(index + 4))
          @index += 4
        else
          terminal_parse_failure("list")
          r5 = nil
        end
        if r5
          r3 = r5
        else
          @index = i3
          r3 = nil
        end
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TName0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_name][start_index] = r0

    r0
  end

  def _nt_t_named
    start_index = index
    if node_cache[:t_named].has_key?(index)
      cached = node_cache[:t_named][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("named", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("named")
      r0 = nil
    end

    node_cache[:t_named][start_index] = r0

    r0
  end

  def _nt_t_namelist
    start_index = index
    if node_cache[:t_namelist].has_key?(index)
      cached = node_cache[:t_namelist][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("namelist", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("namelist")
      r0 = nil
    end

    node_cache[:t_namelist][start_index] = r0

    r0
  end

  def _nt_t_newline
    start_index = index
    if node_cache[:t_newline].has_key?(index)
      cached = node_cache[:t_newline][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("\n", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("\n")
      r0 = nil
    end

    node_cache[:t_newline][start_index] = r0

    r0
  end

  def _nt_t_nextrec
    start_index = index
    if node_cache[:t_nextrec].has_key?(index)
      cached = node_cache[:t_nextrec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("nextrec", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("nextrec")
      r0 = nil
    end

    node_cache[:t_nextrec][start_index] = r0

    r0
  end

  def _nt_t_nml
    start_index = index
    if node_cache[:t_nml].has_key?(index)
      cached = node_cache[:t_nml][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("nml", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("nml")
      r0 = nil
    end

    node_cache[:t_nml][start_index] = r0

    r0
  end

  def _nt_t_none
    start_index = index
    if node_cache[:t_none].has_key?(index)
      cached = node_cache[:t_none][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("none", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("none")
      r0 = nil
    end

    node_cache[:t_none][start_index] = r0

    r0
  end

  def _nt_t_null
    start_index = index
    if node_cache[:t_null].has_key?(index)
      cached = node_cache[:t_null][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("null", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("null")
      r0 = nil
    end

    node_cache[:t_null][start_index] = r0

    r0
  end

  def _nt_t_nullify
    start_index = index
    if node_cache[:t_nullify].has_key?(index)
      cached = node_cache[:t_nullify][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("nullify", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("nullify")
      r0 = nil
    end

    node_cache[:t_nullify][start_index] = r0

    r0
  end

  def _nt_t_number
    start_index = index
    if node_cache[:t_number].has_key?(index)
      cached = node_cache[:t_number][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("number", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("number")
      r0 = nil
    end

    node_cache[:t_number][start_index] = r0

    r0
  end

  def _nt_t_octal
    start_index = index
    if node_cache[:t_octal].has_key?(index)
      cached = node_cache[:t_octal][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?('\G[01234567]', true, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      r0 = nil
    end

    node_cache[:t_octal][start_index] = r0

    r0
  end

  def _nt_t_only
    start_index = index
    if node_cache[:t_only].has_key?(index)
      cached = node_cache[:t_only][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("only", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("only")
      r0 = nil
    end

    node_cache[:t_only][start_index] = r0

    r0
  end

  module TOpen0
  end

  def _nt_t_open
    start_index = index
    if node_cache[:t_open].has_key?(index)
      cached = node_cache[:t_open][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("open", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("open")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      if has_terminal?("ed", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("ed")
        r3 = nil
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TOpen0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_open][start_index] = r0

    r0
  end

  def _nt_t_opened
    start_index = index
    if node_cache[:t_opened].has_key?(index)
      cached = node_cache[:t_opened][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("opened", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("opened")
      r0 = nil
    end

    node_cache[:t_opened][start_index] = r0

    r0
  end

  def _nt_t_operator
    start_index = index
    if node_cache[:t_operator].has_key?(index)
      cached = node_cache[:t_operator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("operator", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("operator")
      r0 = nil
    end

    node_cache[:t_operator][start_index] = r0

    r0
  end

  def _nt_t_optional
    start_index = index
    if node_cache[:t_optional].has_key?(index)
      cached = node_cache[:t_optional][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("optional", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("optional")
      r0 = nil
    end

    node_cache[:t_optional][start_index] = r0

    r0
  end

  def _nt_t_out
    start_index = index
    if node_cache[:t_out].has_key?(index)
      cached = node_cache[:t_out][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("out", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("out")
      r0 = nil
    end

    node_cache[:t_out][start_index] = r0

    r0
  end

  def _nt_t_pad
    start_index = index
    if node_cache[:t_pad].has_key?(index)
      cached = node_cache[:t_pad][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("pad", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("pad")
      r0 = nil
    end

    node_cache[:t_pad][start_index] = r0

    r0
  end

  def _nt_t_parameter
    start_index = index
    if node_cache[:t_parameter].has_key?(index)
      cached = node_cache[:t_parameter][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("parameter", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("parameter")
      r0 = nil
    end

    node_cache[:t_parameter][start_index] = r0

    r0
  end

  def _nt_t_paren_l
    start_index = index
    if node_cache[:t_paren_l].has_key?(index)
      cached = node_cache[:t_paren_l][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("(", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("(")
      r0 = nil
    end

    node_cache[:t_paren_l][start_index] = r0

    r0
  end

  def _nt_t_paren_r
    start_index = index
    if node_cache[:t_paren_r].has_key?(index)
      cached = node_cache[:t_paren_r][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(")", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure(")")
      r0 = nil
    end

    node_cache[:t_paren_r][start_index] = r0

    r0
  end

  def _nt_t_pause
    start_index = index
    if node_cache[:t_pause].has_key?(index)
      cached = node_cache[:t_pause][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("pause", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("pause")
      r0 = nil
    end

    node_cache[:t_pause][start_index] = r0

    r0
  end

  def _nt_t_percent
    start_index = index
    if node_cache[:t_percent].has_key?(index)
      cached = node_cache[:t_percent][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("%", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("%")
      r0 = nil
    end

    node_cache[:t_percent][start_index] = r0

    r0
  end

  def _nt_t_plus
    start_index = index
    if node_cache[:t_plus].has_key?(index)
      cached = node_cache[:t_plus][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("+", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("+")
      r0 = nil
    end

    node_cache[:t_plus][start_index] = r0

    r0
  end

  def _nt_t_point
    start_index = index
    if node_cache[:t_point].has_key?(index)
      cached = node_cache[:t_point][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("=>", false, index)
      r0 = instantiate_node(T,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("=>")
      r0 = nil
    end

    node_cache[:t_point][start_index] = r0

    r0
  end

  def _nt_t_pointer
    start_index = index
    if node_cache[:t_pointer].has_key?(index)
      cached = node_cache[:t_pointer][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("pointer", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("pointer")
      r0 = nil
    end

    node_cache[:t_pointer][start_index] = r0

    r0
  end

  def _nt_t_position
    start_index = index
    if node_cache[:t_position].has_key?(index)
      cached = node_cache[:t_position][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("position", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("position")
      r0 = nil
    end

    node_cache[:t_position][start_index] = r0

    r0
  end

  def _nt_t_print
    start_index = index
    if node_cache[:t_print].has_key?(index)
      cached = node_cache[:t_print][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("print", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("print")
      r0 = nil
    end

    node_cache[:t_print][start_index] = r0

    r0
  end

  def _nt_t_private
    start_index = index
    if node_cache[:t_private].has_key?(index)
      cached = node_cache[:t_private][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("private", false, index)
      r0 = instantiate_node(Access_Spec,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("private")
      r0 = nil
    end

    node_cache[:t_private][start_index] = r0

    r0
  end

  def _nt_t_procedure
    start_index = index
    if node_cache[:t_procedure].has_key?(index)
      cached = node_cache[:t_procedure][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("procedure", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("procedure")
      r0 = nil
    end

    node_cache[:t_procedure][start_index] = r0

    r0
  end

  def _nt_t_program
    start_index = index
    if node_cache[:t_program].has_key?(index)
      cached = node_cache[:t_program][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("program", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("program")
      r0 = nil
    end

    node_cache[:t_program][start_index] = r0

    r0
  end

  def _nt_t_public
    start_index = index
    if node_cache[:t_public].has_key?(index)
      cached = node_cache[:t_public][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("public", false, index)
      r0 = instantiate_node(Access_Spec,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("public")
      r0 = nil
    end

    node_cache[:t_public][start_index] = r0

    r0
  end

  def _nt_t_pure
    start_index = index
    if node_cache[:t_pure].has_key?(index)
      cached = node_cache[:t_pure][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("pure", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("pure")
      r0 = nil
    end

    node_cache[:t_pure][start_index] = r0

    r0
  end

  def _nt_t_quotemark
    start_index = index
    if node_cache[:t_quotemark].has_key?(index)
      cached = node_cache[:t_quotemark][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("\"", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("\"")
      r0 = nil
    end

    node_cache[:t_quotemark][start_index] = r0

    r0
  end

  module TRead0
  end

  def _nt_t_read
    start_index = index
    if node_cache[:t_read].has_key?(index)
      cached = node_cache[:t_read][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("read", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("read")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      if has_terminal?("write", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 5))
        @index += 5
      else
        terminal_parse_failure("write")
        r3 = nil
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TRead0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_read][start_index] = r0

    r0
  end

  def _nt_t_readwrite
    start_index = index
    if node_cache[:t_readwrite].has_key?(index)
      cached = node_cache[:t_readwrite][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("readwrite", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("readwrite")
      r0 = nil
    end

    node_cache[:t_readwrite][start_index] = r0

    r0
  end

  def _nt_t_real
    start_index = index
    if node_cache[:t_real].has_key?(index)
      cached = node_cache[:t_real][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("real", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("real")
      r0 = nil
    end

    node_cache[:t_real][start_index] = r0

    r0
  end

  module TRec0
  end

  def _nt_t_rec
    start_index = index
    if node_cache[:t_rec].has_key?(index)
      cached = node_cache[:t_rec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("rec", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("rec")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      if has_terminal?("l", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("l")
        r3 = nil
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TRec0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_rec][start_index] = r0

    r0
  end

  def _nt_t_recl
    start_index = index
    if node_cache[:t_recl].has_key?(index)
      cached = node_cache[:t_recl][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("recl", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("recl")
      r0 = nil
    end

    node_cache[:t_recl][start_index] = r0

    r0
  end

  def _nt_t_recursive
    start_index = index
    if node_cache[:t_recursive].has_key?(index)
      cached = node_cache[:t_recursive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("recursive", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("recursive")
      r0 = nil
    end

    node_cache[:t_recursive][start_index] = r0

    r0
  end

  def _nt_t_result
    start_index = index
    if node_cache[:t_result].has_key?(index)
      cached = node_cache[:t_result][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("result", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("result")
      r0 = nil
    end

    node_cache[:t_result][start_index] = r0

    r0
  end

  def _nt_t_return
    start_index = index
    if node_cache[:t_return].has_key?(index)
      cached = node_cache[:t_return][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("return", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("return")
      r0 = nil
    end

    node_cache[:t_return][start_index] = r0

    r0
  end

  def _nt_t_rewind
    start_index = index
    if node_cache[:t_rewind].has_key?(index)
      cached = node_cache[:t_rewind][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("rewind", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("rewind")
      r0 = nil
    end

    node_cache[:t_rewind][start_index] = r0

    r0
  end

  def _nt_t_save
    start_index = index
    if node_cache[:t_save].has_key?(index)
      cached = node_cache[:t_save][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("save", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("save")
      r0 = nil
    end

    node_cache[:t_save][start_index] = r0

    r0
  end

  def _nt_t_select
    start_index = index
    if node_cache[:t_select].has_key?(index)
      cached = node_cache[:t_select][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("select", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("select")
      r0 = nil
    end

    node_cache[:t_select][start_index] = r0

    r0
  end

  def _nt_t_sequence
    start_index = index
    if node_cache[:t_sequence].has_key?(index)
      cached = node_cache[:t_sequence][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("sequence", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("sequence")
      r0 = nil
    end

    node_cache[:t_sequence][start_index] = r0

    r0
  end

  def _nt_t_sequential
    start_index = index
    if node_cache[:t_sequential].has_key?(index)
      cached = node_cache[:t_sequential][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("sequential", false, index)
      r0 = instantiate_node(T,input, index...(index + 10))
      @index += 10
    else
      terminal_parse_failure("sequential")
      r0 = nil
    end

    node_cache[:t_sequential][start_index] = r0

    r0
  end

  def _nt_t_size
    start_index = index
    if node_cache[:t_size].has_key?(index)
      cached = node_cache[:t_size][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("size", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("size")
      r0 = nil
    end

    node_cache[:t_size][start_index] = r0

    r0
  end

  def _nt_t_slash
    start_index = index
    if node_cache[:t_slash].has_key?(index)
      cached = node_cache[:t_slash][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("/", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("/")
      r0 = nil
    end

    node_cache[:t_slash][start_index] = r0

    r0
  end

  def _nt_t_star
    start_index = index
    if node_cache[:t_star].has_key?(index)
      cached = node_cache[:t_star][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("*", false, index)
      r0 = instantiate_node(T,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("*")
      r0 = nil
    end

    node_cache[:t_star][start_index] = r0

    r0
  end

  module TStat0
  end

  def _nt_t_stat
    start_index = index
    if node_cache[:t_stat].has_key?(index)
      cached = node_cache[:t_stat][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    if has_terminal?("stat", false, index)
      r1 = instantiate_node(SyntaxNode,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("stat")
      r1 = nil
    end
    s0 << r1
    if r1
      i2 = index
      if has_terminal?("us", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 2))
        @index += 2
      else
        terminal_parse_failure("us")
        r3 = nil
      end
      if r3
        r2 = nil
      else
        @index = i2
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(TStat0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:t_stat][start_index] = r0

    r0
  end

  def _nt_t_status
    start_index = index
    if node_cache[:t_status].has_key?(index)
      cached = node_cache[:t_status][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("status", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("status")
      r0 = nil
    end

    node_cache[:t_status][start_index] = r0

    r0
  end

  def _nt_t_stop
    start_index = index
    if node_cache[:t_stop].has_key?(index)
      cached = node_cache[:t_stop][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("stop", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("stop")
      r0 = nil
    end

    node_cache[:t_stop][start_index] = r0

    r0
  end

  def _nt_t_subroutine
    start_index = index
    if node_cache[:t_subroutine].has_key?(index)
      cached = node_cache[:t_subroutine][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("subroutine", false, index)
      r0 = instantiate_node(T,input, index...(index + 10))
      @index += 10
    else
      terminal_parse_failure("subroutine")
      r0 = nil
    end

    node_cache[:t_subroutine][start_index] = r0

    r0
  end

  def _nt_t_target
    start_index = index
    if node_cache[:t_target].has_key?(index)
      cached = node_cache[:t_target][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("target", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("target")
      r0 = nil
    end

    node_cache[:t_target][start_index] = r0

    r0
  end

  def _nt_t_then
    start_index = index
    if node_cache[:t_then].has_key?(index)
      cached = node_cache[:t_then][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("then", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("then")
      r0 = nil
    end

    node_cache[:t_then][start_index] = r0

    r0
  end

  def _nt_t_to
    start_index = index
    if node_cache[:t_to].has_key?(index)
      cached = node_cache[:t_to][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("to", false, index)
      r0 = instantiate_node(T,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("to")
      r0 = nil
    end

    node_cache[:t_to][start_index] = r0

    r0
  end

  def _nt_t_true
    start_index = index
    if node_cache[:t_true].has_key?(index)
      cached = node_cache[:t_true][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?(".true.", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure(".true.")
      r0 = nil
    end

    node_cache[:t_true][start_index] = r0

    r0
  end

  def _nt_t_type
    start_index = index
    if node_cache[:t_type].has_key?(index)
      cached = node_cache[:t_type][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("type", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("type")
      r0 = nil
    end

    node_cache[:t_type][start_index] = r0

    r0
  end

  def _nt_t_underscore
    start_index = index
    if node_cache[:t_underscore].has_key?(index)
      cached = node_cache[:t_underscore][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("_", false, index)
      r0 = instantiate_node(SyntaxNode,input, index...(index + 1))
      @index += 1
    else
      terminal_parse_failure("_")
      r0 = nil
    end

    node_cache[:t_underscore][start_index] = r0

    r0
  end

  def _nt_t_unformatted
    start_index = index
    if node_cache[:t_unformatted].has_key?(index)
      cached = node_cache[:t_unformatted][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("unformatted", false, index)
      r0 = instantiate_node(T,input, index...(index + 11))
      @index += 11
    else
      terminal_parse_failure("unformatted")
      r0 = nil
    end

    node_cache[:t_unformatted][start_index] = r0

    r0
  end

  def _nt_t_unit
    start_index = index
    if node_cache[:t_unit].has_key?(index)
      cached = node_cache[:t_unit][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("unit", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("unit")
      r0 = nil
    end

    node_cache[:t_unit][start_index] = r0

    r0
  end

  def _nt_t_use
    start_index = index
    if node_cache[:t_use].has_key?(index)
      cached = node_cache[:t_use][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("use", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("use")
      r0 = nil
    end

    node_cache[:t_use][start_index] = r0

    r0
  end

  def _nt_t_where
    start_index = index
    if node_cache[:t_where].has_key?(index)
      cached = node_cache[:t_where][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("where", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("where")
      r0 = nil
    end

    node_cache[:t_where][start_index] = r0

    r0
  end

  def _nt_t_while
    start_index = index
    if node_cache[:t_while].has_key?(index)
      cached = node_cache[:t_while][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("while", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("while")
      r0 = nil
    end

    node_cache[:t_while][start_index] = r0

    r0
  end

  def _nt_t_write
    start_index = index
    if node_cache[:t_write].has_key?(index)
      cached = node_cache[:t_write][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("write", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("write")
      r0 = nil
    end

    node_cache[:t_write][start_index] = r0

    r0
  end

  def _nt_target
    start_index = index
    if node_cache[:target].has_key?(index)
      cached = node_cache[:target][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_variable
    if r1
      r0 = r1
    else
      r2 = _nt_expr
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:target][start_index] = r0

    r0
  end

  def _nt_target_object
    start_index = index
    if node_cache[:target_object].has_key?(index)
      cached = node_cache[:target_object][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_array_name_and_spec
    if r1
      r0 = r1
    else
      r2 = _nt_variable_name
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:target_object][start_index] = r0

    r0
  end

  module TargetObjectList0
    def target_object
      elements[0]
    end

  end

  def _nt_target_object_list
    start_index = index
    if node_cache[:target_object_list].has_key?(index)
      cached = node_cache[:target_object_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_target_object
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        r3 = _nt_target_object_list_pair
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Target_Object_List,input, i0...index, s0)
      r0.extend(TargetObjectList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:target_object_list][start_index] = r0

    r0
  end

  module TargetObjectListPair0
    def t_comma
      elements[0]
    end

    def target_object
      elements[1]
    end
  end

  def _nt_target_object_list_pair
    start_index = index
    if node_cache[:target_object_list_pair].has_key?(index)
      cached = node_cache[:target_object_list_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_comma
    s0 << r1
    if r1
      r2 = _nt_target_object
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Target_Object_List_Pair,input, i0...index, s0)
      r0.extend(TargetObjectListPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:target_object_list_pair][start_index] = r0

    r0
  end

  module TargetStmt0
    def label
      elements[0]
    end

    def t_target
      elements[1]
    end

    def target_object_list
      elements[3]
    end

    def t_newline
      elements[4]
    end

  end

  def _nt_target_stmt
    start_index = index
    if node_cache[:target_stmt].has_key?(index)
      cached = node_cache[:target_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_target
      s0 << r3
      if r3
        r5 = _nt_double_colon
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_target_object_list
          s0 << r6
          if r6
            r7 = _nt_t_newline
            s0 << r7
            if r7
              i8 = index
              r9 = lambda { |e| sp_target_stmt(e[3]) }.call(s0)
              if r9
                @index = i8
                r8 = instantiate_node(SyntaxNode,input, index...index)
              else
                r8 = nil
              end
              s0 << r8
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Target_Stmt,input, i0...index, s0)
      r0.extend(TargetStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:target_stmt][start_index] = r0

    r0
  end

  module TypeDeclarationStmt0
    def label
      elements[0]
    end

    def type_spec
      elements[1]
    end

    def entity_decl_list
      elements[3]
    end

    def t_newline
      elements[4]
    end

  end

  def _nt_type_declaration_stmt
    start_index = index
    if node_cache[:type_declaration_stmt].has_key?(index)
      cached = node_cache[:type_declaration_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_type_spec
      s0 << r3
      if r3
        r5 = _nt_attr_spec_option
        if r5
          r4 = r5
        else
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r4
        if r4
          r6 = _nt_entity_decl_list
          s0 << r6
          if r6
            r7 = _nt_t_newline
            s0 << r7
            if r7
              i8 = index
              r9 = lambda { |e| sp_type_declaration_stmt(e[1],e[2],e[3]) }.call(s0)
              if r9
                @index = i8
                r8 = instantiate_node(SyntaxNode,input, index...index)
              else
                r8 = nil
              end
              s0 << r8
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Type_Declaration_Stmt,input, i0...index, s0)
      r0.extend(TypeDeclarationStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:type_declaration_stmt][start_index] = r0

    r0
  end

  def _nt_type_name
    start_index = index
    if node_cache[:type_name].has_key?(index)
      cached = node_cache[:type_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:type_name][start_index] = r0

    r0
  end

  def _nt_type_param_value
    start_index = index
    if node_cache[:type_param_value].has_key?(index)
      cached = node_cache[:type_param_value][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_specification_expr
    if r1
      r0 = r1
    else
      r2 = _nt_t_star
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:type_param_value][start_index] = r0

    r0
  end

  def _nt_type_spec
    start_index = index
    if node_cache[:type_spec].has_key?(index)
      cached = node_cache[:type_spec][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_type_spec_with_kind_selector
    if r1
      r0 = r1
    else
      r2 = _nt_type_spec_without_kind_selector
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:type_spec][start_index] = r0

    r0
  end

  module TypeSpecWithKindSelector0
    def t_integer
      elements[0]
    end

    def kind_selector
      elements[1]
    end
  end

  module TypeSpecWithKindSelector1
    def t_real
      elements[0]
    end

    def kind_selector
      elements[1]
    end
  end

  module TypeSpecWithKindSelector2
    def t_complex
      elements[0]
    end

    def kind_selector
      elements[1]
    end
  end

  module TypeSpecWithKindSelector3
    def t_logical
      elements[0]
    end

    def kind_selector
      elements[1]
    end
  end

  def _nt_type_spec_with_kind_selector
    start_index = index
    if node_cache[:type_spec_with_kind_selector].has_key?(index)
      cached = node_cache[:type_spec_with_kind_selector][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_integer
    s1 << r2
    if r2
      r3 = _nt_kind_selector
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(Type_Spec,input, i1...index, s1)
      r1.extend(TypeSpecWithKindSelector0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i4, s4 = index, []
      r5 = _nt_t_real
      s4 << r5
      if r5
        r6 = _nt_kind_selector
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(Type_Spec,input, i4...index, s4)
        r4.extend(TypeSpecWithKindSelector1)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r0 = r4
      else
        i7, s7 = index, []
        r8 = _nt_t_complex
        s7 << r8
        if r8
          r9 = _nt_kind_selector
          s7 << r9
        end
        if s7.last
          r7 = instantiate_node(Type_Spec,input, i7...index, s7)
          r7.extend(TypeSpecWithKindSelector2)
        else
          @index = i7
          r7 = nil
        end
        if r7
          r0 = r7
        else
          i10, s10 = index, []
          r11 = _nt_t_logical
          s10 << r11
          if r11
            r12 = _nt_kind_selector
            s10 << r12
          end
          if s10.last
            r10 = instantiate_node(Type_Spec,input, i10...index, s10)
            r10.extend(TypeSpecWithKindSelector3)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r0 = r10
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:type_spec_with_kind_selector][start_index] = r0

    r0
  end

  module TypeSpecWithoutKindSelector0
    def t_integer
      elements[0]
    end

    def star_int
      elements[1]
    end
  end

  module TypeSpecWithoutKindSelector1
    def t_integer
      elements[0]
    end

  end

  module TypeSpecWithoutKindSelector2
    def t_real
      elements[0]
    end

    def star_int
      elements[1]
    end
  end

  module TypeSpecWithoutKindSelector3
    def t_real
      elements[0]
    end

  end

  module TypeSpecWithoutKindSelector4
    def t_doubleprecision
      elements[0]
    end

  end

  module TypeSpecWithoutKindSelector5
    def t_complex
      elements[0]
    end

  end

  module TypeSpecWithoutKindSelector6
    def t_character
      elements[0]
    end

  end

  module TypeSpecWithoutKindSelector7
    def t_logical
      elements[0]
    end

  end

  module TypeSpecWithoutKindSelector8
    def t_type
      elements[0]
    end

    def t_paren_l
      elements[1]
    end

    def type_name
      elements[2]
    end

    def t_paren_r
      elements[3]
    end
  end

  def _nt_type_spec_without_kind_selector
    start_index = index
    if node_cache[:type_spec_without_kind_selector].has_key?(index)
      cached = node_cache[:type_spec_without_kind_selector][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_integer
    s1 << r2
    if r2
      r3 = _nt_star_int
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(Type_Spec,input, i1...index, s1)
      r1.extend(TypeSpecWithoutKindSelector0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i4, s4 = index, []
      r5 = _nt_t_integer
      s4 << r5
      if r5
        if has_terminal?("", false, index)
          r6 = instantiate_node(SyntaxNode,input, index...(index + 0))
          @index += 0
        else
          terminal_parse_failure("")
          r6 = nil
        end
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(Type_Spec,input, i4...index, s4)
        r4.extend(TypeSpecWithoutKindSelector1)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r0 = r4
      else
        i7, s7 = index, []
        r8 = _nt_t_real
        s7 << r8
        if r8
          r9 = _nt_star_int
          s7 << r9
        end
        if s7.last
          r7 = instantiate_node(Type_Spec,input, i7...index, s7)
          r7.extend(TypeSpecWithoutKindSelector2)
        else
          @index = i7
          r7 = nil
        end
        if r7
          r0 = r7
        else
          i10, s10 = index, []
          r11 = _nt_t_real
          s10 << r11
          if r11
            if has_terminal?("", false, index)
              r12 = instantiate_node(SyntaxNode,input, index...(index + 0))
              @index += 0
            else
              terminal_parse_failure("")
              r12 = nil
            end
            s10 << r12
          end
          if s10.last
            r10 = instantiate_node(Type_Spec,input, i10...index, s10)
            r10.extend(TypeSpecWithoutKindSelector3)
          else
            @index = i10
            r10 = nil
          end
          if r10
            r0 = r10
          else
            i13, s13 = index, []
            r14 = _nt_t_doubleprecision
            s13 << r14
            if r14
              if has_terminal?("", false, index)
                r15 = instantiate_node(SyntaxNode,input, index...(index + 0))
                @index += 0
              else
                terminal_parse_failure("")
                r15 = nil
              end
              s13 << r15
            end
            if s13.last
              r13 = instantiate_node(Type_Spec,input, i13...index, s13)
              r13.extend(TypeSpecWithoutKindSelector4)
            else
              @index = i13
              r13 = nil
            end
            if r13
              r0 = r13
            else
              i16, s16 = index, []
              r17 = _nt_t_complex
              s16 << r17
              if r17
                if has_terminal?("", false, index)
                  r18 = instantiate_node(SyntaxNode,input, index...(index + 0))
                  @index += 0
                else
                  terminal_parse_failure("")
                  r18 = nil
                end
                s16 << r18
              end
              if s16.last
                r16 = instantiate_node(Type_Spec,input, i16...index, s16)
                r16.extend(TypeSpecWithoutKindSelector5)
              else
                @index = i16
                r16 = nil
              end
              if r16
                r0 = r16
              else
                i19, s19 = index, []
                r20 = _nt_t_character
                s19 << r20
                if r20
                  r22 = _nt_char_selector
                  if r22
                    r21 = r22
                  else
                    r21 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s19 << r21
                end
                if s19.last
                  r19 = instantiate_node(Type_Spec,input, i19...index, s19)
                  r19.extend(TypeSpecWithoutKindSelector6)
                else
                  @index = i19
                  r19 = nil
                end
                if r19
                  r0 = r19
                else
                  i23, s23 = index, []
                  r24 = _nt_t_logical
                  s23 << r24
                  if r24
                    if has_terminal?("", false, index)
                      r25 = instantiate_node(SyntaxNode,input, index...(index + 0))
                      @index += 0
                    else
                      terminal_parse_failure("")
                      r25 = nil
                    end
                    s23 << r25
                  end
                  if s23.last
                    r23 = instantiate_node(Type_Spec,input, i23...index, s23)
                    r23.extend(TypeSpecWithoutKindSelector7)
                  else
                    @index = i23
                    r23 = nil
                  end
                  if r23
                    r0 = r23
                  else
                    i26, s26 = index, []
                    r27 = _nt_t_type
                    s26 << r27
                    if r27
                      r28 = _nt_t_paren_l
                      s26 << r28
                      if r28
                        r29 = _nt_type_name
                        s26 << r29
                        if r29
                          r30 = _nt_t_paren_r
                          s26 << r30
                        end
                      end
                    end
                    if s26.last
                      r26 = instantiate_node(Type_Spec,input, i26...index, s26)
                      r26.extend(TypeSpecWithoutKindSelector8)
                    else
                      @index = i26
                      r26 = nil
                    end
                    if r26
                      r0 = r26
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:type_spec_without_kind_selector][start_index] = r0

    r0
  end

  module UpperBound0
    def specification_expr
      elements[0]
    end

  end

  def _nt_upper_bound
    start_index = index
    if node_cache[:upper_bound].has_key?(index)
      cached = node_cache[:upper_bound][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_specification_expr
    s0 << r1
    if r1
      if has_terminal?("", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure("")
        r2 = nil
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(Upper_Bound,input, i0...index, s0)
      r0.extend(UpperBound0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:upper_bound][start_index] = r0

    r0
  end

  def _nt_use_name
    start_index = index
    if node_cache[:use_name].has_key?(index)
      cached = node_cache[:use_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:use_name][start_index] = r0

    r0
  end

  def _nt_use_part
    start_index = index
    if node_cache[:use_part].has_key?(index)
      cached = node_cache[:use_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_use_stmt
      if r2
        r1 = r2
      else
        r3 = _nt_directive
        if r3
          r1 = r3
        else
          @index = i1
          r1 = nil
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(Use_Part,input, i0...index, s0)

    node_cache[:use_part][start_index] = r0

    r0
  end

  module UseStmt0
    def label
      elements[0]
    end

    def t_use
      elements[1]
    end

    def module_name
      elements[2]
    end

    def t_newline
      elements[4]
    end

  end

  module UseStmt1
    def label
      elements[0]
    end

    def t_use
      elements[1]
    end

    def module_name
      elements[2]
    end

    def t_comma
      elements[3]
    end

    def t_only
      elements[4]
    end

    def t_colon
      elements[5]
    end

    def t_newline
      elements[7]
    end

  end

  def _nt_use_stmt
    start_index = index
    if node_cache[:use_stmt].has_key?(index)
      cached = node_cache[:use_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r3 = _nt_label
    if r3
      r2 = r3
    else
      r2 = instantiate_node(SyntaxNode,input, index...index)
    end
    s1 << r2
    if r2
      r4 = _nt_t_use
      s1 << r4
      if r4
        r5 = _nt_module_name
        s1 << r5
        if r5
          r7 = _nt_rename_list_option
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s1 << r6
          if r6
            r8 = _nt_t_newline
            s1 << r8
            if r8
              i9 = index
              r10 = lambda { |e| sp_use_stmt(e[2],e[3]) }.call(s1)
              if r10
                @index = i9
                r9 = instantiate_node(SyntaxNode,input, index...index)
              else
                r9 = nil
              end
              s1 << r9
            end
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(Use_Stmt_1,input, i1...index, s1)
      r1.extend(UseStmt0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i11, s11 = index, []
      r13 = _nt_label
      if r13
        r12 = r13
      else
        r12 = instantiate_node(SyntaxNode,input, index...index)
      end
      s11 << r12
      if r12
        r14 = _nt_t_use
        s11 << r14
        if r14
          r15 = _nt_module_name
          s11 << r15
          if r15
            r16 = _nt_t_comma
            s11 << r16
            if r16
              r17 = _nt_t_only
              s11 << r17
              if r17
                r18 = _nt_t_colon
                s11 << r18
                if r18
                  r20 = _nt_only_list
                  if r20
                    r19 = r20
                  else
                    r19 = instantiate_node(SyntaxNode,input, index...index)
                  end
                  s11 << r19
                  if r19
                    r21 = _nt_t_newline
                    s11 << r21
                    if r21
                      i22 = index
                      r23 = lambda { |e| sp_use_stmt(e[2],e[6]) }.call(s11)
                      if r23
                        @index = i22
                        r22 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        r22 = nil
                      end
                      s11 << r22
                    end
                  end
                end
              end
            end
          end
        end
      end
      if s11.last
        r11 = instantiate_node(Use_Stmt_2,input, i11...index, s11)
        r11.extend(UseStmt1)
      else
        @index = i11
        r11 = nil
      end
      if r11
        r0 = r11
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:use_stmt][start_index] = r0

    r0
  end

  def _nt_variable
    start_index = index
    if node_cache[:variable].has_key?(index)
      cached = node_cache[:variable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_subobject
    if r1
      r0 = r1
    else
      r2 = _nt_array_variable_name
      if r2
        r0 = r2
      else
        r3 = _nt_scalar_variable_name
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:variable][start_index] = r0

    r0
  end

  def _nt_variable_name
    start_index = index
    if node_cache[:variable_name].has_key?(index)
      cached = node_cache[:variable_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_name

    node_cache[:variable_name][start_index] = r0

    r0
  end

  def _nt_vector_subscript
    start_index = index
    if node_cache[:vector_subscript].has_key?(index)
      cached = node_cache[:vector_subscript][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_int_expr

    node_cache[:vector_subscript][start_index] = r0

    r0
  end

  def _nt_where_assignment_stmt_block
    start_index = index
    if node_cache[:where_assignment_stmt_block].has_key?(index)
      cached = node_cache[:where_assignment_stmt_block][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_assignment_stmt
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(E,input, i0...index, s0)

    node_cache[:where_assignment_stmt_block][start_index] = r0

    r0
  end

  module WhereConstruct0
    def where_construct_stmt
      elements[0]
    end

    def where_assignment_stmt_block
      elements[1]
    end

    def end_where_stmt
      elements[3]
    end
  end

  def _nt_where_construct
    start_index = index
    if node_cache[:where_construct].has_key?(index)
      cached = node_cache[:where_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_where_construct_stmt
    s0 << r1
    if r1
      r2 = _nt_where_assignment_stmt_block
      s0 << r2
      if r2
        r4 = _nt_elsewhere_construct
        if r4
          r3 = r4
        else
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
        if r3
          r5 = _nt_end_where_stmt
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(E,input, i0...index, s0)
      r0.extend(WhereConstruct0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:where_construct][start_index] = r0

    r0
  end

  module WhereConstructStmt0
    def label
      elements[0]
    end

    def t_where
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def mask_expr
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_where_construct_stmt
    start_index = index
    if node_cache[:where_construct_stmt].has_key?(index)
      cached = node_cache[:where_construct_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_where
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_mask_expr
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r7 = _nt_t_newline
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Where_Construct_Stmt,input, i0...index, s0)
      r0.extend(WhereConstructStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:where_construct_stmt][start_index] = r0

    r0
  end

  module WhereStmt0
    def label
      elements[0]
    end

    def t_where
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def mask_expr
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def assignment_stmt
      elements[6]
    end
  end

  def _nt_where_stmt
    start_index = index
    if node_cache[:where_stmt].has_key?(index)
      cached = node_cache[:where_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_where
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_mask_expr
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              i7 = index
              r8 = _nt_label
              if r8
                r7 = nil
              else
                @index = i7
                r7 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r7
              if r7
                r9 = _nt_assignment_stmt
                s0 << r9
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Where_Stmt,input, i0...index, s0)
      r0.extend(WhereStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:where_stmt][start_index] = r0

    r0
  end

  module WriteStmt0
    def label
      elements[0]
    end

    def t_write
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def io_control_spec_list
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[6]
    end
  end

  def _nt_write_stmt
    start_index = index
    if node_cache[:write_stmt].has_key?(index)
      cached = node_cache[:write_stmt][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r2 = _nt_label
    if r2
      r1 = r2
    else
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      r3 = _nt_t_write
      s0 << r3
      if r3
        r4 = _nt_t_paren_l
        s0 << r4
        if r4
          r5 = _nt_io_control_spec_list
          s0 << r5
          if r5
            r6 = _nt_t_paren_r
            s0 << r6
            if r6
              r8 = _nt_output_item_list
              if r8
                r7 = r8
              else
                r7 = instantiate_node(SyntaxNode,input, index...index)
              end
              s0 << r7
              if r7
                r9 = _nt_t_newline
                s0 << r9
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(Write_Stmt,input, i0...index, s0)
      r0.extend(WriteStmt0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:write_stmt][start_index] = r0

    r0
  end

end

class FortranParser < Treetop::Runtime::CompiledParser
  include Fortran
end


# paul.a.madden@noaa.gov
