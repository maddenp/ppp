grammar Fortran

  rule ac_do_variable
    # F90:R435

    scalar_int_variable
  end

  rule ac_implied_do
    # F90:R433

    t_paren_l ac_value_list t_comma ac_implied_do_control t_paren_r <AC_Implied_Do>
  end

  rule ac_implied_do_control
    # F90:R434

    ac_do_variable t_equal scalar_int_expr ( t_comma scalar_int_expr )? <AC_Implied_Do_Control>
  end

  rule ac_value
    # F90:R432

    ac_implied_do /
    expr !t_equal <AC_Value_Expr>
  end

  rule ac_value_list
    ac_value ( t_comma ac_value )* <AC_Value_List>
  end

  rule access_id
    # F90:R522

    use_name /
    generic_spec
  end

  rule access_id_list
    access_id access_id_list_pair* <Access_Id_List>
  end

  rule access_id_list_pair
    t_comma access_id <Access_Id_List_Pair>
  end

  rule access_spec
    # F90:R510

    t_public /
    t_private
  end

  rule access_stmt
    # F90:R521

    label:label_stmt? access_spec access_stmt_option? t_newline &{ |e| sp_access_stmt(e[1],e[2]) } <Access_Stmt>
  end

  rule access_stmt_option
    double_colon? access_id_list <Access_Stmt_Option>
  end

  rule action_stmt
    # F90:R216

    allocate_stmt /
    assignment_stmt /
    backspace_stmt /
    call_stmt /
    close_stmt /
    computed_goto_stmt /
    continue_stmt /
    cycle_stmt /
    deallocate_stmt /
    endfile_stmt /
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    if_stmt /
    inquire_stmt /
    nullify_stmt /
    open_stmt /
    pointer_assignment_stmt /
    print_stmt /
    read_stmt /
    return_stmt /
    rewind_stmt /
    stop_stmt /
    where_stmt /
    write_stmt /
    arithmetic_if_stmt /
    assign_stmt /
    assigned_goto_stmt /
    pause_stmt
  end

  rule action_term_do_construct
    # F90:R827

    label_do_stmt !{ |e| sp_dolabel_repeat? } do_body do_term_action_stmt <Action_Term_Do_Construct>
  end

  rule actual_arg
    # F90:R1213

    hollerith /
    expr /
    variable /
    procedure_name /
    alt_return_spec
  end

  rule actual_arg_spec
    # F90:R1211

    keyword_option actual_arg <Actual_Arg_Spec>
  end

  rule actual_arg_spec_list
    actual_arg_spec ( t_comma actual_arg_spec )* <Actual_Arg_Spec_List>
  end

  rule add_op
    # F90:R710

    t_plus /
    t_minus
  end

  rule add_operand
    # F90:R706
    #
    # Note: Left-recursive rule implied by standard:
    # ( add_operand mult_op)? mult_operand

    mult_operand ( mult_op add_operand )? <Add_Operand>
  end

  rule and_op
    # F90:R720

    ".and." <T>
  end

  rule allocatable_stmt
    # F90:R526

    label:label_stmt? t_allocatable double_colon? array_names_and_deferred_shape_spec_lists t_newline &{ |e| sp_allocatable_stmt(e[3]) } <Allocatable_Stmt>
  end

  rule allocate_lower_bound
    # F90:R627

    scalar_int_expr
  end

  rule allocate_object
    # F90:R625

    !( t_stat t_equal ) variable_name <Allocate_Object> /
    !( t_stat t_equal ) structure_component <Allocate_Object>
  end

  rule allocate_object_list
    allocate_object allocate_object_list_pair* <Allocate_Object_List>
  end

  rule allocate_object_list_pair
    t_comma allocate_object <Allocate_Object_List_Pair>
  end

  rule allocate_shape_spec
    # F90:R626

    allocate_shape_spec_option? allocate_upper_bound <Allocate_Shape_Spec>
  end

  rule allocate_shape_spec_option
    allocate_lower_bound t_colon <Allocate_Shape_Spec_Option>
  end

  rule allocate_shape_spec_list
    # F90:6.3.1

    allocate_shape_spec ( t_comma allocate_shape_spec )* <Allocate_Shape_Spec_List>
  end

  rule allocate_stat_construct
    t_comma t_stat t_equal stat_variable <Allocate_Stat_Construct>
  end

  rule allocate_stmt
    # F90:R622

    label:label_stmt? t_allocate t_paren_l allocation_list allocate_stat_construct? t_paren_r t_newline <Allocate_Stmt>
  end

  rule allocate_upper_bound
    # F90:R628

    scalar_int_expr
  end

  rule allocation
    # F90:R624

    allocate_object parenthesized_allocate_shape_spec_list? <Allocation>
  end

  rule allocation_list
    allocation ( t_comma allocation )* <Allocation_List>
  end

  rule alphanumeric_character
    # F90:R302

    t_letter /
    t_digit /
    t_underscore
  end

  rule alt_return_spec
    # F90:R1214

    t_star label_branch &{ |e| sp_alt_return_spec(e[1]) } <Alt_Return_Spec>
  end

  rule arithmetic_if_stmt
    # F90:R840

    label:label_stmt? t_if t_paren_l scalar_numeric_expr t_paren_r label_branch t_comma label_branch t_comma label_branch t_newline &{ |e| sp_arithmetic_if_stmt(e[5],e[7],e[9]) } <Arithmetic_If_Stmt>
  end

  rule array_constructor
    # F90:R431

    t_paren_l t_slash ac_value_list t_slash t_paren_r <Array_Constructor>
  end

  rule array_element
    # F90:R615

    data_ref
  end

  rule array_name
    # Multiple uses (not explicitly defined)

    name "" <Array_Name>
  end

  rule array_name_and_deferred_shape_spec_list
    array_name parenthesized_deferred_shape_spec_list? <Array_Name_And_Deferred_Shape_Spec_List>
  end

  rule array_name_and_deferred_shape_spec_list_pair
    t_comma array_name_and_deferred_shape_spec_list <Array_Name_And_Deferred_Shape_Spec_List_Pair>
  end

  rule array_name_and_spec
    array_name t_paren_l array_spec t_paren_r <Array_Name_And_Spec>
  end

  rule array_name_and_spec_pair
    t_comma array_name_and_spec <Array_Name_And_Spec_Pair>
  end

  rule array_names_and_deferred_shape_spec_lists
    array_name_and_deferred_shape_spec_list array_name_and_deferred_shape_spec_list_pair* <Array_Names_And_Deferred_Shape_Spec_Lists>
  end

  rule array_names_and_specs
    array_name_and_spec array_name_and_spec_pair* <Array_Names_And_Specs>
  end

  rule array_section
    # F90:R616

    data_ref &{ |e| sp_is_array?(e[0]) } substring_range_triplet? <Array_Section>
  end

  rule array_spec
    # F90:R512
    #
    # Note: Since e.g. "(:)" may indicate either an assumed-shape or a deferred-
    # shape array, which cannot be determined until all declarations have been
    # parsed, a generic "implicit" rule is recognized here. The implicit rule
    # cannot match an assumed-shape spec when a lower bound is specified, so a
    # final assumed_shape_spec_list choice is retained. Environment information
    # for a variable associated with an implicit_shape_spec_list is reconciled
    # later.

    assumed_size_spec "" <Array_Spec> /
    explicit_shape_spec_list "" <Array_Spec> /
    implicit_shape_spec_list "" <Array_Spec> /
    assumed_shape_spec_list "" <Array_Spec>
  end

  rule array_variable_name
    # Section 6 (not explicitly defined)

    variable_name &{ |e| sp_is_array?(e[0]) } <Array_Variable_Name>
  end

  rule assign_stmt
    # F90:R838

    label:label_stmt? t_assign label_assign t_to scalar_int_variable t_newline &{ |e| sp_assign_stmt(e[2],e[4]) } <Assign_Stmt>
  end

  rule assigned_goto_stmt
    # F90:R839

    label:label_stmt? t_goto scalar_int_variable t_comma? assigned_goto_stmt_label_list? t_newline &{ |e| sp_assigned_goto_stmt(e[2]) } <Assigned_Goto_Stmt>
  end

  rule assigned_goto_stmt_label_list
    t_comma? t_paren_l label_list t_paren_r <Assigned_Goto_Stmt_Label_List>
  end

  rule assignment_stmt
    # F90:R735

    label:label_stmt? variable t_equal expr t_newline <Assignment_Stmt>
  end

  rule assumed_shape_spec
    # F90:R516

    lower_bound? t_colon <Assumed_Shape_Spec>
  end

  rule assumed_shape_spec_list
    assumed_shape_spec assumed_shape_spec_list_pair* <Assumed_Shape_Spec_List>
  end

  rule assumed_shape_spec_list_pair
    t_comma assumed_shape_spec <Assumed_Shape_Spec_List_Pair>
  end

  rule assumed_size_spec
    # F90:R518

    assumed_size_spec_pair? lower_bound_pair? t_star <Assumed_Size_Spec>
  end

  rule assumed_size_spec_pair
    explicit_shape_spec_list t_comma <Assumed_Size_Spec_Pair>
  end

  rule attr_spec
    # F90:R503

    t_parameter "" <Attr_Spec_Parameter> /
    access_spec /
    t_allocatable "" <Attr_Spec_Allocatable> /
    t_dimension t_paren_l array_spec t_paren_r <Attr_Spec_Dimension> /
    t_external /
    t_intent t_paren_l intent_spec t_paren_r <Attr_Spec_Intent> /
    t_intrinsic /
    t_optional /
    t_pointer "" <Attr_Spec_Pointer> /
    t_save /
    t_target "" <Attr_Spec_Target>
  end

  rule attr_spec_list
    attr_spec attr_spec_list_pairs <Attr_Spec_List>
  end

  rule attr_spec_list_pair
    t_comma attr_spec <Attr_Spec_List_Pair>
  end

  rule attr_spec_list_pairs
    attr_spec_list_pair* <Attr_Spec_List_Pairs>
  end

  rule attr_spec_option
    t_comma attr_spec_list double_colon <Attr_Spec_Option> /
    double_colon
  end

  rule backspace_stmt
    # F90:R919

    label:label_stmt? t_backspace t_paren_l position_spec_list t_paren_r t_newline <Backspace_Stmt_1> /
    label:label_stmt? t_backspace external_file_unit t_newline <Backspace_Stmt_2>
  end

  rule binary_constant
    # F90:R408

    &"b" t_letter t_apostrophe t_binary+ t_apostrophe <Binary_Constant> /
    &"b" t_letter t_quotemark t_binary+ t_quotemark <Binary_Constant>
  end

  rule blank_interp_edit_desc
    # F90:R1015

    "bn" <T> /
    "bz" <T>
  end

  rule block
    # F90:R801

    execution_part_construct
  end

  rule block_data
    # F90:R1110

    block_data_stmt specification_part? end_block_data_stmt &{ |e| sp_block_data } <Block_Data>
  end

  rule block_data_name
    # F90:11.4 (not explicitly defined)

    name "" <Block_Data_Name>
  end

  rule block_data_stmt
    # F90:R1111

    label:label_stmt? t_block t_data block_data_name? t_newline &{ |e| sp_block_data_stmt } <Block_Data_Stmt>
  end

  rule block_do_construct
    # F90:R817
    #
    # Note: For this rule to match, the label (if any) on the do_stmt cannot be
    # a repeat, as that would require more than one end-do-stmt with the same
    # label, which is not permitted.

    do_stmt !{ |e| sp_dolabel_repeat? } do_block end_do <Block_Do_Construct_Main>
  end

  rule boz_literal_constant
    # F90:R407

    binary_constant /
    octal_constant /
    hex_constant
  end

  rule call_stmt
    # F90:R1210

    label:label_stmt? t_call subroutine_name parenthesized_args? t_newline <Call_Stmt>
  end

  rule case_construct
    # F90:R808

    select_case_stmt case_stmt_construct_block end_select_stmt <Case_Construct>
  end

  rule case_construct_name
    name "" <Case_Construct_Name>
  end

  rule case_construct_name_pair
    case_construct_name t_colon <Case_Construct_Name_Pair>
  end

  rule case_expr
    # F90:R812

    scalar_int_expr /
    scalar_char_expr /
    scalar_logical_expr
  end

  rule case_selector
    # F90:R813

    case_selector_range /
    t_default
  end

  rule case_selector_range
    t_paren_l case_value_range_list t_paren_r <Case_Selector_Range>
  end

  rule case_stmt
    # F90:R810

    label:label_stmt? t_case case_selector case_construct_name? t_newline <Case_Stmt>
  end

  rule case_stmt_construct
    case_stmt block <Case_Stmt_Construct>
  end

  rule case_stmt_construct_block
    case_stmt_construct* <Case_Stmt_Construct_Block>
  end

  rule case_value
    # F90:R815

    scalar_int_initialization_expr /
    scalar_char_initialization_expr /
    scalar_logical_initialization_expr
  end

  rule case_value_range
    # F90:R814

    t_colon case_value <Case_Value_Range_1> /
    case_value t_colon case_value <Case_Value_Range_2> /
    case_value t_colon <Case_Value_Range_3> /
    case_value
  end

  rule case_value_range_list
    case_value_range ( t_comma case_value_range )* <Case_Value_Range_List>
  end

  rule char_expr
    # F90:R726

    expr
  end

  rule char_initialization_expr
    # F90:R731

    char_expr
  end

  rule char_length
    # F90:R508

    t_paren_l type_param_value t_paren_r <Char_Length_1> /
    scalar_int_literal_constant
  end

  rule char_length_pair
    t_star char_length <Char_Length_Pair>
  end

  rule char_literal_constant
    # F90:R420

    char_literal_constant_prefix? char_literal_constant_sq <Char_Literal_Constant_Sq> /
    char_literal_constant_prefix? char_literal_constant_dq <Char_Literal_Constant_Dq>
  end

  rule char_literal_constant_dq
    t_quotemark ( !t_quotemark rep_char )* t_quotemark <Char_Literal_Constant_Quoted>
  end

  rule char_literal_constant_prefix
    kind_param t_underscore <Char_Literal_Constant_Prefix>
  end

  rule char_literal_constant_sq
    t_apostrophe ( !t_apostrophe rep_char )* t_apostrophe <Char_Literal_Constant_Quoted>
  end

  rule char_selector
    # F90:R506

    length_selector /
    t_paren_l len_pair type_param_value t_comma kind_pair scalar_int_initialization_expr t_paren_r <Char_Selector_1> /
    t_paren_l type_param_value t_comma kind_pair? scalar_int_initialization_expr t_paren_r <Char_Selector_2> /
    t_paren_l kind_pair scalar_int_initialization_expr char_selector_option? t_paren_r <Char_Selector_3>
  end

  rule char_selector_option
    t_comma len_pair type_param_value <Char_Selector_Option>
  end

  rule char_string_edit_desc
    # F90:R1016

    hollerith /
    char_literal_constant
  end

  rule char_variable
    # F90:R605

    variable
  end

  rule character
    # F90:R301

    alphanumeric_character /
    special_character
  end

  rule close_spec
    # F90:R908

    io_spec_iostat /
    io_spec_err /
    t_status t_equal scalar_default_char_expr <Close_Spec_1> /
    close_spec_option? external_file_unit <Close_Spec_2>
  end

  rule close_spec_option
    t_unit t_equal <Close_Spec_Option>
  end

  rule close_spec_list
    close_spec close_spec_list_pair* <Close_Spec_List>
  end

  rule close_spec_list_pair
    t_comma close_spec <Close_Spec_List_Pair>
  end

  rule close_stmt
    # F90:R907

    label:label_stmt? t_close t_paren_l close_spec_list t_paren_r t_newline <Close_Stmt>
  end

  rule common_block_name
    # Multiple uses (not explicitly defined)

    name "" <Common_Block_Name>
  end

  rule common_block_name_and_object_list
    t_comma? common_block_name_triplet common_block_object_list <Common_Block_Name_And_Object_List>
  end

  rule common_block_name_and_object_lists
    common_block_name_and_object_list* <Common_Block_Name_And_Object_Lists>
  end

  rule common_block_name_triplet
    t_slash common_block_name? t_slash <Common_Block_Name_Triplet>
  end

  rule common_block_object
    # F90:R549

    variable_name common_block_object_explicit_shape_spec_list? <Common_Block_Object>
  end

  rule common_block_object_explicit_shape_spec_list
    parenthesized_explicit_shape_spec_list
  end

  rule common_block_object_list
    common_block_object common_block_object_pairs <Common_Block_Object_List>
  end

  rule common_block_object_pair
    t_comma common_block_object <Common_Block_Object_Pair>
  end

  rule common_block_object_pairs
    common_block_object_pair* <Common_Block_Object_Pairs>
  end

  rule common_stmt
    # F90:R548

    label:label_stmt? t_common common_block_name_triplet? common_block_object_list common_block_name_and_object_lists t_newline <Common_Stmt>
  end

  rule complex_literal_constant
    # F90:R417

    t_paren_l real_part t_comma imag_part t_paren_r <Complex_Literal_Constant>
  end

  rule component_array_spec
    # F90:R428

    explicit_shape_spec_list /
    deferred_shape_spec_list
  end

  rule component_attr_spec
    # F90:R427 + F95:R426 + F03:R441

    t_pointer /
    t_dimension t_paren_l component_array_spec t_paren_r <Component_Attr_Spec_1> /
    t_allocatable
  end

  rule component_attr_spec_list
    component_attr_spec ( t_comma component_attr_spec )* <Component_Attr_Spec_List>
  end

  rule component_attr_spec_list_option
    t_comma component_attr_spec_list <Compoent_Attr_Spec_List_Option>
  end

  rule component_decl
    # F90:R429 + F95:R428

    component_name parenthesized_component_array_spec? ( t_star char_length )? component_initialization? <Component_Decl>
  end

  rule component_decl_list
    component_decl ( t_comma component_decl )* <Component_Decl_List>
  end

  rule component_def_stmt
    # F90:R426

    label:label_stmt? type_spec component_def_stmt_option? component_decl_list t_newline <Component_Def_Stmt>
  end

  rule component_def_stmt_option
    component_attr_spec_list_option? double_colon <Component_Def_Stmt_Option>
  end

  rule component_def_stmts
    component_def_stmt+ <Component_Def_Stmts>
  end

  rule component_initialization
    # F95:R429

    t_equal initialization_expr <Component_Initialization_1> /
    t_point null_function_ref <Component_Initialization_2>
  end

  rule component_name
    # F90:4.4.1 (not explicitly defined)

    name "" <Component_Name>
  end

  rule computed_goto_stmt
    # F90:R837

    label:label_stmt? t_goto t_paren_l label_list t_paren_r t_comma? scalar_int_expr t_newline <Computed_Goto_Stmt>
  end

  rule concat_op
    # F90:R712

    "//" <T>
  end

  rule connect_spec
    # F90:R905

    io_spec_iostat /
    io_spec_err /
    t_file t_equal file_name_expr <Connect_Spec_File_Name> /
    t_status t_equal scalar_default_char_expr <Connect_Spec_Status> /
    t_access t_equal scalar_default_char_expr <Connect_Spec_Access> /
    t_form t_equal scalar_default_char_expr <Connect_Spec_Form> /
    t_recl t_equal scalar_int_expr <Connect_Spec_Recl> /
    t_blank t_equal scalar_default_char_expr <Connect_Spec_Blank> /
    t_position t_equal scalar_default_char_expr <Connect_Spec_Position> /
    t_action t_equal scalar_default_char_expr <Connect_Spec_Action> /
    t_delim t_equal scalar_default_char_expr <Connect_Spec_Delim> /
    t_pad t_equal scalar_default_char_expr <Connect_Spec_Pad> /
    connect_spec_external_file_unit_option? external_file_unit <Connect_Spec_External_File_Unit>
  end

  rule connect_spec_external_file_unit_option
    t_unit t_equal <Connect_Spec_External_File_Unit_Option>
  end

  rule connect_spec_list
    connect_spec connect_spec_list_pair* <Connect_Spec_List>
  end

  rule connect_spec_list_pair
    t_comma connect_spec <Connect_Spec_List_Pair>
  end

  rule constant
    # F90:R305

    literal_constant /
    named_constant
  end

  rule constant_subobject
    # F90:R702

    subobject
  end

  rule contains_stmt
    # F90:R1225

    label:label_stmt? t_contains t_newline <Contains_Stmt>
  end

  rule continue_stmt
    # F90:R841

    label:label_stmt? t_continue t_newline <Continue_Stmt>
  end

  rule control_edit_desc
    # F90:R1010

    position_edit_desc /
    blank_interp_edit_desc /
    sign_edit_desc /
    int_literal_constant? t_slash <Control_Edit_Desc_Slash> /
    t_colon /
    signed_int_literal_constant? &"p" t_letter <Control_Edit_Desc_P>
  end

  rule cycle_stmt
    # F90:R834

    label:label_stmt? t_cycle do_construct_name? t_newline <Cycle_Stmt>
  end

  rule data_edit_desc
    # F90:R1005
    data_edit_desc_1 int_literal_constant data_edit_desc_1_option? <Data_Edit_Desc_1> /
    data_edit_desc_2 int_literal_constant t_dot int_literal_constant <Data_Edit_Desc_2> /
    data_edit_desc_3 int_literal_constant t_dot int_literal_constant data_edit_desc_3_option? <Data_Edit_Desc_3> /
    &"l" t_letter int_literal_constant <Data_Edit_Desc_L> /
    &"a" t_letter int_literal_constant? <Data_Edit_Desc_A>
  end

  rule data_edit_desc_1
    "i" <T> /
    "b" <T> /
    "o" <T> /
    "z" <T>
  end

  rule data_edit_desc_1_option
    t_dot int_literal_constant <Data_Edit_Desc_1_Option>
  end

  rule data_edit_desc_2
    "f" <T> /
    "d" <T>
  end

  rule data_edit_desc_3
    "en" <T> /
    "es" <T> /
    "e" <T> /
    "g" <T>
  end

  rule data_edit_desc_3_option
    &"e" t_letter int_literal_constant <Data_Edit_Desc_3_Option>
  end

  rule data_i_do_object
    # F90:R536

    array_element !t_equal <Data_I_Do_Object_1> /
    scalar_structure_component !t_equal <Data_I_Do_Object_2> /
    data_implied_do
  end

  rule data_i_do_object_list
    data_i_do_object ( t_comma data_i_do_object )* <Data_I_Do_Object_List>
  end

  rule data_i_do_variable
    # F90:R537

    scalar_int_variable
  end

  rule data_implied_do
    # F90:R535

    t_paren_l data_i_do_object_list t_comma data_i_do_variable t_equal scalar_int_expr t_comma scalar_int_expr data_implied_do_option t_paren_r <Data_Implied_Do>
  end

  rule data_implied_do_option
    ( t_comma scalar_int_expr )* <Data_Implied_Do_Option>
  end

  rule data_ref
    # F90:R612

    part_ref data_ref_option* <Data_Ref>
  end

  rule data_ref_option
    t_percent part_ref <Data_Ref_Option>
  end

  rule data_stmt
    # F90:R529

    label:label_stmt? t_data data_stmt_set_list t_newline <Data_Stmt>
  end

  rule data_stmt_constant
    # F90:R533

    hollerith /
    signed_real_literal_constant /
    signed_int_literal_constant /
    boz_literal_constant /
    structure_constructor /
    scalar_constant
  end

  rule data_stmt_object
    # F90:R531

    variable /
    data_implied_do
  end

  rule data_stmt_object_list
    data_stmt_object ( t_comma data_stmt_object )* <Data_Stmt_Object_List>
  end

  rule data_stmt_repeat
    # F90:R534

    scalar_int_constant
  end

  rule data_stmt_repeat_pair
    data_stmt_repeat t_star <Data_Stmt_Repeat_Pair>
  end

  rule data_stmt_set
    # F90:R530

    data_stmt_object_list t_slash data_stmt_value_list t_slash <Data_Stmt_Set>
  end

  rule data_stmt_set_list
    data_stmt_set data_stmt_set_list_pairs <Data_Stmt_Set_List>
  end

  rule data_stmt_set_list_pair
    t_comma? data_stmt_set <Data_Stmt_Set_List_Pair>
  end

  rule data_stmt_set_list_pairs
    data_stmt_set_list_pair* <Data_Stmt_Set_List_Pairs>
  end

  rule data_stmt_value
    # F90:R531

    data_stmt_repeat_pair? data_stmt_constant <Data_Stmt_Value>
  end

  rule data_stmt_value_list
    data_stmt_value ( t_comma data_stmt_value )* <Data_Stmt_Value_List>
  end

  rule deallocate_stmt
    # F90:R631

    label:label_stmt? t_deallocate t_paren_l allocate_object_list allocate_stat_construct? t_paren_r t_newline <Deallocate_Stmt>
  end

  rule declaration_construct
    # F90:R207

    derived_type_def /
    interface_block /
    type_declaration_stmt /
    specification_stmt /
    parameter_stmt /
    format_stmt /
    entry_stmt /
    stmt_function_stmt !{ |e| sp_is_array?(e[0]) } <Declaration_Construct_Stmt_Function_Stmt> /
    directive
  end

  rule declaration_constructs
    declaration_construct* <Declaration_Constructs>
  end

  rule default_char_variable
    # F90:R606

    variable &{ |e| sp_default_char_variable?(e[0]) } <Default_Char_Variable>
  end

  rule default_char_expr
    # F90:R727

    expr
  end

  rule default_int_variable
    # F90:R608

    variable
  end

  rule default_logical_variable
    # F90:R604

    variable
  end

  rule deferred_shape_spec
    # F90:R517

    t_colon "" <Deferred_Shape_Spec>
  end

  rule deferred_shape_spec_list
    deferred_shape_spec deferred_shape_spec_list_pair* <Deferred_Shape_Spec_List>
  end

  rule deferred_shape_spec_list_pair
    t_comma deferred_shape_spec <Deferred_Shape_Spec_List_Pair>
  end

  rule defined_binary_op
    # F90:R724

    t_dot t_letter letter_sequence t_dot <Defined_Binary_Op>
  end

  rule defined_operator
    # F90:R311

    defined_unary_op /
    defined_binary_op /
    extended_intrinsic_op
  end

  rule defined_unary_op
    # F90:R704

    !( intrinsic_operator / logical_literal_constant ) t_dot t_letter letter_sequence t_dot <Defined_Unary_Op>
  end

  rule derived_type_def
    # F90:R422

    derived_type_stmt private_sequence_stmts component_def_stmts end_type_stmt &{ |e| sp_derived_type_def(e[0]) } <Derived_Type_Def>
  end

  rule derived_type_stmt
    # F90:R424

    label:label_stmt? t_type derived_typeaccess_spec? type_name t_newline <Derived_Type_Stmt>
  end

  rule derived_typeaccess_spec
    derived_typeaccess_spec_option? double_colon <Derived_Typeaccess_Spec>
  end

  rule derived_typeaccess_spec_option
    t_comma access_spec <Derived_Typeaccess_Spec_Option>
  end

  rule digit_string
    # F90:R402

    t_digit+ <Digit>
  end

  rule dimension_stmt
    # F90:R525

    label:label_stmt? t_dimension double_colon? array_names_and_specs t_newline &{ |e| sp_dimension_stmt(e[3]) } <Dimension_Stmt>
  end

  rule directive
    # Note: Any "comment" not stripped out during normalization is a directive.

    "!" character+ t_newline <Directive>
  end

  rule do_block
    # F90:R823

    block
  end

  rule do_body
    # F90:R828

    execution_part_construct "" <Do_Body>
  end

  rule do_construct
    # F90:R816
    #
    # Note: When either option is matched, the appropriate label-popping method
    # should be called. See those methods for more information.

    nonblock_do_construct &{ |e| sp_dolabel_pop } <Nonblock_Do_Construct> /
    block_do_construct &{ |e| sp_dolabel_pop } <Block_Do_Construct>
  end

  rule do_construct_name
    # F90:8.1.4.1.1 (not explicitly defiend)

    name "" <Do_Construct_Name>
  end

  rule do_construct_name_label
    do_construct_name t_colon <Do_Construct_Name_Label>
  end

  rule do_stmt
    # F90:R818

    label_do_stmt /
    nonlabel_do_stmt
  end

  rule do_term_action_stmt
    # F90:R829

    !do_term_action_stmt_disallowed action_stmt &{ |e| sp_nonblock_do_end?(e[1]) } <Do_Term_Action_Stmt>
  end

  rule do_term_action_stmt_disallowed
    arithmetic_if_stmt /
    assigned_goto_stmt /
    continue_stmt /
    cycle_stmt /
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    return_stmt /
    stop_stmt
  end

  rule do_term_shared_stmt
    # F90:R833

    !do_term_shared_stmt_disallowed action_stmt &{ |e| sp_nonblock_do_end?(e[1]) } <Do_Term_Shared_Stmt>
  end

  rule do_term_shared_stmt_disallowed
    arithmetic_if_stmt /
    assigned_goto_stmt /
    cycle_stmt /
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    return_stmt /
    stop_stmt
  end

  rule do_variable
    # F90:R822

    scalar_variable
  end

  rule double_colon
    t_colon t_colon <Double_Colon>
  end

  rule dummy_arg
    # F90:R1221

    dummy_arg_name /
    t_star
  end

  rule dummy_arg_list
    dummy_arg dummy_arg_list_pair* <Dummy_Arg_List>
  end

  rule dummy_arg_list_pair
    t_comma dummy_arg <Dummy_Arg_List_Pair>
  end

  rule dummy_arg_list_option
    t_paren_l dummy_arg_list? t_paren_r <Dummy_Arg_List_Option>
  end

  rule dummy_arg_name
    # Multiple uses (not explicitly defined)

    name "" <Dummy_Arg_Name>
  end

  rule dummy_arg_name_list
    dummy_arg_name dummy_arg_name_list_pair* <Dummy_Arg_Name_List>
  end

  rule dummy_arg_name_list_pair
    t_comma dummy_arg_name <Dummy_Arg_Name_List_Pair>
  end

  rule else_construct
    else_stmt block <Else_Construct>
  end

  rule else_if_construct
    else_if_construct_element+ <Else_If_Construct>
  end

  rule else_if_construct_element
    else_if_stmt block <Else_If_Construct_Element>
  end

  rule else_if_stmt
    # F90:R804
    #
    # Note: The negagive lookahead assertion here enables parsing code like:
    #
    #   if_label: if (.false.) then
    #     print *,1
    #   else if_label
    #     print *,2
    #   end if if_label
    #
    # After normalization, line 3 reads "elseif_label". Without the negative
    # lookahead assertion, and due to the packrat nature of PEG parsers, the
    # characters 'elseif' are irrevocably recognized using rule t_elseif, and
    # a parse failure follows, as '_label' is then unexpected.

    label:label_stmt? !( t_else if_construct_name !t_paren_l ) t_elseif t_paren_l scalar_logical_expr t_paren_r t_then if_construct_name? t_newline <Else_If_Stmt>
  end

  rule else_stmt
    # F90:R805

    label:label_stmt? t_else if_construct_name? t_newline <Else_Stmt>
  end

  rule elsewhere_construct
    elsewhere_stmt where_assignment_stmt_block <Elsewhere_Construct>
  end

  rule elsewhere_stmt
    # F90:R742

    label:label_stmt? t_elsewhere t_newline <Elsewhere_Stmt>
  end

  rule end_block_data_option
    t_block t_data block_data_name? <End_Block_Data_Option>
  end

  rule end_block_data_stmt
    # F90:R1112

    label:label_stmt? t_end end_block_data_option? t_newline <End_Block_Data_Stmt>
  end

  rule end_do
    # F90:R824

    end_do_stmt /
    end_do_continue_stmt
  end

  rule end_do_continue_stmt
    label:label_stmt? t_continue t_newline <End_Do_Stmt>
  end

  rule end_do_stmt
    # F90:R825

    label:label_stmt? t_enddo do_construct_name? t_newline <End_Do_Stmt>
  end

  rule end_function_option
    t_function function_name? <End_Function_Option>
  end

  rule end_function_stmt
    # F90:R1218

    label:label_stmt? t_end end_function_option? t_newline <End_Function_Stmt>
  end

  rule end_if_stmt
    # F90:R806

    label:label_stmt? t_endif if_construct_name? t_newline <End_If_Stmt>
  end

  rule end_interface_stmt
    # F90:R1203 + F95:R1204

    label:label_stmt? t_end t_interface generic_spec? t_newline <End_Interface_Stmt>
  end

  rule end_module_option
    t_module module_name? <End_Module_Option>
  end

  rule end_module_stmt
    # F90:R1106

    label:label_stmt? t_end end_module_option? t_newline <End_Module_Stmt>
  end

  rule end_program_stmt
    # F90:R1103

    label:label_stmt? t_end !end_program_stmt_disallowed t_program? program_name? t_newline? <End_Program_Stmt>
  end

  rule end_program_stmt_disallowed
    t_block /
    t_function /
    t_interface /
    t_module /
    t_select /
    t_subroutine /
    t_type
  end

  rule end_select_stmt
    # F90:R811

    label:label_stmt? t_end t_select case_construct_name? t_newline <End_Select_Stmt>
  end

  rule end_subroutine_stmt
    # F90:R1222

    label:label_stmt? t_end end_subroutine_option? t_newline <End_Subroutine_Stmt>
  end

  rule end_subroutine_option
    t_subroutine subroutine_name? <End_Subroutine_Option>
  end

  rule end_type_stmt
    # F90:R415

    label:label_stmt? t_end t_type type_name? t_newline <End_Type_Stmt>
  end

  rule end_where_stmt
    # F90:R743

    label:label_stmt? t_endwhere t_newline <End_Where_Stmt>
  end

  rule endfile_stmt
    # F90:R920

    label:label_stmt? t_endfile t_paren_l position_spec_list t_paren_r t_newline <Endfile_Stmt_1> /
    label:label_stmt? t_endfile external_file_unit t_newline <Endfile_Stmt_2>
  end

  rule entity_decl
    # F90:R504 + F95:R504
    #
    # Note: Since all but the first element of each component list is optional,
    # the parser cannot distinguish between, e.g. "integer::f" where f is an
    # integer scalar, and "integer::f" where f is a function. If the function
    # has an explicit interface, it may be possible to disambiguate after
    # parsing; if not, it may only be possible to analyze actual uses of the
    # name to make a determination. If the name is never used, disambiguation
    # may be impossible, but it probably doesn't matter. Until it proves
    # problematic, allow uses like the above example to match the first choice.

    object_name entity_decl_array_spec? char_length_pair? initialization? <Entity_Decl_1> /
    function_name char_length_pair? <Entity_Decl_2>
  end

  rule entity_decl_array_spec
    t_paren_l array_spec t_paren_r <Entity_Decl_Array_Spec>
  end

  rule entity_decl_list
    entity_decl entity_decl_list_pairs <Entity_Decl_List>
  end

  rule entity_decl_list_pair
    t_comma entity_decl <Entity_Decl_List_Pair>
  end

  rule entity_decl_list_pairs
    entity_decl_list_pair* <Entity_Decl_List_Pairs>
  end

  rule entry_name
    # F90:12.5.2.5 (not explicitly defined)

    name "" <Entry_Name>
  end

  rule entry_stmt
    # F90:R1223

    label:label_stmt? t_entry entry_name dummy_arg_list_option? result_option? t_newline <Entry_Stmt>
  end

  rule equiv_op
    # F90:R722

    ".eqv." <T> /
    ".neqv." <T>
  end

  rule equiv_operand
    # F90:R715

    not_op? level_4_expr <Equiv_Operand>
  end

  rule equivalence_object
    # F90:R547

    substring /
    array_element /
    variable_name
  end

  rule equivalence_object_list
    equivalence_object equivalence_object_list_option? <Equivalence_Object_List>
  end

  rule equivalence_object_list_option
    t_comma equivalence_object <Equivalence_Object_List>
  end

  rule equivalence_set
    # F90:R546

    t_paren_l equivalence_object t_comma equivalence_object_list t_paren_r <Equivalence_Set>
  end

  rule equivalence_set_list
    equivalence_set ( t_comma equivalence_set )* <Equivalence_Set_List>
  end

  rule equivalence_stmt
    # F90:R545

    label:label_stmt? t_equivalence equivalence_set_list t_newline <Equivalence_Stmt>
  end

  rule executable_construct
    # F90:R215

    executable_construct_action_stmt /
    case_construct /
    do_construct /
    if_construct /
    where_construct /
    directive
  end

  rule executable_construct_action_stmt
    !execution_part_disallowed action_stmt !{ |e| sp_nonblock_do_end?(e[1]) } <Executable_Construct_Action_Stmt>
  end

  rule execution_part
    # F90:R208

    executable_construct execution_part_construct <Execution_Part>
  end

  rule execution_part_disallowed
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt
  end

  rule execution_part_construct
    # F90:R209

    execution_part_construct_item* <Execution_Part_Construct>
  end

  rule execution_part_construct_item
    executable_construct /
    format_stmt /
    data_stmt /
    entry_stmt
  end

  rule exit_stmt
    # F90:R835

    label:label_stmt? t_exit do_construct_name? t_newline <Exit_Stmt>
  end

  rule explicit_shape_spec
    # F90:R513

    lower_bound_pair? upper_bound <Explicit_Shape_Spec>
  end

  rule explicit_shape_spec_list
    explicit_shape_spec explicit_shape_spec_list_pair* <Explicit_Shape_Spec_List>
  end

  rule explicit_shape_spec_list_pair
    t_comma explicit_shape_spec <Explicit_Shape_Spec_List_Pair>
  end

  rule exponent
    # F90:R416

    signed_digit_string
  end

  rule exponent_letter
    # F90:R415

    [ed] <T>
  end

  rule expr
    # F90:R723
    #
    # Note: Left-recursive rule implied by standard:
    # ( expr defined_binary_op )? level_5_expr

    level_5_expr ( defined_binary_op expr )? <Expr>
  end

  rule expr_list
    expr ( t_comma expr )* <Expr_List>
  end

  rule extended_intrinsic_op
    # F90:R312

    intrinsic_operator
  end

  rule external_file_unit
    # F90:R902

    scalar_int_expr
  end

  rule external_name
    # F90:12.3.2.2

    name "" <External_Name>
  end

  rule external_name_list
    external_name ( t_comma external_name )* <External_Name_List>
  end

  rule external_stmt
    # F90:R1207

    label:label_stmt? t_external external_name_list t_newline <External_Stmt>
  end

  rule external_subprogram
    # F90:R203

    subroutine_subprogram &{ |e| sp_env_pullup(e[0]) } <External_Subprogram_Subroutine> /
    function_subprogram &{ |e| sp_env_pullup(e[0]) } <External_Subprogram_Function>
  end

  rule file_name_expr
    # F90:R906

    scalar_default_char_expr
  end

  rule format
    # F90:R913

    default_char_expr /
    label_format /
    t_star /
    scalar_default_int_variable
  end

  rule format_item
    # F90:R1003

    int_literal_constant? data_edit_desc <Format_Item_Data_Edit_Desc> /
    control_edit_desc /
    char_string_edit_desc /
    int_literal_constant? format_specification <Format_Item_Format_Specification>
  end

  rule format_item_list
    # F90:R1003

    format_item format_item_list_option* <Format_Item_List>
  end

  rule format_item_list_option
    t_comma format_item <Format_Item_List_Option>
  end

  rule format_specification
    # F90:R1002

    t_paren_l format_item_list* t_paren_r <Format_Specification>
  end

  rule format_stmt
    # F90:R1001

    label_format t_format format_specification t_newline <Format_Stmt>
  end

  rule function_name
    # Multiple uses (not explicitly defined)

    name &{ |e| sp_is_function_name?(e[0]) } <Function_Name>
  end

  rule function_prefix
    # F90:R1217 + F95:1219

    function_prefix_option+ <Function_Prefix>
  end

  rule function_prefix_option
    type_spec /
    t_elemental /
    t_pure /
    t_recursive
  end

  rule function_reference
    # F90:R1209

    function_name t_paren_l actual_arg_spec_list? t_paren_r <Function_Reference>
  end

  rule function_stmt
    # F90:R1216

    label:label_stmt? function_prefix? t_function function_name t_paren_l dummy_arg_name_list? t_paren_r result_option? t_newline &{ |e| sp_function_stmt(e[3],e[5],e[7]) } <Function_Stmt>
  end

  rule function_subprogram
    # F90:R1215

    function_stmt specification_part? execution_part? internal_subprogram_part? end_function_stmt &{ |e| sp_function_subprogram(e[0]) } <Function_Subprogram>
  end

  rule generic_name
    # F90:12.3.2.1 (not explicitly defined)

    name "" <Generic_Name>
  end

  rule generic_spec
    # F90:R1206

    generic_spec_option /
    generic_name
  end

  rule generic_spec_option_1
    t_operator t_paren_l defined_operator t_paren_r <Generic_Spec>
  end

  rule generic_spec_option_2
    t_assignment t_paren_l t_equal t_paren_r <Generic_Spec>
  end

  rule generic_spec_option
    generic_spec_option_1 /
    generic_spec_option_2
  end

  rule goto_stmt
    # F90:R836

    label:label_stmt? t_goto label_branch t_newline &{ |e| sp_goto_stmt(e[2]) } <Goto_Stmt>
  end

  rule hex_constant
    # F90:R410

    hex_constant_prefix t_apostrophe hex_digit+ t_apostrophe <Hex_Constant> /
    hex_constant_prefix t_quotemark hex_digit+ t_quotemark <Hex_Constant>
  end

  rule hex_constant_prefix

    # Note: x is NON-CONFORMANT

    &"z" t_letter <Hex_Constant_Prefix_Z> /
    &"x" t_letter <Hex_Constant_Prefix_X>
  end

  rule hex_digit
    # F90:R411

    [0123456789aAbBcCdDeEfF] <T>
  end

  rule hollerith
    digit_string &"h" t_letter &{ |e| sp_hollerith_set_length(e[0]) } hollerith_string <Hollerith>
  end

  rule hollerith_string
    &{ |e| sp_hollerith_reset_count } ( rep_char &{ |e| sp_hollerith_check_count } )+ <Hollerith_String>
  end

  rule if_construct
    # F90:R802
    #
    # Note: if_then_construct, else_if_construct and else_construct added for
    # clarity, not specified in standard.

    if_then_construct else_if_construct? else_construct? end_if_stmt <If_Construct>
  end

  rule if_construct_name
    # Multiple uses (not explicitly defined)

    name "" <If_Construct_Name>
  end

  rule if_construct_name_label
    if_construct_name t_colon <If_Construct_Name_Label>
  end

  rule if_stmt
    # F90:R807

    label:label_stmt? t_if t_paren_l scalar_logical_expr t_paren_r action_stmt <If_Stmt>
  end

  rule if_then_construct
    if_then_stmt block <If_Then_Construct>
  end

  rule if_then_stmt
    # F90:R803

    label:label_stmt? if_construct_name_label? t_if t_paren_l scalar_logical_expr t_paren_r t_then t_newline <If_Then_Stmt>
  end

  rule imag_part
    # F90:R419

    signed_real_literal_constant /
    signed_int_literal_constant
  end

  rule implicit_part
    # F90:R205
    #
    # Note: The standard insists that the last statement in implicit_part be
    # an implicit_stmt but, given that this seems unlikely to affect parsing,
    # and the availibility of 3rd-party syntax-checking compilers, it is not
    # enforced here.

    implicit_part_stmt+ <Implicit_Part>
  end

  rule implicit_part_stmt
    # F90:R206

    implicit_stmt /
    format_stmt /
    parameter_stmt /
    entry_stmt
  end

  rule implicit_shape_spec
    # Note: See also rule array_spec.

    t_colon "" <Implicit_Shape_Spec>
  end

  rule implicit_shape_spec_list
    implicit_shape_spec implicit_shape_spec_list_pair* !t_comma <Implicit_Shape_Spec_List>
  end

  rule implicit_shape_spec_list_pair
    t_comma implicit_shape_spec <Implicit_Shape_Spec_List_Pair>
  end

  rule implicit_spec
    # F90:R541

    type_spec_with_kind_selector t_paren_l letter_spec_list t_paren_r <Implicit_Spec_1> /
    type_spec_without_kind_selector t_paren_l letter_spec_list t_paren_r <Implicit_Spec_2>
  end

  rule implicit_spec_list
    implicit_spec implicit_spec_list_pair* <Implicit_Spec_List>
  end

  rule implicit_spec_list_pair
    t_comma implicit_spec <Implicit_Spec_List_Pair>
  end

  rule implicit_stmt
    # F90:R540

    label:label_stmt? t_implicit t_none t_newline <Implicit_None_Stmt> /
    label:label_stmt? t_implicit implicit_spec_list t_newline <Implicit_Stmt>
  end

  rule initialization
    # F95:R505

    t_equal initialization_expr <Initialization_1> /
    t_point null_function_ref <Initialization_2>
  end

  rule initialization_expr
    # F90:R730

    expr
  end

  rule inner_shared_do_construct
    # F90:R832
    #
    # Note: For this rule to match, the label on the label_do_stmt must match
    # that of the enclosing outer_shared_do_construct, which has already been
    # pushed onto the stack.

    label_do_stmt &{ |e| sp_dolabel_repeat? } do_body do_term_shared_stmt <Inner_Shared_Do_Construct>
  end

  rule input_item
    # F90:R914

    io_implied_do /
    variable
  end

  rule input_item_list
    # F90:9.4.2

    input_item input_item_list_pair* <Input_Item_List>
  end

  rule input_item_list_pair
    t_comma input_item <Input_Item_List_Pair>
  end

  rule inquire_spec
    # F90:R924

    external_file_unit &t_comma <Inquire_Spec_External_File_Unit> /
    t_unit t_equal external_file_unit <Inquire_Spec_Unit> /
    t_file t_equal file_name_expr <Inquire_Spec_File> /
    io_spec_iostat /
    io_spec_err /
    io_spec_exist /
    io_spec_opened /
    io_spec_number /
    io_spec_named /
    io_spec_name /
    io_spec_access /
    io_spec_sequential /
    io_spec_direct /
    io_spec_form /
    io_spec_formatted /
    io_spec_unformatted /
    io_spec_recl /
    io_spec_nextrec /
    io_spec_blank /
    io_spec_position /
    io_spec_action /
    io_spec_read /
    io_spec_write /
    io_spec_readwrite /
    io_spec_delim /
    io_spec_pad
  end

  rule inquire_spec_list
    inquire_spec ( t_comma inquire_spec )* <Inquire_Spec_List>
  end

  rule inquire_stmt
    # F90:R923

    label:label_stmt? t_inquire t_paren_l inquire_spec_list t_paren_r t_newline <Inquire_Stmt_1> /
    label:label_stmt? t_inquire t_paren_l t_iolength t_equal scalar_default_int_variable t_paren_r output_item_list t_newline <Inquire_Stmt_2>
  end

  rule int_expr
    # F90:R728

    expr
  end

  rule int_initialization_expr
    # F90:R732

    int_expr
  end

  rule int_literal_constant
    # F90:R404
    #
    # Note: The negative lookahead here prevents, for example, the the 1 in the
    # text 1_"a" (a char_literal_constant) from being matched.

    digit_string !( t_underscore ( t_apostrophe / t_quotemark ) ) kind_option? <Int_Literal_Constant>
  end

  rule int_variable
    # F90:R607

    variable
  end

  rule intent_spec
    # F90:R511

    t_in /
    t_out /
    t_inout
  end

  rule intent_stmt
    # F90:R519

    label:label_stmt? t_intent t_paren_l intent_spec t_paren_r double_colon? dummy_arg_name_list t_newline &{ |e| sp_intent_stmt(e[3],e[6]) } <Intent_Stmt>
  end

  rule interface_block
    # F90:R1201

    interface_stmt interface_bodies module_procedure_stmts end_interface_stmt <Interface_Block>
  end

  rule interface_bodies
    interface_body* <Interface_Bodies>
  end

  rule interface_body
    # F90:R1204

    subroutine_stmt specification_part? end_subroutine_stmt &{ |e| sp_interface_body } <Interface_Body_1> /
    function_stmt specification_part? end_function_stmt &{ |e| sp_interface_body } <Interface_Body_2>
  end

  rule interface_stmt
    # F90:R1202

    label:label_stmt? t_interface generic_spec? t_newline <Interface_Stmt>
  end

  rule internal_file_unit
    # F90:R903

    default_char_variable
  end

  rule internal_subprogram_part
    # F90:R210

    contains_stmt internal_subprograms <Internal_Subprogram_Part>
  end

  rule internal_subprogram
    # F90:R211

    subroutine_subprogram &{ |e| sp_env_pullup(e[0]) } <Internal_Subprogram_Subroutine> /
    function_subprogram &{ |e| sp_env_pullup(e[0]) } <Internal_Subprogram_Function>
  end

  rule internal_subprograms
    internal_subprogram+ <Internal_Subprograms>
  end

  rule intrinsic_operator
    # F90:R310

    power_op /
    mult_op /
    add_op /
    concat_op /
    rel_op /
    logical_op
  end

  rule intrinsic_procedure_name
    # F90:12.3.2.3 (not explicitly defined)

    name "" <Intrinsic_Procedure_Name>
  end

  rule intrinsic_procedure_name_list
    intrinsic_procedure_name ( t_comma intrinsic_procedure_name )* <Intrinsic_Procedure_Name_List>
  end

  rule intrinsic_stmt
    # F90:R1208

    label:label_stmt? t_intrinsic intrinsic_procedure_name_list t_newline <Intrinsic_Stmt>
  end

  rule io_control_spec
    # F90:R912

    io_unit t_comma namelist_group_name !t_equal &{ |e| sp_namelist_group_name?(e[2]) } <Io_Control_Spec_Unit_Nml> /
    io_unit t_comma format !t_equal <Io_Control_Spec_Unit_Format> /
    t_advance t_equal scalar_default_char_expr <Io_Control_Spec_Advance> /
    io_spec_end /
    io_spec_eor /
    io_spec_err/
    t_fmt t_equal format <Io_Control_Spec_Fmt> /
    io_spec_iostat /
    io_spec_nml /
    t_rec t_equal scalar_int_expr <Io_Control_Spec_Rec> /
    io_spec_size /
    io_spec_unit /
    io_unit "" <Io_Control_Spec_Unit>
  end

  rule io_control_spec_list
    io_control_spec io_control_spec_list_pair* <Io_Control_Spec_List>
  end

  rule io_control_spec_list_pair
    t_comma io_control_spec <Io_Control_Spec_List_Pair>
  end

  rule io_implied_do
    # F90:R916

    t_paren_l io_implied_do_object_list t_comma io_implied_do_control t_paren_r <Io_Implied_Do>
  end

  rule io_implied_do_control
    # F90:R918

    do_variable t_equal scalar_numeric_expr t_comma scalar_numeric_expr io_implied_do_control_option? <Io_Implied_Do_Control>
  end

  rule io_implied_do_control_option
    t_comma scalar_numeric_expr <Io_Implied_Do_Control_Option>
  end

  rule io_implied_do_object
    # F90:R917

    output_item !t_equal <Io_Implied_Do_Object_Output_Item> /
    input_item !t_equal <Io_Implied_Do_Object_Input_Item>
  end

  rule io_implied_do_object_list
    io_implied_do_object ( t_comma io_implied_do_object )* <Io_Implied_Do_Object_List>
  end

  rule io_spec_access
    t_access t_equal scalar_default_char_variable <Io_Spec_Access>
  end

  rule io_spec_action
    t_action t_equal scalar_default_char_variable <Io_Spec_Action>
  end

  rule io_spec_blank
    t_blank t_equal scalar_default_char_variable <Io_Spec_Blank>
  end

  rule io_spec_delim
    t_delim t_equal scalar_default_char_variable <Io_Spec_Delim>
  end

  rule io_spec_direct
    t_direct t_equal scalar_default_char_variable <Io_Spec_Direct>
  end

  rule io_spec_end
    t_io_control_spec_end t_equal label_branch &{ |e| sp_io_spec_end(e[2]) } <Io_Spec_End>
  end

  rule io_spec_eor
    t_eor t_equal label_branch &{ |e| sp_io_spec_eor(e[2]) } <Io_Spec_Eor>
  end

  rule io_spec_err
    t_err t_equal label_branch &{ |e| sp_io_spec_err(e[2]) } <Io_Spec_Err>
  end

  rule io_spec_exist
    t_exist t_equal scalar_default_logical_variable <Io_Spec_Exist>
  end

  rule io_spec_form
    t_form t_equal scalar_default_char_variable <Io_Spec_Form>
  end

  rule io_spec_formatted
    t_formatted t_equal scalar_default_char_variable <Io_Spec_Formatted>
  end

  rule io_spec_iostat
    t_iostat t_equal scalar_default_int_variable <Io_Spec_Iostat>
  end

  rule io_spec_name
    t_name t_equal scalar_default_char_variable <Io_Spec_Name>
  end

  rule io_spec_named
    t_named t_equal scalar_default_logical_variable <Io_Spec_Named>
  end

  rule io_spec_nextrec
    t_nextrec t_equal scalar_default_int_variable <Io_Spec_Nextrec>
  end

  rule io_spec_nml
    t_nml t_equal namelist_group_name <Io_Spec_Nml>
  end

  rule io_spec_number
    t_number t_equal scalar_default_int_variable <Io_Spec_Number>
  end

  rule io_spec_opened
    t_opened t_equal scalar_default_logical_variable <Io_Spec_Opened>
  end

  rule io_spec_pad
    t_pad t_equal scalar_default_char_variable <Io_Spec_Pad>
  end

  rule io_spec_position
    t_position t_equal scalar_default_char_variable <Io_Spec_Position>
  end

  rule io_spec_read
    t_read t_equal scalar_default_char_variable <Io_Spec_Read>
  end

  rule io_spec_readwrite
    t_readwrite t_equal scalar_default_char_variable <Io_Spec_Readwrite>
  end

  rule io_spec_recl
    t_recl t_equal scalar_default_int_variable <Io_Spec_Recl>
  end

  rule io_spec_sequential
    t_sequential t_equal scalar_default_char_variable <Io_Spec_Sequential>
  end

  rule io_spec_size
    t_size t_equal scalar_default_int_variable <Io_Spec_Size>
  end

  rule io_spec_unformatted
    t_unformatted t_equal scalar_default_char_variable <Io_Spec_Unformatted>
  end

  rule io_spec_unit
    t_unit t_equal io_unit <Io_Spec_Unit>
  end

  rule io_spec_write
    t_write t_equal scalar_default_char_variable <Io_Spec_Write>
  end

  rule io_unit
    # F90:R901

    t_star /
    internal_file_unit "" <Internal_File_Unit> /
    external_file_unit "" <External_File_Unit>
  end

  rule keyword
    # F90:R1212

    dummy_arg_name
  end

  rule keyword_option
    keyword_pair?
  end

  rule keyword_pair
    keyword t_equal <Keyword_Pair>
  end

  rule kind_pair
    t_kind t_equal <Kind_Pair>
  end

  rule kind_option
    t_underscore kind_param <Kind_Option>
  end

  rule kind_param
    # F90:R405

    digit_string /
    scalar_int_constant_name
  end

  rule kind_selector
    # F90:R505

    t_paren_l kind_pair? scalar_int_initialization_expr t_paren_r <Kind_Selector>
  end

  rule label
    # F90:R313

    t_digit 1..5 &{ |e| sp_label(e[0]) } <Label>
  end

  rule label_assign
    label "" <Label_Assign>
  end

  rule label_branch
    label "" <Label_Branch>
  end

  rule label_do_stmt
    # F90:R819

    label:label_stmt? do_construct_name_label? t_do label loop_control? t_newline &{ |e| sp_dolabel_push(e[3]) } <Label_Do_Stmt>
  end

  rule label_format
    label "" <Label_Format>
  end

  rule label_list
    label_branch label_list_pair* &{ |e| sp_label_list(e[0],e[1]) } <Label_List>
  end

  rule label_list_pair
    t_comma label_branch <Label_List_Pair>
  end

  rule label_stmt
    label "" <Label_Stmt>
  end

  rule len_pair
    t_len t_equal <Len_Pair>
  end

  rule length_selector
    # F90:R507

    t_paren_l len_pair? type_param_value t_paren_r <Length_Selector_1> /
    char_length_pair &( [^\:\n]* double_colon ) <Length_Selector_2> /
    char_length_pair t_comma? <Length_Selector_3>
  end

  rule letter_sequence
    t_letter+ <Letter_Sequence>
  end

  rule letter_spec
    # F90:R542

    t_letter letter_spec_option? <Letter_Spec>
  end

  rule letter_spec_list
    letter_spec letter_spec_list_option* <Letter_Spec_List>
  end

  rule letter_spec_list_option
    t_comma letter_spec <Letter_Spec_List_Option>
  end

  rule letter_spec_option
    t_minus t_letter <Letter_Spec_Option>
  end

  rule level_1_expr
    # F90:R703

    defined_unary_op? primary <Level_1_Expr>
  end

  rule level_2_expr
    # F90:R707
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_2_expr? add_op )? add_operand

    add_op? add_operand level_2_expr? <Level_2_Expr>
  end

  rule level_3_expr
    # F90:R711
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr concat_op )? level_2_expr

    level_2_expr level_3_expr_option? <Level_3_Expr>
  end

  rule level_3_expr_option
    concat_op level_3_expr <Level_3_Expr_Option>
  end

  rule level_4_expr
    # F90:R713
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr rel_op )? level_3_expr

    level_3_expr level_4_expr_option? <Level_4_Expr>
  end

  rule level_4_expr_option
    rel_op level_3_expr <Level_4_Expr_Option>
  end

  rule level_5_expr
    # F90:R718
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_5_expr equiv_op)? equiv_operand

    equiv_operand level_5_expr_option? <Level_5_Expr>
  end

  rule level_5_expr_option
    equiv_op level_5_expr <Level_5_Expr_Option>
  end

  rule literal_constant
    # F90:R306
    #
    # Note: The choice order is different than that given in the standard, e.g.
    # an int_literal_constant should only be matched after failure to match a
    # real_literal_constant. Also, signed versions of real_literal_constant and
    # int_literal_constant are used here, though the standard (seemingly
    # incorrectly) specifies the unsigned versions.

    complex_literal_constant /
    signed_real_literal_constant /
    signed_int_literal_constant /
    logical_literal_constant /
    char_literal_constant /
    boz_literal_constant
  end

  rule local_name
    # F90:11.3.2 (not explicitly defined)

    name "" <Local_Name>
  end

  rule logical_expr
    # F90:R725

    expr
  end

  rule logical_initialization_expr
    # F90:R733

    logical_expr
  end

  rule logical_literal_constant
    # F90:R421

    t_true kind_option? <Logical_Literal_Constant_True> /
    t_false kind_option? <Logical_Literal_Constant_False>
  end

  rule logical_op
    not_op /
    and_op /
    or_op /
    equiv_op
  end

  rule logical_variable
    # F90:R603

    variable
  end

  rule loop_control
    # F90:R821

    t_comma? do_variable t_equal scalar_numeric_expr loop_control_pair loop_control_pair? <Loop_Control_1> /
    t_comma? t_while t_paren_l scalar_logical_expr t_paren_r <Loop_Control_2>
  end

  rule loop_control_pair
    t_comma scalar_numeric_expr <Loop_Control_Pair>
  end

  rule lower_bound
    # F90:R514

    specification_expr
  end

  rule lower_bound_pair
    lower_bound t_colon <Lower_Bound_Pair>
  end

  rule main_program
    # F90:R1101

    program_stmt? specification_part? execution_part? internal_subprogram_part? end_program_stmt &{ |e| sp_main_program } <Main_Program>
  end

  rule mask_expr
    # F90:R741

    logical_expr
  end

  rule module
    # F90:R1104

    module_stmt specification_part? module_subprogram_part? end_module_stmt &{ |e| sp_module(e[0],e[2]) } <Module>
  end

  rule module_name
    # F90:11.3 (not explicitly defined)

    name "" <Module_Name>
  end

  rule module_procedure_stmt
    # F90:R1205

    label:label_stmt? t_module t_procedure procedure_name_list t_newline <Module_Procedure_Stmt>
  end

  rule module_procedure_stmts
    module_procedure_stmt* <Module_Procedure_Stmts>
  end

  rule module_stmt
    # F90:R1105

    label:label_stmt? t_module module_name t_newline &{ |e| sp_module_stmt } <Module_Stmt>
  end

  rule module_subprogram
    # F90:R213

    subroutine_subprogram &{ |e| sp_env_pullup(e[0]) } <Module_Subprogram_Subroutine> /
    function_subprogram &{ |e| sp_env_pullup(e[0]) } <Module_Subprogram_Function>
  end

  rule module_subprogram_part
    # F90:R212

    contains_stmt module_subprogram+ <Module_Subprogram_Part>
  end

  rule mult_op
    # F90:R709

    t_star /
    t_slash
  end

  rule mult_operand
    # F90:R705

    level_1_expr power_op_option? <Mult_Operand>
  end

  rule name
    # F90:R304

    t_letter alphanumeric_character* <Name>
  end

  rule named_constant
    # F90:R307

    name "" <Named_Constant>
  end

  rule named_constant_def
    # F90:R539

    named_constant t_equal initialization_expr <Named_Constant_Def>
  end

  rule named_constant_def_list
    named_constant_def ( t_comma named_constant_def )* <Named_Constant_Def_List>
  end

  rule namelist_group_name
    # Multiple uses (not explicitly defined)

    name "" <Namelist_Group_Name>
  end

  rule namelist_group_object
    # F90:R544

    variable_name
  end

  rule namelist_group_object_list
    namelist_group_object namelist_group_object_list_pair* <Namelist_Group_Object_List>
  end

  rule namelist_group_object_list_pair
    t_comma namelist_group_object <Namelist_Group_Object_List_Pair>
  end

  rule namelist_group_set
    t_slash namelist_group_name t_slash namelist_group_object_list <Namelist_Group_Set>
  end

  rule namelist_group_set_pair
    t_comma? namelist_group_set <Namelist_Group_Set_Pair>
  end

  rule namelist_group_sets
    namelist_group_set_pair* <Namelist_Group_Sets>
  end

  rule namelist_stmt
    # F90:R543

    label:label_stmt? t_namelist namelist_group_set namelist_group_sets t_newline &{ |e| sp_namelist_stmt(e[2],e[3]) } <Namelist_Stmt>
  end

  rule nonblock_do_construct
    # F90:R826

    outer_shared_do_construct !{ |e| sp_dolabel_repeat? } <Nonblock_Do_Construct_Osdc> /
    action_term_do_construct
  end

  rule nonlabel_do_stmt
    # F90:R820

    label:label_stmt? do_construct_name_label? t_do loop_control? t_newline &{ |e| sp_dolabel_push(:nolabel) } <Nonlabel_Do_Stmt>
  end

  rule not_op
    # F90:R719

    ".not." <T>
  end

  rule null_function_ref
    t_null t_paren_l t_paren_r <Null_Function_Ref>
  end

  rule nullify_stmt
    # F90:R629

    label:label_stmt? t_nullify t_paren_l pointer_object_list t_paren_r t_newline <Nullify_Stmt>
  end

  rule numeric_expr
    # F90:R729

    expr
  end

  rule object_name
    # Multiple uses (not explicitly defined)

    name "" <Object_Name>
  end

  rule object_name_and_spec_list
    object_name parenthesized_deferred_shape_spec_list? <Object_Name_And_Spec_List>
  end

  rule object_name_and_spec_list_pair
    t_comma object_name_and_spec_list <Object_Name_And_Spec_List_Pair>
  end

  rule object_names_and_spec_lists
    object_name_and_spec_list object_name_and_spec_list_pair* <Object_Names_And_Spec_Lists>
  end

  rule octal_constant
    # F90:R409

    &"o" t_letter t_apostrophe t_octal+ t_apostrophe <Octal_Constant> /
    &"o" t_letter t_quotemark t_octal+ t_quotemark <Octal_Constant>
  end

  rule only
    # F90:R1109

    only_option? use_name <Only> /
    access_id
  end

  rule only_list
    only only_list_pair* <Only_List>
  end

  rule only_list_pair
    t_comma only <Only_List_Pair>
  end

  rule only_option
    local_name t_point <Only_Option>
  end

  rule open_stmt
    # F90:R904

    label:label_stmt? t_open t_paren_l connect_spec_list t_paren_r t_newline <Open_Stmt>
  end

  rule optional_stmt
    # F90:R520

    label:label_stmt? t_optional double_colon? dummy_arg_name_list t_newline &{ |e| sp_optional_stmt(e[3]) } <Optional_Stmt>
  end

  rule or_op
    # F90:R721

    ".or." <T>
  end

  rule outer_shared_do_construct
    # F90:R830
    #
    # Note: The label on label_do_stmt may match that of an enclosing o_s_d_c
    # (e.g. the second level in a triply-nested loop), or may not (e.g. in the
    # outermost o_s_d_c in a triply-nested loop).

    label_do_stmt do_body shared_term_do_construct <Outer_Shared_Do_Construct>
  end

  rule output_item
    # F90:R915

    io_implied_do /
    expr
  end

  rule output_item_list
    # F90:9.4.2

    output_item output_item_list_pair* <Output_Item_List>
  end

  rule output_item_list_pair
    t_comma output_item <Output_Item_List_Pair>
  end

  rule parameter_stmt
    # F90:R538

    label:label_stmt? t_parameter t_paren_l named_constant_def_list t_paren_r t_newline &{ |e| sp_parameter_stmt(e[3]) } <Parameter_Stmt>
  end

  rule parent_string
    # F90:R610

    array_element /
    scalar_structure_component /
    scalar_variable_name /
    scalar_constant
  end

  rule parenthesized_allocate_shape_spec_list
    t_paren_l allocate_shape_spec_list t_paren_r <Parenthesized_Allocate_Shape_Spec_List>
  end

  rule parenthesized_args
    t_paren_l actual_arg_spec_list? t_paren_r <Parenthesized_Args>
  end

  rule parenthesized_component_array_spec
    t_paren_l component_array_spec t_paren_r <Parenthesized_Component_Array_Spec>
  end

  rule parenthesized_deferred_shape_spec_list
    t_paren_l deferred_shape_spec_list t_paren_r <Parenthesized_Deferred_Shape_Spec_List>
  end

  rule parenthesized_explicit_shape_spec_list
    t_paren_l explicit_shape_spec_list t_paren_r <Parenthesized_Explicit_Shape_Spec_List>
  end

  rule parenthesized_expr
    t_paren_l expr t_paren_r <Parenthesized_Expr>
  end

  rule parenthesized_section_subscript_list
    t_paren_l section_subscript_list t_paren_r <Parenthesized_Section_Subscript_List>
  end

  rule part_name
    # Multiple uses (not explicitly defined)

    name "" <Part_Name>
  end

  rule part_ref
    # F90:R613

    part_name parenthesized_section_subscript_list? <Part_Ref>
  end

  rule pause_stmt
    # F90:R844

    label:label_stmt? t_pause stop_code? t_newline <Pause_Stmt>
  end

  rule pointer_assignment_stmt
    # F90:R736

    label:label_stmt? pointer_object t_point target t_newline <Pointer_Assignment_Stmt>
  end

  rule pointer_object
    # F90:R630

    structure_component /
    variable_name
  end

  rule pointer_object_list
    pointer_object ( t_comma pointer_object )* <Pointer_Object_List>
  end

  rule pointer_stmt
    # F90:R527

    label:label_stmt? t_pointer double_colon? object_names_and_spec_lists t_newline &{ |e| sp_pointer_stmt(e[3]) } <Pointer_Stmt>
  end

  rule position_edit_desc
    # F90:R1012

    &"tl" t_letter t_letter int_literal_constant <Position_Edit_Desc_Tl> /
    &"tr" t_letter t_letter int_literal_constant <Position_Edit_Desc_Tr> /
    &"t" t_letter int_literal_constant <Position_Edit_Desc_T> /
    int_literal_constant &"x" t_letter <Position_Edit_Desc_X>
  end

  rule position_spec
    # F90:R922

    external_file_unit &t_comma <Position_Spec_1> /
    t_unit t_equal external_file_unit <Position_Spec_2> /
    io_spec_iostat /
    io_spec_err
  end

  rule position_spec_list
    position_spec position_spec_list_pair* <Position_Spec_List>
  end

  rule position_spec_list_pair
    t_comma position_spec <Position_Spec_List_Pair>
  end

  rule power_op
    # F90:R708

    "**" <Power_Op>
  end

  rule power_op_option
    power_op mult_operand <Power_Op_Option>
  end

  rule primary
    # F90:R701

    function_reference /
    structure_constructor /
    variable /
    constant /
    constant_subobject /
    array_constructor /
    parenthesized_expr
  end

  rule print_stmt
    # F90:R911

    label:label_stmt? t_print format print_stmt_output_item_list? t_newline <Print_Stmt>
  end

  rule print_stmt_output_item_list
    t_comma output_item_list <Print_Stmt_Output_Item_List>
  end

  rule private_sequence_stmt
    # F90:R423

    label:label_stmt? ( t_private / t_sequence ) t_newline <Private_Sequence_Stmt>
  end

  rule private_sequence_stmts
    private_sequence_stmt* <Private_Sequence_Stmts>
  end

  rule procedure_name
    # F90:12.4.1

    name "" <Procedure_Name>
  end

  rule procedure_name_list
    procedure_name ( t_comma procedure_name )* <Procedure_Name_List>
  end

  rule program_name
    # F90:11.1

    name "" <Program_Name>
  end

  rule program_stmt
    # F90:R1102

    label:label_stmt? t_program program_name t_newline &{ |e| sp_program_stmt } <Program_Stmt>
  end

  rule program_unit
    # F90:R202

    external_subprogram /
    module &{ |e| sp_env_pullup(e[0]) } <Program_Unit_Module> /
    block_data &{ |e| sp_env_pullup(e[0]) } <Program_Unit_Block_Data> /
    main_program &{ |e| sp_env_pullup(e[0]) } <Program_Unit_Main_Program>
  end

  rule program_units
    program_unit+ <Program_Units>
  end

  rule read_stmt
    # F90:R909

    label:label_stmt? t_read t_paren_l io_control_spec_list t_paren_r input_item_list? t_newline <Read_Stmt_1> /
    label:label_stmt? t_read format read_stmt_input_item_list_option? t_newline <Read_Stmt_2>
  end

  rule read_stmt_input_item_list_option
    t_comma input_item_list <Read_Stmt_Input_Item_List_Option>
  end

  rule real_literal_constant
    # F90:R413

    significand real_literal_constant_option? kind_option? <Real_Literal_Constant_1> /
    digit_string exponent_letter exponent kind_option? <Real_Literal_Constant_2>
  end

  rule real_literal_constant_option
    exponent_letter exponent <Real_Literal_Constant_Option>
  end

  rule real_part
    # F90:R418

    signed_real_literal_constant /
    signed_int_literal_constant
  end

  rule rel_op_eq
    ".eq." <T> /
    "==" <T>
  end

  rule rel_op_ge
    ".ge." <T> /
    ">=" <T>
  end

  rule rel_op_gt
    ".gt." <T> /
    t_gt
  end

  rule rel_op_le
    ".le." <T> /
    "<=" <T>
  end

  rule rel_op_lt
    ".lt." <T> /
    t_lt
  end

  rule rel_op_ne
    ".ne." <T> /
    "/=" <T>
  end

  rule rel_op
    # F90:R714

    rel_op_eq /
    rel_op_ne /
    rel_op_le /
    rel_op_lt /
    rel_op_ge /
    rel_op_gt
  end

  rule rename
    # F90:R1108

    local_name t_point use_name <Rename>
  end

  rule rename_list
    rename rename_list_pair* <Rename_List>
  end

  rule rename_list_pair
    t_comma rename <Rename_List_Pair>
  end

  rule rename_list_option
    t_comma rename_list <Rename_List_Option>
  end

  rule rep_char
    # F90:4.3.2.1 (processor-dependent). Also see F90:3.1.5.

    character /
    [\[\]\~\`\@\#\^\|\{\}\\] <T>
  end

  rule result_name
    # Multiple uses (not explicitly defined)

    name "" <Result_Name>
  end

  rule result_option
    t_result t_paren_l result_name t_paren_r <Result_Option>
  end

  rule return_stmt
    # F90:R1224

    label:label_stmt? t_return scalar_int_expr? t_newline <Return_Stmt>
  end

  rule rewind_stmt
    # F90:R921

    label:label_stmt? t_rewind t_paren_l position_spec_list t_paren_r t_newline <Rewind_Stmt_1> /
    label:label_stmt? t_rewind external_file_unit t_newline <Rewind_Stmt_2>
  end

  rule save_stmt
    # F90:R523

    label:label_stmt? t_save save_stmt_entity_list? t_newline &{ |e| sp_save_stmt(e[2]) } <Save_Stmt>
  end

  rule save_stmt_entity_list
    double_colon? saved_entity_list <Save_Stmt_Entity_List>
  end

  rule saved_entity
    # F90:R524

    object_name "" <Saved_Entity_1> /
    t_slash common_block_name t_slash <Saved_Entity_2>
  end

  rule saved_entity_list
    saved_entity saved_entity_list_pair* <Saved_Entity_List>
  end

  rule saved_entity_list_pair
    t_comma saved_entity <Saved_Entity_List_Pair>
  end

  rule scalar_char_constant
    # F90:8.4 (not explicitly defined)

    char_literal_constant /
    named_constant
  end

  rule scalar_char_expr
    # F90:8.1.3.1

    char_expr
  end

  rule scalar_char_initialization_expr
    # F90:8.1.3.1 (not explicitly defined)

    initialization_expr
  end

  rule scalar_constant
    # Multiple uses (not explicitly defined)

    literal_constant /
    named_constant
  end

  rule scalar_default_char_expr
    # Multiple uses (not explicitly defined)

    default_char_expr
  end

  rule scalar_default_char_variable
    # F90:9.6.1 (not explicitly defined)

    default_char_variable
  end

  rule scalar_default_int_variable
    # Multiple uses (not explicitly defined)

    variable
  end

  rule scalar_default_logical_variable
    # F90:9.6.1 (not explicitly defined)

    default_logical_variable
  end

  rule scalar_expr
    # F90:12.5.4 (not explicitly defined)

    expr
  end

  rule scalar_int_constant
    # Multiple uses (not explicitly defined)

    scalar_int_literal_constant /
    scalar_int_constant_name
  end

  rule scalar_int_constant_name
    # F90:4.3.1.1 (not explicitly defined)

    named_constant
  end

  rule scalar_int_expr
    # Multiple uses (not explicitly defined)

    expr
  end

  rule scalar_int_initialization_expr
    # Multiple uses (not explicitly defined)

    initialization_expr
  end

  rule scalar_int_literal_constant
    # F90:5.1.1.5 (not explicitly defined)

    signed_int_literal_constant
  end

  rule scalar_int_variable
    # Multiple uses (not explicitly defined)

    scalar_variable_name
  end

  rule scalar_logical_expr
    # Multiple uses (not explicitly defined)

    logical_expr
  end

  rule scalar_logical_initialization_expr
    # F90:8.1.3.1 (not explicitly defined)

    initialization_expr
  end

  rule scalar_numeric_expr
    # Multiple users (not explicitly defined)

    numeric_expr
  end

  rule scalar_structure_component
    # Multiple uses (not explicitly defined)

    structure_component
  end

  rule scalar_variable
    # F90:8.1.4.1.1 (not explicitly defiend)

    scalar_variable_name
  end

  rule scalar_variable_name
    # Section 6 (not explicitly defined)

    variable_name "" <Scalar_Variable_Name>
  end

  rule section_subscript
    # F90:R618
    #
    # Note: Distinguishing between the subscript and vector_subscript choices
    # would require shape analysis not currently being performed.

    subscript_triplet /
    subscript #/
#   vector_subscript
  end

  rule section_subscript_list
    section_subscript section_subscript_list_option* <Section_Subscript_List>
  end

  rule section_subscript_list_option
    t_comma section_subscript <Section_Subscript_List_Option>
  end

  rule select_case_stmt
    # F90:R809

    label:label_stmt? case_construct_name_pair? t_select t_case t_paren_l case_expr t_paren_r t_newline <Select_Case_Stmt>
  end

  rule shared_term_do_construct
    # F90:R831

    inner_shared_do_construct &{ |e| sp_dolabel_pop } <Shared_Term_Do_Construct_Inner> /
    outer_shared_do_construct &{ |e| sp_dolabel_pop } <Shared_Term_Do_Construct_Outer>
  end

  rule sign
    # F90:R406

    t_plus /
    t_minus
  end

  rule sign_edit_desc
    # F90:R1014

    "sp" <T> /
    "ss" <T> /
    "s" <T>
  end

  rule signed_digit_string
    # F90:R401

    sign? digit_string <Signed_Digit_String>
  end

  rule signed_int_literal_constant
    # F90:R403

    sign? int_literal_constant <Signed_Int_Literal_Constant>
  end

  rule signed_real_literal_constant
    # F90:R412

    sign? real_literal_constant <Signed_Real_Literal_Constant>
  end

  rule significand
    # F90:R414

    digit_string !significand_disallowed t_dot digit_string? <Significand_1> /
    t_dot digit_string <Significand_2>
  end

  rule significand_disallowed
    # Note: The use of this rule as a negative lookahead assertion in rule
    # significand allows parsing of an if_then_stmt like:
    #
    #  if (a>0.and.b>1) then
    #
    # Without the negative lookahead assertion, "0." would be recognized as a
    # real_literal_constant and consumed, and the parse would fail.

    rel_op /
    logical_op
  end

  rule special_character
    # F90:3.1.4

    [\ \=\+\-\*\/\(\)\,\.\'\:\!\"\%\&\;\<\>\?\$] <T>
  end

  rule specification_expr
    # F90:R734

    scalar_int_expr
  end

  rule specification_part
    # F90:R204

    use_part implicit_part? declaration_constructs &{ |e| sp_specification_part } <Specification_Part>
  end

  rule specification_stmt
    # F90:R214

    access_stmt /
    allocatable_stmt /
    common_stmt /
    data_stmt /
    dimension_stmt /
    equivalence_stmt /
    external_stmt /
    intent_stmt /
    intrinsic_stmt /
    namelist_stmt /
    optional_stmt /
    pointer_stmt /
    save_stmt /
    target_stmt
  end

  rule star_int
    t_star int_literal_constant <Star_Int>
  end

  rule stat_variable
    # F90:R623

    scalar_int_variable
  end

  rule stmt_function_stmt
    # F90:R1226

    label:label_stmt? function_name t_paren_l dummy_arg_name_list? t_paren_r t_equal scalar_expr t_newline <Stmt_Function_Stmt>
  end

  rule stop_code
    # F90:R843

    scalar_char_constant "" <Stop_Code_Character> /
    t_digit 1..5 <Stop_Code_Numeric>
  end

  rule stop_stmt
    # F90:R842

    label:label_stmt? t_stop stop_code? t_newline <Stop_Stmt>
  end

  rule stride
    # F90:R620

    scalar_int_expr "" <Subscript>
  end

  rule structure_component
    # F90:R614

    data_ref "" <Structure_Component>
  end

  rule structure_constructor
    # F90:R430

    type_name t_paren_l expr_list t_paren_r &{ |e| sp_structure_constructor(e[0]) } <Structure_Constructor>
  end

  rule subroutine_name
    # Multiple uses (not explicitly defined)

    name "" <Subroutine_Name>
  end

  rule subroutine_prefix
    # F95:1219

    subroutine_prefix_option+ <Subroutine_Prefix>
  end

  rule subroutine_prefix_option
    t_elemental /
    t_pure /
    t_recursive
  end

  rule subroutine_stmt
    # F90:R1220 + F95:1222

    label:label_stmt? subroutine_prefix? t_subroutine subroutine_name dummy_arg_list_option? t_newline &{ |e| sp_subroutine_stmt(e[3],e[4]) } <Subroutine_Stmt>
  end

  rule subroutine_subprogram
    # F90:R1219

    subroutine_stmt specification_part? execution_part? internal_subprogram_part? end_subroutine_stmt &{ |e| sp_subroutine_subprogram } <Subroutine_Subprogram>
  end

  rule subscript
    # F90:R617

    scalar_int_expr "" <Subscript>
  end

  rule subscript_triplet
    # F90:R619

    subscript? t_colon subscript? subscript_triplet_stride_option? <Subscript_Triplet>
  end

  rule subscript_triplet_stride_option
    t_colon stride <Subscript_Triplet_Stride_Option>
  end

  rule subobject
    # F90:R602

    array_section /
    array_element /
    structure_component /
    substring
  end

  rule substring
    # F90:R609

    parent_string t_paren_l substring_range t_paren_r <Substring>
  end

  rule substring_range
    # F90:R611

    scalar_int_expr? t_colon scalar_int_expr? <Substring_Range>
  end

  rule substring_range_triplet
    t_paren_l substring_range t_paren_r <Substring_Range_Triplet>
  end

  rule t_access
    "access" <T>
  end

  rule t_action
    "action" <T>
  end

  rule t_advance
    "advance" <T>
  end

  rule t_allocatable
    "allocatable" <T>
  end

  rule t_allocate
    "allocate" <T>
  end

  rule t_apostrophe
    "'" <T>
  end

  rule t_assign
    "assign" !"ment" <T>
  end

  rule t_assignment
    "assignment" <T>
  end

  rule t_backspace
    "backspace" <T>
  end

  rule t_binary
    [01] <T>
  end

  rule t_blank
    "blank" <T>
  end

  rule t_block
    "block" <T>
  end

  rule t_call
    "call" <T>
  end

  rule t_case
    "case" <T>
  end

  rule t_character
    "character" <T>
  end

  rule t_close
    "close" <T>
  end

  rule t_colon
    ":" <T>
  end

  rule t_comma
    "," <T>
  end

  rule t_common
    "common" <T>
  end

  rule t_contains
    "contains" <T>
  end

  rule t_complex
    "complex" <T>
  end

  rule t_continue
    "continue" <T>
  end

  rule t_cycle
    "cycle" <T>
  end

  rule t_data
    "data" <T>
  end

  rule t_deallocate
    "deallocate" <T>
  end

  rule t_default
    "default" <T>
  end

  rule t_delim
    "delim" <T>
  end

  rule t_digit
    [0-9] <T>
  end

  rule t_dimension
    "dimension" <T>
  end

  rule t_direct
    "direct" <T>
  end

  rule t_do
    "do" <T>
  end

  rule t_dot
    "." <T>
  end

  rule t_doubleprecision
    "doubleprecision" <T>
  end

  rule t_elemental
    "elemental" <T>
  end

  rule t_else
    "else" <T>
  end

  rule t_elseif
    "elseif" <T>
  end

  rule t_elsewhere
    "elsewhere" <T>
  end

  rule t_end
    "end" !t_end_disallowed <T>
  end

  rule t_end_disallowed
    # Note: Used as a negative lookahead assertion, prevents t_end from matching
    # "endfile", "enddo", etc. Also prevents t_end from matching an assignment
    # statement like "endxyz=1".

    "file" /
    "do" /
    "if" /
    "where" /
    alphanumeric_character* t_equal
  end

  rule t_enddo
    "enddo" <T>
  end

  rule t_endfile
    "endfile" <T>
  end

  rule t_endif
    "endif" <T>
  end

  rule t_endwhere
    "endwhere" <T>
  end

  rule t_entry
    "entry" <T>
  end

  rule t_eor
    "eor" <T>
  end

  rule t_equal
    "=" <T>
  end

  rule t_equivalence
    "equivalence" <T>
  end

  rule t_err
    "err" <T>
  end

  rule t_exist
    "exist" <T>
  end

  rule t_exit
    "exit" <T>
  end

  rule t_external
    "external" <T>
  end

  rule t_false
    ".false." <T>
  end

  rule t_file
    "file" <T>
  end

  rule t_fmt
    "fmt" <T>
  end

  rule t_form
    "form" !"at" <T>
  end

  rule t_format
    "format" !"ted" <T>
  end

  rule t_formatted
    "formatted" <T>
  end

  rule t_function
    "function" <T>
  end

  rule t_goto
    "goto" <T>
  end

  rule t_gt
    ">" <T>
  end

  rule t_if
    "if" <T>
  end

  rule t_implicit
    "implicit" <T>
  end

  rule t_in
    "in" !( "out" / "quire" / "teger" / "tent" / "trinsic" ) <T>
  end

  rule t_inout
    "inout" <T>
  end

  rule t_inquire
    "inquire" <T>
  end

  rule t_integer
    "integer" <T>
  end

  rule t_intent
    "intent" <T>
  end

  rule t_interface
    "interface" <T>
  end

  rule t_intrinsic
    "intrinsic" <T>
  end

  rule t_io_control_spec_end
    "end" &t_equal <T>
  end

  rule t_iolength
    "iolength" <T>
  end

  rule t_iostat
    "iostat" <T>
  end

  rule t_kind
    "kind" <T>
  end

  rule t_len
    "len" <T>
  end

  rule t_letter
    [a-zA-Z] <T>
  end

  rule t_logical
    "logical" <T>
  end

  rule t_lt
    "<" <T>
  end

  rule t_minus
    "-" <T>
  end

  rule t_module
    "module" <T>
  end

  rule t_name
    "name" !( "d" / "list" ) <T>
  end

  rule t_named
    "named" <T>
  end

  rule t_namelist
    "namelist" <T>
  end

  rule t_newline
    "\n" <T>
  end

  rule t_nextrec
    "nextrec" <T>
  end

  rule t_nml
    "nml" <T>
  end

  rule t_none
    "none" <T>
  end

  rule t_null
    "null" <T>
  end

  rule t_nullify
    "nullify" <T>
  end

  rule t_number
    "number" <T>
  end

  rule t_octal
    [01234567] <T>
  end

  rule t_only
    "only" <T>
  end

  rule t_open
    "open" !"ed" <T>
  end

  rule t_opened
    "opened" <T>
  end

  rule t_operator
    "operator" <T>
  end

  rule t_optional
    "optional" <T>
  end

  rule t_out
    "out" <T>
  end

  rule t_pad
    "pad" <T>
  end

  rule t_parameter
    "parameter" <T>
  end

  rule t_paren_l
    "(" <T>
  end

  rule t_paren_r
    ")" <T>
  end

  rule t_pause
    "pause" <T>
  end

  rule t_percent
    "%" <T>
  end

  rule t_plus
    "+" <T>
  end

  rule t_point
    "=>" <T>
  end

  rule t_pointer
    "pointer" <T>
  end

  rule t_position
    "position" <T>
  end

  rule t_print
    "print" <T>
  end

  rule t_private
    "private" <Access_Spec>
  end

  rule t_procedure
    "procedure" <T>
  end

  rule t_program
    "program" <T>
  end

  rule t_public
    "public" <Access_Spec>
  end

  rule t_pure
    "pure" <T>
  end

  rule t_quotemark
    "\"" <T>
  end

  rule t_read
    "read" !"write" <T>
  end

  rule t_readwrite
    "readwrite" <T>
  end

  rule t_real
    "real" <T>
  end

  rule t_rec
    "rec" !"l" <T>
  end

  rule t_recl
    "recl" <T>
  end

  rule t_recursive
    "recursive" <T>
  end

  rule t_result
    "result" <T>
  end

  rule t_return
    "return" <T>
  end

  rule t_rewind
    "rewind" <T>
  end

  rule t_save
    "save" <T>
  end

  rule t_select
    "select" <T>
  end

  rule t_sequence
    "sequence" <T>
  end

  rule t_sequential
    "sequential" <T>
  end

  rule t_size
    "size" <T>
  end

  rule t_slash
    "/" <T>
  end

  rule t_star
    "*" <T>
  end

  rule t_stat
    "stat" !"us" <T>
  end

  rule t_status
    "status" <T>
  end

  rule t_stop
    "stop" <T>
  end

  rule t_subroutine
    "subroutine" <T>
  end

  rule t_target
    "target" <T>
  end

  rule t_then
    "then" <T>
  end

  rule t_to
    "to" <T>
  end

  rule t_true
    ".true." <T>
  end

  rule t_type
    "type" <T>
  end

  rule t_underscore
    # F90:R303
    "_" <T>
  end

  rule t_unformatted
    "unformatted" <T>
  end

  rule t_unit
    "unit" <T>
  end

  rule t_use
    "use" <T>
  end

  rule t_where
    "where" <T>
  end

  rule t_while
    "while" <T>
  end

  rule t_write
    "write" <T>
  end

  rule target
    # F90:R737

    variable /
    expr
  end

  rule target_object
    array_name_and_spec /
    variable_name
  end

  rule target_object_list
    target_object target_object_list_pair* <Target_Object_List>
  end

  rule target_object_list_pair
    t_comma target_object <Target_Object_List_Pair>
  end

  rule target_stmt
    # F90:R528

    label:label_stmt? t_target double_colon? target_object_list t_newline &{ |e| sp_target_stmt(e[3]) } <Target_Stmt>
  end

  rule type_declaration_stmt
    # F90:R501

    label:label_stmt? type_spec attr_spec_option? entity_decl_list t_newline &{ |e| sp_type_declaration_stmt(e[1],e[2],e[3]) } <Type_Declaration_Stmt>
  end

  rule type_name
    # Multiple uses (not explicitly defined)

    name "" <Type_Name>
  end

  rule type_param_value
    # F90:R509

    specification_expr /
    t_star
  end

  rule type_spec
    # F90:R502

    type_spec_with_kind_selector /
    type_spec_without_kind_selector
  end

  rule type_spec_with_kind_selector
    t_integer kind_selector <Type_Spec> /
    t_real kind_selector <Type_Spec> /
    t_complex kind_selector <Type_Spec> /
    t_logical kind_selector <Type_Spec>
  end

  rule type_spec_without_kind_selector
    t_integer star_int <Type_Spec> / # NON-CONFORMANT!
    t_integer "" <Type_Spec> /
    t_real star_int <Type_Spec> / # NON-CONFORMANT!
    t_real "" <Type_Spec> /
    t_doubleprecision "" <Type_Spec> /
    t_complex star_int <Type_Spec> /
    t_complex "" <Type_Spec> /
    t_character char_selector? <Type_Spec> /
    t_logical star_int <Type_Spec> / # NON-CONFORMANT!
    t_logical "" <Type_Spec> /
    t_type t_paren_l type_name t_paren_r <Type_Spec>
  end

  rule upper_bound
    # F90:R515

    specification_expr "" <Upper_Bound>
  end

  rule use_name
    # Multiple uses (not explicitly defined)

    name "" <Use_Name>
  end

  rule use_part
    use_stmt* <Use_Part>
  end

  rule use_stmt
    # F90:R1107

    label:label_stmt? t_use module_name rename_list_option? t_newline &{ |e| sp_use_stmt(e[2],e[3]) } <Use_Stmt_1> /
    label:label_stmt? t_use module_name t_comma t_only t_colon only_list? t_newline &{ |e| sp_use_stmt(e[2],e[6]) } <Use_Stmt_2>
  end

  rule variable
    # F90:R601

    array_variable_name ![\(\%] <Variable> /
    scalar_variable_name ![\(\%] <Variable> /
    subobject "" <Variable>
  end

  rule variable_name
    # Multiple uses (not explicitly defined)

    name !"%" <Variable_Name>
  end

  rule vector_subscript
    # F90:R621

    int_expr "" <Vector_Subscript>
  end

  rule where_assignment_stmt_block
    assignment_stmt* <Where_Assignement_Stmt_Block>
  end

  rule where_construct
    # F90:R739

    where_construct_stmt where_assignment_stmt_block elsewhere_construct? end_where_stmt <Where_Construct>
  end

  rule where_construct_stmt
    # F90:R740

    label:label_stmt? t_where t_paren_l mask_expr t_paren_r t_newline <Where_Construct_Stmt>
  end

  rule where_stmt
    # F90:R738

    label:label_stmt? t_where t_paren_l mask_expr t_paren_r !label assignment_stmt <Where_Stmt>
  end

  rule write_stmt
    # F90:R910

    label:label_stmt? t_write t_paren_l io_control_spec_list t_paren_r output_item_list? t_newline <Write_Stmt>
  end

end
