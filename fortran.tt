grammar Fortran

  rule ac_do_variable
    # F90:R435

    scalar_int_variable
  end

  rule ac_implied_do
    # F90:R433

    t_paren_l ac_value_list t_comma ac_implied_do_control t_paren_r <E>
  end

  rule ac_implied_do_control
    # F90:R434

    ac_do_variable t_equal scalar_int_expr ( t_comma scalar_int_expr )? <AC_Implied_Do_Control>
  end

  rule ac_value
    # F90:R432

    ac_implied_do /
    expr !t_equal <E>
  end

  rule ac_value_list
    ac_value ( t_comma ac_value )* <AC_Value_List>
  end

  rule access_id
    # F90:R522

    use_name /
    generic_spec
  end

  rule access_id_list
    access_id access_id_pair* <Access_Id_List>
  end

  rule access_id_pair
    t_comma access_id <Access_Id_List_Pair>
  end

  rule access_spec
    # F90:R510

    t_public /
    t_private
  end

  rule access_stmt
    # F90:R521

    label:label? access_spec access_stmt_option? t_newline &{ |e| sp_access_stmt(e[1],e[2]) } <Access_Stmt>
  end

  rule access_stmt_option
    double_colon? access_id_list <Access_Stmt_Option>
  end

  rule action_stmt
    # F90:R216

    allocate_stmt /
    assignment_stmt /
    backspace_stmt /
    call_stmt /
    close_stmt /
    computed_goto_stmt /
    continue_stmt /
    cycle_stmt /
    deallocate_stmt /
    endfile_stmt /
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    if_stmt /
    inquire_stmt /
    nullify_stmt /
    open_stmt /
    pointer_assignment_stmt /
    print_stmt /
    read_stmt /
    return_stmt /
    rewind_stmt /
    stop_stmt /
    where_stmt /
    write_stmt /
    arithmetic_if_stmt /
    assign_stmt /
    assigned_goto_stmt /
    pause_stmt
  end

  rule action_term_do_construct
    # F90:R827

    label_do_stmt !{ |e| dolabel_repeat? } do_body do_term_action_stmt <E>
  end

  rule actual_arg
    # F90:R1213

    expr /
    variable /
    procedure_name /
    alt_return_spec
  end

  rule actual_arg_spec
    # F90:R1211

    keyword_option actual_arg <E>
  end

  rule actual_arg_spec_list
    actual_arg_spec ( t_comma actual_arg_spec )* <Actual_Arg_Spec_List>
  end

  rule add_op
    # F90:R710

    t_plus /
    t_minus
  end

  rule add_operand
    # F90:R706
    #
    # Note: Left-recursive rule implied by standard:
    # ( add_operand mult_op)? mult_operand

    mult_operand ( mult_op add_operand )? <Add_Operand>
  end

  rule and_op
    # F90:R720

    ".and." <T>
  end

  rule allocatable_stmt
    # F90:R526

    label:label? t_allocatable double_colon? array_names_and_deferred_shape_spec_lists t_newline &{ |e| sp_allocatable_stmt(e[3]) } <Allocatable_Stmt>
  end

  rule allocate_lower_bound
    # F90:R627

    scalar_int_expr
  end

  rule allocate_object
    # F90:R625

    !( t_stat t_equal ) structure_component <Allocate_Object> /
    !( t_stat t_equal ) variable_name <Allocate_Object>
  end

  rule allocate_object_list
    allocate_object allocate_object_list_pair* <Allocate_Object_List>
  end

  rule allocate_object_list_pair
    t_comma allocate_object <Allocate_Object_List_Pair> 
  end

  rule allocate_shape_spec
    # F90:R626

    ( allocate_lower_bound t_colon )? allocate_upper_bound <E>
  end

  rule allocate_shape_spec_list
    # F90:6.3.1

    allocate_shape_spec ( t_comma allocate_shape_spec )* <Allocate_Shape_Spec_List>
  end

  rule allocate_stat_construct
    t_comma t_stat t_equal stat_variable <E>
  end

  rule allocate_stmt
    # F90:R622

    label:label? t_allocate t_paren_l allocation_list allocate_stat_construct? t_paren_r t_newline <Allocate_Stmt>
  end

  rule allocate_upper_bound
    # F90:R628

    scalar_int_expr
  end

  rule allocation
    # F90:R624

    allocate_object parenthesized_allocate_shape_spec_list? <Allocation>
  end

  rule allocation_list
    allocation ( t_comma allocation )* <Allocation_List>
  end

  rule alphanumeric_character
    # F90:R302

    t_letter /
    t_digit /
    t_underscore
  end

  rule alt_return_spec
    # F90:R1214

    t_star label <T>
  end

  rule arithmetic_if_stmt
    # F90:R840

    label:label? t_if t_paren_l scalar_numeric_expr t_paren_r label t_comma label t_comma label t_newline <Arithmetic_If_Stmt>
  end

  rule array_constructor
    # F90:R431

    t_paren_l t_slash ac_value_list t_slash t_paren_r <E>
  end

  rule array_element
    # F90:R615

    data_ref
  end

  rule array_name
    # Multiple uses (not explicitly defined)

    name "" <Array_Name>
  end

  rule array_name_and_deferred_shape_spec_list
    array_name parenthesized_deferred_shape_spec_list? <Array_Name_And_Deferred_Shape_Spec_List>
  end

  rule array_name_and_deferred_shape_spec_list_pair
    t_comma array_name_and_deferred_shape_spec_list <Array_Name_And_Deferred_Shape_Spec_List_Pair>
  end

  rule array_names_and_deferred_shape_spec_lists
    array_name_and_deferred_shape_spec_list array_name_and_deferred_shape_spec_list_pair* <Array_Names_And_Deferred_Shape_Spec_Lists>
  end

  rule array_name_and_spec
    array_name t_paren_l array_spec t_paren_r <Array_Name_And_Spec>
  end

  rule array_name_and_spec_pair
    t_comma array_name_and_spec <Array_Name_And_Spec_Pair>
  end

  rule array_names_and_specs
    array_name_and_spec array_name_and_spec_pair* <Array_Names_And_Specs>
  end

  rule array_section
    # F90:R616

    data_ref &{ |e| sp_is_array?(e[0]) } substring_range_triplet? <Array_Section>
  end

  rule array_spec
    # F90:R512
    #
    # Note: A deferred_shape_spec_list will be (incorrectly) recognized as an
    # assumed_shape_spec_list, as it's (apparently) impossible to differentiate
    # all cases with only information encountered so far. This is corrected in
    # tree post-processing.

    assumed_size_spec "" <Array_Spec> /
    explicit_shape_spec_list "" <Array_Spec> /
    assumed_shape_spec_list "" <Array_Spec>
  end

  rule array_variable_name
    # Section 6 (not explicitly defined)

    variable_name
  end

  rule assign_stmt
    # F90:R838

    label:label? t_assign label t_to scalar_int_variable t_newline <StmtJ>
  end

  rule assigned_goto_stmt
    # F90:R839

    label:label? t_goto scalar_int_variable assigned_goto_stmt_label_list? t_newline <Assigned_Goto_Stmt>
  end

  rule assigned_goto_stmt_label_list
    t_comma? t_paren_l label_list t_paren_r <T>
  end

  rule assignment_stmt
    # F90:R735

    label:label? variable t_equal expr t_newline <StmtC>
  end

  rule assumed_shape_spec
    # F90:R516

    lower_bound? t_colon <Assumed_Shape_Spec>
  end

  rule assumed_shape_spec_list
    assumed_shape_spec assumed_shape_spec_list_pair* <Assumed_Shape_Spec_List>
  end

  rule assumed_shape_spec_list_pair
    t_comma assumed_shape_spec <Assumed_Shape_Spec_List_Pair>
  end

  rule assumed_size_spec
    # F90:R518

    assumed_size_spec_pair? lower_bound_pair? t_star <Assumed_Size_Spec>
  end

  rule assumed_size_spec_pair
    explicit_shape_spec_list t_comma <Assumed_Size_Spec_Pair>
  end

  rule attr_spec
    # F90:R503

    t_parameter /
    access_spec /
    t_allocatable /
    t_dimension t_paren_l array_spec t_paren_r <Attr_Spec_Dimension> /
    t_external /
    t_intent t_paren_l intent_spec t_paren_r <T> /
    t_intrinsic /
    t_optional /
    t_pointer /
    t_save /
    t_target
  end

  rule attr_spec_list
    attr_spec attr_spec_list_pairs <Attr_Spec_List>
  end

  rule attr_spec_list_pair
    t_comma attr_spec <Attr_Spec_List_Pair>
  end

  rule attr_spec_list_pairs
    attr_spec_list_pair* <Attr_Spec_List_Pairs>
  end

  rule attr_spec_option
    t_comma attr_spec_list double_colon <Attr_Spec_Option> /
    double_colon
  end

  rule backspace_stmt
    # F90:R919

    label:label? t_backspace t_paren_l position_spec_list t_paren_r t_newline <StmtC> /
    label:label? t_backspace external_file_unit t_newline <StmtJ>
  end

  rule binary_constant
    # F90:R408

    "b" ( ( t_apostrophe t_binary+ t_apostrophe ) / ( t_quotemark t_binary+ t_quotemark ) ) <T>
  end

  rule block
    # F90:R801

    execution_part_construct
  end

  rule block_data
    # F90:R1110

    block_data_stmt specification_part? end_block_data_stmt <Block_Data>
  end

  rule block_data_name
    # F90:11.4 (not explicitly defined)

    name "" <Block_Data_Name>
  end

  rule block_data_stmt
    # F90:R1111

    label:label? t_block t_data block_data_name? t_newline &{ |e| sp_block_data_stmt } <Block_Data_Stmt>
  end

  rule block_do_construct
    # F90:R817
    #
    # Note: For this rule to match, the label (if any) on the do_stmt cannot be
    # a repeat, as that would require more than one end-do-stmt with the same
    # label, which is not permitted.

    do_stmt !{ |e| dolabel_repeat? } do_block end_do <E>
  end

  rule boz_literal_constant
    # F90:R407

    binary_constant /
    octal_constant /
    hex_constant
  end

  rule call_stmt
    # F90:R1210

    label:label? t_call subroutine_name parenthesized_args? t_newline <Call_Stmt>
  end

  rule case_construct
    # F90:R808

    select_case_stmt case_stmt_construct_block end_select_stmt <E>
  end

  rule case_construct_name
    name "" <Case_Construct_Name>
  end

  rule case_construct_name_pair
    case_construct_name t_colon <T>
  end

  rule case_expr
    # F90:R812

    scalar_int_expr /
    scalar_char_expr /
    scalar_logical_expr
  end

  rule case_selector
    # F90:R813

    case_selector_range /
    t_default
  end

  rule case_selector_range
    t_paren_l case_value_range_list t_paren_r <E>
  end

  rule case_stmt
    # F90:R810

    label:label? t_case case_selector case_construct_name? t_newline <Case_Stmt>
  end

  rule case_stmt_construct
    case_stmt block <E>
  end

  rule case_stmt_construct_block
    case_stmt_construct* <E>
  end

  rule case_value
    # F90:R815

    scalar_int_initialization_expr /
    scalar_char_initialization_expr /
    scalar_logical_initialization_expr
  end

  rule case_value_range
    # F90:R814

    t_colon case_value <T> /
    case_value t_colon case_value <T> /
    case_value t_colon <T> /
    case_value
  end

  rule case_value_range_list
    case_value_range ( t_comma case_value_range )* <Case_Value_Range_List>
  end

  rule char_expr
    # F90:R726

    expr
  end

  rule char_initialization_expr
    # F90:R731

    char_expr
  end

  rule char_length
    # F90:R508

    t_paren_l type_param_value t_paren_r <T> /
    scalar_int_literal_constant
  end

  rule char_length_pair
    t_star char_length <T>
  end

  rule char_literal_constant
    # F90:R420

    ( kind_param t_underscore )? char_literal_constant_sq <T> /
    ( kind_param t_underscore )? char_literal_constant_dq <T>
  end

  rule char_literal_constant_dq
    t_quotemark ( !t_quotemark rep_char )* t_quotemark <T>
  end

  rule char_literal_constant_sq
    t_apostrophe ( !t_apostrophe rep_char )* t_apostrophe <T>
  end

  rule char_selector
    # F90:R506

    length_selector /
    t_paren_l len_pair type_param_value t_comma kind_pair scalar_int_initialization_expr t_paren_r <T> /
    t_paren_l type_param_value t_comma kind_pair? scalar_int_initialization_expr t_paren_r <T> /
    t_paren_l kind_pair scalar_int_initialization_expr ( t_comma len_pair type_param_value )? t_paren_r <T>
  end

  rule char_variable
    # F90:R605

    variable
  end

  rule character
    # F90:R301

    alphanumeric_character /
    special_character
  end

  rule close_spec
    # F90:R908

    t_iostat t_equal scalar_default_int_variable <T> /
    t_err t_equal label <T> /
    t_status t_equal scalar_default_char_expr <T> /
    ( t_unit t_equal )? external_file_unit <T>
  end

  rule close_spec_list
    close_spec ( t_comma close_spec )* <Close_Spec_List>
  end

  rule close_stmt
    # F90:R907

    label:label? t_close t_paren_l close_spec_list t_paren_r t_newline <StmtC>
  end

  rule common_block_name
    # Multiple uses (not explicitly defined)

    name "" <Common_Block_Name>
  end

  rule common_block_name_and_object_list
    t_comma? common_block_name_triplet common_block_object_list <Common_Block_Name_And_Object_List>
  end

  rule common_block_name_and_object_lists
    common_block_name_and_object_list* <E>
  end

  rule common_block_name_triplet
    t_slash common_block_name? t_slash <T>
  end

  rule common_block_object
    # F90:R549

    variable_name common_block_object_explicit_shape_spec_list? <T>
  end

  rule common_block_object_explicit_shape_spec_list
    parenthesized_explicit_shape_spec_list
  end

  rule common_block_object_list
    common_block_object common_block_object_pairs <E>
  end

  rule common_block_object_pair
    t_comma common_block_object <E>
  end

  rule common_block_object_pairs
    common_block_object_pair* <E>
  end

  rule common_stmt
    # F90:R548

    label:label? t_common common_block_name_triplet? common_block_object_list common_block_name_and_object_lists t_newline <Common_Stmt>
  end

  rule complex_literal_constant
    # F90:R417

    t_paren_l real_part t_comma imag_part t_paren_r <T>
  end

  rule component_array_spec
    # F90:R428

    explicit_shape_spec_list /
    deferred_shape_spec_list
  end

  rule component_attr_spec
    # F90:R427 + F95:R426 + F03:R441

    t_pointer /
    t_dimension t_paren_l component_array_spec t_paren_r <E> /
    t_allocatable
  end

  rule component_attr_spec_list
    component_attr_spec ( t_comma component_attr_spec )* <Component_Attr_Spec_List>
  end

  rule component_attr_spec_list_option
    ( t_comma component_attr_spec_list )? double_colon <T>
  end

  rule component_decl
    # F90:R429 + F95:R428

    component_name parenthesized_component_array_spec? ( t_star char_length )? component_initialization? <E>
  end

  rule component_decl_list
    component_decl ( t_comma component_decl )* <Component_Decl_List>
  end

  rule component_def_stmt
    # F90:R426

    label:label? type_spec component_attr_spec_list_option? component_decl_list t_newline <Component_Def_Stmt>
  end

  rule component_def_stmts
    component_def_stmt+ <E>
  end

  rule component_initialization
    # F95:R429

    t_equal initialization_expr <E> /
    t_point null_function_ref <T>
  end

  rule component_name
    # F90:4.4.1 (not explicitly defined)

    name "" <Component_Name>
  end

  rule computed_goto_stmt
    # F90:R837

    label:label? t_goto t_paren_l label_list t_paren_r t_comma? scalar_int_expr t_newline <Computed_Goto_Stmt>
  end

  rule concat_op
    # F90:R712

    "//" <T>
  end

  rule connect_spec
    # F90:R905

    t_iostat t_equal scalar_default_int_variable <T> /
    t_err t_equal label <T> /
    t_file t_equal file_name_expr <T> /
    t_status t_equal scalar_default_char_expr <T> /
    t_access t_equal scalar_default_char_expr <T> /
    t_form t_equal scalar_default_char_expr <T> /
    t_recl t_equal scalar_int_expr <T> /
    t_blank t_equal scalar_default_char_expr <T> /
    t_position t_equal scalar_default_char_expr <T> /
    t_action t_equal scalar_default_char_expr <T> /
    t_delim t_equal scalar_default_char_expr <T> /
    t_pad t_equal scalar_default_char_expr <T> /
    ( t_unit t_equal )? external_file_unit <T>
  end

  rule connect_spec_list
    connect_spec ( t_comma connect_spec )* <Connect_Spec_List>
  end

  rule constant
    # F90:R305

    literal_constant /
    named_constant
  end

  rule constant_subobject
    # F90:R702

    subobject
  end

  rule contains_stmt
    # F90:R1225

    label:label? t_contains t_newline <Contains_Stmt>
  end

  rule continue_stmt
    # F90:R841

    label:label? t_continue t_newline <StmtJ>
  end

  rule cycle_stmt
    # F90:R834

    label:label? t_cycle do_construct_name? t_newline <StmtJ>
  end

  rule data_i_do_object
    # F90:R536

    array_element !t_equal <E> /
    scalar_structure_component !t_equal <E> /
    data_implied_do
  end

  rule data_i_do_object_list
    data_i_do_object ( t_comma data_i_do_object )* <Data_I_Do_Object_List>
  end

  rule data_i_do_variable
    # F90:R537

    scalar_int_variable
  end

  rule data_implied_do
    # F90:R535

    t_paren_l data_i_do_object_list t_comma data_i_do_variable t_equal scalar_int_expr t_comma scalar_int_expr ( t_comma scalar_int_expr )* t_paren_r <T>
  end

  rule data_ref
    # F90:R612

    part_ref ( t_percent part_ref )* <Data_Ref>
  end

  rule data_stmt
    # F90:R529

    label:label? t_data data_stmt_set_list t_newline <Data_Stmt>
  end

  rule data_stmt_constant
    # F90:R533

    signed_real_literal_constant /
    signed_int_literal_constant /
    boz_literal_constant /
    structure_constructor /
    scalar_constant
  end

  rule data_stmt_object
    # F90:R531

    variable /
    data_implied_do
  end

  rule data_stmt_object_list
    data_stmt_object ( t_comma data_stmt_object )* <Data_Stmt_Object_List>
  end

  rule data_stmt_repeat
    # F90:R534

    scalar_int_constant
  end

  rule data_stmt_set
    # F90:R530

    data_stmt_object_list t_slash data_stmt_value_list t_slash <E>
  end

  rule data_stmt_set_list
    data_stmt_set data_stmt_set_list_pairs <E>
  end

  rule data_stmt_set_list_pair
    t_comma data_stmt_set <E>
  end

  rule data_stmt_set_list_pairs
    data_stmt_set_list_pair* <E>
  end

  rule data_stmt_value
    # F90:R531

    data_stmt_repeat_pair? data_stmt_constant <T>
  end

  rule data_stmt_repeat_pair
    data_stmt_repeat t_star <T>
  end

  rule data_stmt_value_list
    data_stmt_value ( t_comma data_stmt_value )* <Data_Stmt_Value_List>
  end

  rule deallocate_stmt
    # F90:R631

    label:label? t_deallocate t_paren_l allocate_object_list allocate_stat_construct? t_paren_r t_newline <Deallocate_Stmt>
  end

  rule declaration_construct
    # F90:R207

    derived_type_def /
    interface_block /
    type_declaration_stmt /
    specification_stmt /
    parameter_stmt /
    format_stmt /
    entry_stmt /
    stmt_function_stmt !{ |e| sp_is_array?(e[0]) } <E> /
    directive
  end

  rule declaration_constructs
    declaration_construct* <Declaration_Constructs>
  end

  rule default_char_variable
    # F90:R606

    variable
  end

  rule default_char_expr
    # F90:R727

    expr
  end

  rule default_int_variable
    # F90:R608

    variable
  end

  rule default_logical_variable
    # F90:R604

    variable
  end

  rule deferred_shape_spec
    # F90:R517

    t_colon "" <Deferred_Shape_Spec>
  end

  rule deferred_shape_spec_list
    deferred_shape_spec deferred_shape_spec_list_pair* <Deferred_Shape_Spec_List>
  end

  rule deferred_shape_spec_list_pair
    t_comma deferred_shape_spec <Deferred_Shape_Spec_List_Pair>
  end

  rule defined_binary_op
    # F90:R724

    t_dot t_letter t_letter+ t_dot <T>
  end

  rule defined_operator
    # F90:R311

    defined_unary_op /
    defined_binary_op /
    extended_intrinsic_op
  end

  rule defined_unary_op
    # F90:R704

    !( intrinsic_operator / logical_literal_constant ) t_dot t_letter t_letter+ t_dot <T>
  end

  rule derived_type_def
    # F90:R422

    derived_type_stmt private_sequence_stmts component_def_stmts end_type_stmt <E>
  end

  rule derived_type_stmt
    # F90:R424

    label:label? t_type derived_typeaccess_spec? type_name t_newline <Derived_Type_Stmt>
  end

  rule derived_typeaccess_spec
    ( t_comma access_spec )? double_colon <T>
  end

  rule digit_string
    # F90:R402

    t_digit+ <T>
  end

  rule dimension_stmt
    # F90:R525

    label:label? t_dimension double_colon? array_names_and_specs t_newline &{ |e| sp_dimension_stmt(e[3]) } <Dimension_Stmt>
  end

  rule directive
    # Note: Any "comment" not stripped out during normalization is a directive.

    "!" character+ t_newline <T>
  end

  rule do_block
    # F90:R823

    block
  end

  rule do_body
    # F90:R828

    execution_part_construct
  end

  rule do_construct
    # F90:R816
    #
    # Note: When either option is matched, the appropriate label-popping method
    # should be called. See those methods for more information.

    nonblock_do_construct &{ |e| dolabel_pop_nonblock } <E> /
    block_do_construct &{ |e| dolabel_pop_block } <E>
  end

  rule do_construct_name
    # F90:8.1.4.1.1 (not explicitly defiend)

    name "" <Do_Construct_Name>
  end

  rule do_construct_name_label
    do_construct_name t_colon <T>
  end

  rule do_stmt
    # F90:R818

    label_do_stmt /
    nonlabel_do_stmt
  end

  rule do_term_action_stmt
    # F90:R829

    !do_term_action_stmt_disallowed action_stmt &{ |e| nonblock_do_end?(e[1]) } <Do_Term_Action_Stmt>
  end

  rule do_term_action_stmt_disallowed
    arithmetic_if_stmt /
    assigned_goto_stmt /
    continue_stmt /
    cycle_stmt /
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    return_stmt /
    stop_stmt
  end

  rule do_term_shared_stmt
    # F90:R833

    !do_term_shared_stmt_disallowed action_stmt &{ |e| nonblock_do_end?(e[1]) } <Do_Term_Shared_Stmt>
  end

  rule do_term_shared_stmt_disallowed
    arithmetic_if_stmt /
    assigned_goto_stmt /
    cycle_stmt /
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    return_stmt /
    stop_stmt
  end

  rule do_variable
    # F90:R822

    scalar_variable
  end

  rule double_colon
    t_colon t_colon <Double_Colon>
  end

  rule dummy_arg
    # F90:R1221

    dummy_arg_name /
    t_star
  end

  rule dummy_arg_list
    dummy_arg ( t_comma dummy_arg )* <Dummy_Arg_List>
  end

  rule dummy_arg_list_option
    t_paren_l dummy_arg_list? t_paren_r <E>
  end

  rule dummy_arg_name
    # Multiple uses (not explicitly defined)

    name "" <Dummy_Arg_Name>
  end

  rule dummy_arg_name_list
    dummy_arg_name ( t_comma dummy_arg_name )* <Dummy_Arg_Name_List>
  end

  rule else_construct
    else_stmt block <E>
  end

  rule else_if_construct
    else_if_construct_element+ <E>
  end

  rule else_if_construct_element
    else_if_stmt block <E>
  end

  rule else_if_stmt
    # F90:R804

    label:label? t_elseif t_paren_l scalar_logical_expr t_paren_r t_then t_newline <Else_If_Stmt>
  end

  rule else_stmt
    # F90:R805

    label:label? t_else if_construct_name? t_newline <Else_Stmt>
  end

  rule elsewhere_construct
    elsewhere_stmt where_assignment_stmt_block <E>
  end

  rule elsewhere_stmt
    # F90:R742

    label:label? t_elsewhere t_newline <Elsewhere_Stmt>
  end

  rule end_block_data_option
    t_block t_data block_data_name? <End_Block_Data_Option>
  end

  rule end_block_data_stmt
    # F90:R1112

    label:label? t_end end_block_data_option? t_newline <End_Block_Data_Stmt>
  end

  rule end_do
    # F90:R824

    end_do_stmt /
    end_do_continue_stmt
  end

  rule end_do_continue_stmt
    label:label? t_continue t_newline <End_Do_Stmt>
  end

  rule end_do_stmt
    # F90:R825

    label:label? t_enddo do_construct_name? t_newline <End_Do_Stmt>
  end

  rule end_function_option
    t_function function_name? <J>
  end

  rule end_function_stmt
    # F90:R1218

    label:label? t_end end_function_option? t_newline <End_Function_Stmt>
  end

  rule end_if_stmt
    # F90:R806

    label:label? t_endif if_construct_name? t_newline <End_If_Stmt>
  end

  rule end_interface_stmt
    # F90:R1203 + F95:R1204

    label:label? t_end t_interface generic_spec_option? t_newline <End_Interface_Stmt>
  end

  rule end_module_option
    t_module module_name? <End_Module_Option>
  end

  rule end_module_stmt
    # F90:R1106

    label:label? t_end end_module_option? t_newline <End_Module_Stmt>
  end

  rule end_program_stmt
    # F90:R1103

    label:label? t_end !end_program_stmt_disallowed t_program? program_name? t_newline? <End_Program_Stmt>
  end

  rule end_program_stmt_disallowed
    t_block /
    t_function /
    t_interface /
    t_module /
    t_select /
    t_subroutine /
    t_type
  end

  rule end_select_stmt
    # F90:R811

    label:label? t_end t_select case_construct_name? t_newline <End_Select_Stmt>
  end

  rule end_subroutine_stmt
    # F90:R1222

    label:label? t_end end_subroutine_option? t_newline <End_Subroutine_Stmt>
  end

  rule end_subroutine_option
    t_subroutine subroutine_name? <J>
  end

  rule end_type_stmt
    # F90:R415

    label:label? t_end t_type type_name? t_newline <End_Type_Stmt>
  end

  rule end_where_stmt
    # F90:R743

    label:label? t_endwhere t_newline <End_Where_Stmt>
  end

  rule endfile_stmt
    # F90:R920

    label:label? t_endfile t_paren_l position_spec_list t_paren_r t_newline <StmtC> /
    label:label? t_endfile external_file_unit t_newline <StmtJ>
  end

  rule entity_decl
    # F90:R504 + F95:R504
    #
    # Note: Since all but the first element of each component list is optional,
    # the parser cannot distinguish between, e.g. "integer::f" where f is an
    # integer scalar, and "integer::f" where f is a function. If the function
    # has an explicit interface, it may be possible to disambiguate after
    # parsing; if not, it may only be possible to analyze actual uses of the
    # name to make a determination. If the name is never used, disambiguation
    # may be impossible, but it probably doesn't matter. Until it proves
    # problematic, allow uses like the above example to match the first choice.

    object_name entity_decl_array_spec? char_length_pair? initialization? <Entity_Decl_1> /
    function_name char_length_pair? <Entity_Decl_2>
  end

  rule entity_decl_array_spec
    t_paren_l array_spec t_paren_r <Entity_Decl_Array_Spec>
  end

  rule entity_decl_list
    entity_decl entity_decl_list_pairs <Entity_Decl_List>
  end

  rule entity_decl_list_pair
    t_comma entity_decl <Entity_Decl_List_Pair>
  end

  rule entity_decl_list_pairs
    entity_decl_list_pair* <Entity_Decl_List_Pairs>
  end

  rule entry_name
    # F90:12.5.2.5 (not explicitly defined)

    name "" <Entry_Name>
  end

  rule entry_stmt
    # F90:R1223

    label:label? t_entry entry_name dummy_arg_list_option? result_option? t_newline <Entry_Stmt>
  end

  rule equiv_op
    # F90:R722

    ".eqv." <T> /
    ".neqv." <T>
  end

  rule equiv_operand
    # F90:R715

    not_op? level_4_expr <E>
  end

  rule equivalence_object
    # F90:R547

    substring /
    array_element /
    variable_name
  end

  rule equivalence_object_list
    equivalence_object ( t_comma equivalence_object )? <T>
  end

  rule equivalence_set
    # F90:R546

    t_paren_l equivalence_object t_comma equivalence_object_list t_paren_r <T>
  end

  rule equivalence_set_list
    equivalence_set ( t_comma equivalence_set )* <Equivalence_Set_List>
  end

  rule equivalence_stmt
    # F90:R545

    label:label? t_equivalence equivalence_set_list t_newline <StmtJ>
  end

  rule executable_construct
    # F90:R215

    executable_construct_action_stmt /
    case_construct /
    do_construct /
    if_construct /
    where_construct /
    directive
  end

  rule executable_construct_action_stmt
    !execution_part_disallowed action_stmt !{ |e| nonblock_do_end?(e[1]) } <StmtJ>
  end

  rule execution_part
    # F90:R208

    executable_construct execution_part_construct <Execution_Part>
  end

  rule execution_part_disallowed
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt
  end

  rule execution_part_construct
    # F90:R209

    ( executable_construct / format_stmt / data_stmt / entry_stmt )* <E>
  end

  rule exit_stmt
    # F90:R835

    label:label? t_exit do_construct_name? t_newline <StmtJ>
  end

  rule explicit_shape_spec
    # F90:R513

    lower_bound_pair? upper_bound <Explicit_Shape_Spec>
  end

  rule explicit_shape_spec_list
    explicit_shape_spec explicit_shape_spec_list_pair* <Explicit_Shape_Spec_List>
  end

  rule explicit_shape_spec_list_pair
    t_comma explicit_shape_spec <Explicit_Shape_Spec_List_Pair>
  end

  rule exponent
    # F90:R416

    signed_digit_string
  end

  rule exponent_letter
    # F90:R415

    [ed] <T>
  end

  rule expr
    # F90:R723
    #
    # Note: Left-recursive rule implied by standard:
    # ( expr defined_binary_op )? level_5_expr

    level_5_expr ( defined_binary_op expr )? <Expr>
  end

  rule expr_list
    expr ( t_comma expr )* <Expr_List>
  end

  rule extended_intrinsic_op
    # F90:R312

    intrinsic_operator
  end

  rule external_file_unit
    # F90:R902

    scalar_int_expr
  end

  rule external_name
    # F90:12.3.2.2

    name "" <External_Name>
  end

  rule external_name_list
    external_name ( t_comma external_name )* <External_Name_List>
  end

  rule external_stmt
    # F90:R1207

    label:label? t_external external_name_list t_newline <StmtJ>
  end

  rule external_subprogram
    # F90:R203

    subroutine_subprogram &{ |e| sp_subroutine_subprogram } <E> /
    function_subprogram &{ |e| sp_function_subprogram } <E> /
    directive
  end

  rule file_name_expr
    # F90:R906

    scalar_default_char_expr
  end

  rule format
    # F90:R913

    default_char_expr /
    label /
    t_star /
    scalar_default_int_variable
  end

  rule format_specification
    # F90:R1002
    #
    # Note: See NOTES file about F90:R1002

    t_paren_l format_specification_element+ t_paren_r <T>
  end

  rule format_specification_element
    format_specification /
    char_literal_constant /
    ( !( t_paren_l / t_paren_r / t_apostrophe / t_quotemark ) character )+ <T>
  end

  rule format_stmt
    # F90:R1001

    label t_format format_specification t_newline <StmtJ>
  end

  rule function_name
    # Multiple uses (not explicitly defined)

    name "" <Function_Name>
  end

  rule function_reference
    # F90:R1209

    function_name t_paren_l actual_arg_spec_list? t_paren_r !{ |e| sp_is_array?(e[0]) } <Function_Reference>
  end

  rule function_stmt
    # F90:R1216

    label:label? prefix_function? t_function function_name t_paren_l dummy_arg_name_list? t_paren_r result_option? t_newline &{ |e| sp_function_stmt(e[5]) } <Function_Stmt>
  end

  rule function_subprogram
    # F90:R1215

    function_stmt specification_part? execution_part? internal_subprogram_part? end_function_stmt <Function_Subprogram>
  end

  rule generic_name
    # F90:12.3.2.1 (not explicitly defined)

    name "" <Generic_Name>
  end

  rule generic_spec
    # F90:R1206

    generic_spec_option /
    generic_name
  end

  rule generic_spec_option_1
    t_operator t_paren_l defined_operator t_paren_r <Generic_Spec>
  end

  rule generic_spec_option_2
    t_assignment t_paren_l t_equal t_paren_r <Generic_Spec>
  end

  rule generic_spec_option
    generic_spec_option_1 /
    generic_spec_option_2
  end

  rule goto_stmt
    # F90:R836

    label:label? t_goto label t_newline <StmtJ>
  end

  rule hex_constant
    # F90:R410

    "z" ( ( t_apostrophe hex_digit+ t_apostrophe ) / ( t_quotemark hex_digit+ t_quotemark ) ) <T>
  end

  rule hex_digit
    # F90:R411

    [0123456789abcdef]
  end

  rule if_construct
    # F90:R802
    #
    # Note: if_then_construct, else_if_construct and else_construct added for
    # clarity, not specified in standard.

    label:label? if_then_construct else_if_construct? else_construct? end_if_stmt <E>
  end

  rule if_construct_name
    # Multiple uses (not explicitly defined)

    name "" <If_Construct_Name>
  end

  rule if_construct_name_label
    if_construct_name t_colon <T>
  end

  rule if_stmt
    # F90:R807

    label:label? t_if t_paren_l scalar_logical_expr t_paren_r action_stmt <If_Stmt>
  end

  rule if_then_construct
    if_then_stmt block <E>
  end

  rule if_then_stmt
    # F90:R803

    label:label? if_construct_name_label? t_if t_paren_l scalar_logical_expr t_paren_r t_then t_newline <If_Then_Stmt>
  end

  rule imag_part
    # F90:R419

    signed_real_literal_constant /
    signed_int_literal_constant
  end

  rule implicit_part
    # F90:R205
    #
    # Note: The standard insists that the last statement in implicit_part be
    # an implicit_stmt but, given that this seems unlikely to affect parsing,
    # and the availibility of 3rd-party syntax-checking compilers, it is not
    # enforced here.

    implicit_part_stmt+ <E> /
    directive
  end

  rule implicit_part_stmt
    # F90:R206

    implicit_stmt /
    format_stmt /
    parameter_stmt /
    entry_stmt
  end

  rule implicit_spec
    # F90:R541

    type_spec_with_kind_selector t_paren_l letter_spec_list t_paren_r <T> /
    type_spec_without_kind_selector t_paren_l letter_spec_list t_paren_r <T>
  end

  rule implicit_spec_list
    implicit_spec ( t_comma implicit_spec )* <Implicit_Spec_List>
  end

  rule implicit_stmt
    # F90:R540

    label:label? t_implicit t_none t_newline <Implicit_None_Stmt> /
    label:label? t_implicit implicit_spec_list t_newline <Implicit_Stmt>
  end

  rule initialization
    # F95:R505

    t_equal initialization_expr <Initialization_1> /
    t_point null_function_ref <Initialization_2>
  end

  rule initialization_expr
    # F90:R730

    expr
  end

  rule inner_shared_do_construct
    # F90:R832
    #
    # Note: For this rule to match, the label on the label_do_stmt must match
    # that of the enclosing outer_shared_do_construct, which has already been
    # pushed onto the stack.

    label_do_stmt &{ |e| dolabel_repeat? } do_body do_term_shared_stmt <Inner_Shared_Do_Construct>
  end

  rule input_item
    # F90:R914

    io_implied_do /
    variable
  end

  rule input_item_list
    # F90:9.4.2

    input_item ( t_comma input_item )* <Input_Item_List>
  end

  rule inquire_spec
    # F90:R924

    external_file_unit &t_comma <T> /
    t_unit t_equal external_file_unit <T> /
    t_file t_equal file_name_expr <T> /
    t_iostat t_equal scalar_default_int_variable <T> /
    t_err t_equal label <T> /
    t_exist t_equal scalar_default_logical_variable <T> /
    t_opened t_equal scalar_default_logical_variable <T> /
    t_number t_equal scalar_default_int_variable <T> /
    t_named t_equal scalar_default_logical_variable <T> /
    t_name t_equal scalar_default_char_variable <T> /
    t_access t_equal scalar_default_char_variable <T> /
    t_sequential t_equal scalar_default_char_variable <T> /
    t_direct t_equal scalar_default_char_variable <T> /
    t_form t_equal scalar_default_char_variable <T> /
    t_formatted t_equal scalar_default_char_variable <T> /
    t_unformatted t_equal scalar_default_char_variable <T> /
    t_recl t_equal scalar_default_int_variable <T> /
    t_nextrec t_equal scalar_default_int_variable <T> /
    t_blank t_equal scalar_default_char_variable <T> /
    t_position t_equal scalar_default_char_variable <T> /
    t_action t_equal scalar_default_char_variable <T> /
    t_read t_equal scalar_default_char_variable <T> /
    t_write t_equal scalar_default_char_variable <T> /
    t_readwrite t_equal scalar_default_char_variable <T> /
    t_delim t_equal scalar_default_char_variable <T> /
    t_pad t_equal scalar_default_char_variable <T>
  end

  rule inquire_spec_list
    inquire_spec ( t_comma inquire_spec )* <Inquire_Spec_List>
  end

  rule inquire_stmt
    # F90:R923

    label:label? t_inquire t_paren_l inquire_spec_list t_paren_r t_newline <StmtC> /
    label:label? t_inquire t_paren_l t_iolength t_equal scalar_default_int_variable t_paren_r output_item_list t_newline <StmtC>
  end

  rule int_expr
    # F90:R728

    expr
  end

  rule int_initialization_expr
    # F90:R732

    int_expr
  end

  rule int_literal_constant
    # F90:R404

    digit_string ( t_underscore kind_param )? <T>
  end

  rule int_variable
    # F90:R607

    variable
  end

  rule intent_spec
    # F90:R511

    t_in /
    t_out /
    t_inout
  end

  rule intent_stmt
    # F90:R519

    label:label? t_intent t_paren_l intent_spec t_paren_r double_colon? dummy_arg_name_list t_newline <Intent_Stmt>
  end

  rule interface_block
    # F90:R1201

    interface_stmt interface_bodies module_procedure_stmts end_interface_stmt <E>
  end

  rule interface_bodies
    interface_body* <E>
  end

  rule interface_body
    # F90:R1204

    subroutine_stmt specification_part? end_subroutine_stmt <Interface_Body_1> /
    function_stmt specification_part? end_function_stmt <Interface_Body_2>
  end

  rule interface_stmt
    # F90:R1202

    label:label? t_interface generic_spec? t_newline <Interface_Stmt>
  end

  rule internal_file_unit
    # F90:R903

    default_char_variable
  end

  rule internal_subprogram_part
    # F90:R210

    contains_stmt internal_subprograms <E>
  end

  rule internal_subprogram
    # F90:R211

    subroutine_subprogram &{ |e| sp_subroutine_subprogram } <E> /
    function_subprogram &{ |e| sp_function_subprogram } <E> /
    directive
  end

  rule internal_subprograms
    internal_subprogram+ <Internal_Subprograms>
  end

  rule intrinsic_operator
    # F90:R310

    power_op /
    mult_op /
    add_op /
    concat_op /
    rel_op /
    not_op /
    and_op /
    or_op /
    equiv_op
  end

  rule intrinsic_procedure_name
    # F90:12.3.2.3 (not explicitly defined)

    name "" <Intrinsic_Procedure_Name>
  end

  rule intrinsic_procedure_name_list
    intrinsic_procedure_name ( t_comma intrinsic_procedure_name )* <Intrinsic_Procedure_Name_List>
  end

  rule intrinsic_stmt
    # F90:R1208

    label:label? t_intrinsic intrinsic_procedure_name_list t_newline <StmtJ>
  end

  rule io_control_spec
    # F90:R912

    io_unit t_comma format !t_equal <T> /
    io_unit t_comma namelist_group_name !t_equal <T> /
    t_advance t_equal scalar_default_char_expr <T> /
    t_io_control_spec_end t_equal label <T> /
    t_eor t_equal label <T> /
    t_err t_equal label <T> /
    t_fmt t_equal format <T> /
    t_iostat t_equal scalar_default_int_variable <T> /
    t_nml t_equal namelist_group_name <T> /
    t_rec t_equal scalar_int_expr <T> /
    t_size t_equal scalar_default_int_variable <T> /
    t_unit t_equal io_unit <T> /
    io_unit
  end

  rule io_control_spec_list
    io_control_spec ( t_comma io_control_spec )* <IO_Control_Spec_List>
  end

  rule io_implied_do
    # F90:R916

    t_paren_l io_implied_do_object_list t_comma io_implied_do_control t_paren_r <E>
  end

  rule io_implied_do_control
    # F90:R918

    do_variable t_equal scalar_numeric_expr t_comma scalar_numeric_expr ( t_comma scalar_numeric_expr )? <T>
  end

  rule io_implied_do_object
    # F90:R917

    output_item !t_equal <E> /
    input_item !t_equal <E>
  end

  rule io_implied_do_object_list
    io_implied_do_object ( t_comma io_implied_do_object )* <IO_Implied_Do_Object_List>
  end

  rule io_unit
    # F90:R901

    t_star /
    external_file_unit /
    internal_file_unit
  end

  rule keyword
    # F90:R1212

    dummy_arg_name
  end

  rule keyword_option
    keyword_pair?
  end

  rule keyword_pair
    keyword t_equal <T>
  end

  rule kind_pair
    t_kind t_equal <T>
  end

  rule kind_param
    # F90:R405

    digit_string /
    scalar_int_constant_name
  end

  rule kind_selector
    # F90:R505

    t_paren_l kind_pair? scalar_int_initialization_expr t_paren_r <Kind_Selector>
  end

  rule label
    # F90:R313

    t_digit 1..5 <T>
  end

  rule label_do_stmt
    # F90:R819

    label:label? do_construct_name_label? t_do label loop_control? t_newline &{ |e| dolabel_push(e[3]) } <Label_Do_Stmt>
  end

  rule label_list
    label ( t_comma label )* <Label_List>
  end

  rule len_pair
    t_len t_equal <T>
  end

  rule length_selector
    # F90:R507

    t_paren_l len_pair? type_param_value t_paren_r <T> /
    char_length_pair &( [^\:\n]* double_colon ) <T> /
    char_length_pair t_comma? <T>
  end

  rule letter_spec
    # F90:R542

    t_letter ( t_minus t_letter )? <T>
  end

  rule letter_spec_list
    letter_spec ( t_comma letter_spec )* <Letter_Spec_List>
  end

  rule level_1_expr
    # F90:R703

    defined_unary_op? primary <E>
  end

  rule level_2_expr
    # F90:R707
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_2_expr? add_op )? add_operand

    add_op? add_operand level_2_expr? <E>
  end

  rule level_3_expr
    # F90:R711
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr concat_op )? level_2_expr

    level_2_expr level_3_expr_option? <E>
  end

  rule level_3_expr_option
    concat_op level_3_expr <E>
  end

  rule level_4_expr
    # F90:R713
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr rel_op )? level_3_expr

    level_3_expr level_4_expr_option? <E>
  end

  rule level_4_expr_option
    rel_op level_3_expr <E>
  end

  rule level_5_expr
    # F90:R718
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_5_expr equiv_op)? equiv_operand

    equiv_operand level_5_expr_option? <E>
  end

  rule level_5_expr_option
    equiv_op level_5_expr <T>
  end

  rule literal_constant
    # F90:R306
    #
    # Note: The choice order is different than that given in the standard, e.g.
    # an int_literal_constant should only be matched after failure to match a
    # real_literal_constant. Also, signed versions of real_literal_constant and
    # int_literal_constant are used here, though the standard (seemingly
    # incorrectly) specifies the unsigned versions.

    complex_literal_constant /
    signed_real_literal_constant /
    signed_int_literal_constant /
    logical_literal_constant /
    char_literal_constant /
    boz_literal_constant
  end

  rule local_name
    # F90:11.3.2 (not explicitly defined)

    name "" <Local_Name>
  end

  rule logical_expr
    # F90:R725

    expr
  end

  rule logical_initialization_expr
    # F90:R733

    logical_expr
  end

  rule logical_literal_constant
    # F90:R421

    ( t_true / t_false ) ( t_underscore kind_param )? <T>
  end

  rule logical_variable
    # F90:R603

    variable
  end

  rule loop_control
    # F90:R821

    t_comma? do_variable t_equal scalar_numeric_expr loop_control_pair loop_control_pair? <Loop_Control_1> /
    t_comma? t_while t_paren_l scalar_logical_expr t_paren_r <Loop_Control_2>
  end

  rule loop_control_pair
    t_comma scalar_numeric_expr <Loop_Control_Pair>
  end

  rule lower_bound
    # F90:R514

    specification_expr
  end

  rule lower_bound_pair
    lower_bound t_colon <Lower_Bound_Pair>
  end

  rule main_program
    # F90:R1101

    program_stmt? specification_part? execution_part? internal_subprogram_part? end_program_stmt <Main_Program>
  end

  rule mask_expr
    # F90:R741

    logical_expr
  end

  rule module
    # F90:R1104

    module_stmt specification_part? module_subprogram_part? end_module_stmt <Module>
  end

  rule module_name
    # F90:11.3 (not explicitly defined)

    name "" <Module_Name>
  end

  rule module_procedure_stmt
    # F90:R1205

    label:label? t_module t_procedure procedure_name_list t_newline <StmtJ>
  end

  rule module_procedure_stmts
    module_procedure_stmt* <E>
  end

  rule module_stmt
    # F90:R1105

    label:label? t_module module_name t_newline &{ |e| sp_module_stmt } <Module_Stmt>
  end

  rule module_subprogram
    # F90:R213

    subroutine_subprogram &{ |e| sp_subroutine_subprogram } <E> /
    function_subprogram &{ |e| sp_function_subprogram } <E> /
    directive
  end

  rule module_subprogram_part
    # F90:R212

    contains_stmt module_subprogram+ <Module_Subprogram_Part>
  end

  rule mult_op
    # F90:R709

    t_star /
    t_slash
  end

  rule mult_operand
    # F90:R705

    level_1_expr power_op_option? <Mult_Operand>
  end

  rule name
    # F90:R304

    t_letter alphanumeric_character* <Name>
  end

  rule named_constant
    # F90:R307

    name "" <Named_Constant>
  end

  rule named_constant_def
    # F90:R539

    named_constant t_equal initialization_expr <E>
  end

  rule named_constant_def_list
    named_constant_def ( t_comma named_constant_def )* <Named_Constant_Def_List>
  end

  rule namelist_group_name
    # Multiple uses (not explicitly defined)

    name "" <Namelist_Group_Name>
  end

  rule namelist_group_object
    # F90:R544

    variable_name
  end

  rule namelist_group_object_list
    namelist_group_object ( t_comma namelist_group_object )* <Namelist_Group_Object_List>
  end

  rule namelist_group_set
    t_slash namelist_group_name t_slash namelist_group_object_list <Namelist_Group_Set>
  end

  rule namelist_group_set_pair
    t_comma? namelist_group_set <Namelist_Group_Set_Pair>
  end

  rule namelist_group_sets
    namelist_group_set_pair* <Namelist_Group_Sets>
  end

  rule namelist_stmt
    # F90:R543

    label:label? t_namelist namelist_group_set namelist_group_sets t_newline <Namelist_Stmt>
  end

  rule nonblock_do_construct
    # F90:R826

    outer_shared_do_construct /
    action_term_do_construct
  end

  rule nonlabel_do_stmt
    # F90:R820

    label:label? do_construct_name_label? t_do loop_control? t_newline &{ |e| dolabel_push(:nolabel) } <Nonlabel_Do_Stmt>
  end

  rule not_op
    # F90:R719

    ".not." <T>
  end

  rule null_function_ref
    t_null t_paren_l t_paren_r <T>
  end

  rule nullify_stmt
    # F90:R629

    label:label? t_nullify t_paren_l pointer_object_list t_paren_r t_newline <StmtC>
  end

  rule numeric_expr
    # F90:R729

    expr
  end

  rule object_name
    # Multiple uses (not explicitly defined)

    name "" <Object_Name>
  end

  rule object_name_and_spec_list
    object_name parenthesized_deferred_shape_spec_list? <E>
  end

  rule object_name_and_spec_list_pair
    t_comma object_name_and_spec_list <E>
  end

  rule object_names_and_spec_lists
    object_name_and_spec_list object_name_and_spec_list_pair* <T>
  end

  rule octal_constant
    # F90:R409

    "o" ( ( t_apostrophe t_octal+ t_apostrophe ) / ( t_quotemark t_octal+ t_quotemark ) ) <T>
  end

  rule only
    # F90:R1109

    only_option? use_name <Only> /
    access_id
  end

  rule only_list
    only only_list_pair* <Only_List>
  end

  rule only_list_pair
    t_comma only <Only_List_Pair>
  end

  rule only_option
    local_name t_point <Only_Option>
  end

  rule open_stmt
    # F90:R904

    label:label? t_open t_paren_l connect_spec_list t_paren_r t_newline <StmtC>
  end

  rule optional_stmt
    # F90:R520

    label:label? t_optional double_colon? dummy_arg_name_list t_newline <Optional_Stmt>
  end

  rule or_op
    # F90:R721

    ".or." <T>
  end

  rule outer_shared_do_construct
    # F90:R830
    #
    # Note: The label on label_do_stmt may match that of an enclosing o_s_d_c
    # (e.g. the second level in a triply-nested loop), or may not (e.g. in the
    # outermost o_s_d_c in a triply-nested loop).

    label_do_stmt do_body shared_term_do_construct <E>
  end

  rule output_item
    # F90:R915

    io_implied_do /
    expr
  end

  rule output_item_list
    # F90:9.4.2

    output_item ( t_comma output_item )* <Output_Item_List>
  end

  rule parameter_stmt
    # F90:R538

    label:label? t_parameter t_paren_l named_constant_def_list t_paren_r t_newline <StmtC>
  end

  rule parent_string
    # F90:R610

    array_element /
    scalar_structure_component /
    scalar_variable_name /
    scalar_constant
  end

  rule parenthesized_allocate_shape_spec_list
    t_paren_l allocate_shape_spec_list t_paren_r <T>
  end

  rule parenthesized_args
    t_paren_l actual_arg_spec_list? t_paren_r <T>
  end

  rule parenthesized_component_array_spec
    t_paren_l component_array_spec t_paren_r <T>
  end

  rule parenthesized_deferred_shape_spec_list
    t_paren_l deferred_shape_spec_list t_paren_r <Parenthesized_Deferred_Shape_Spec_List>
  end

  rule parenthesized_explicit_shape_spec_list
    t_paren_l explicit_shape_spec_list t_paren_r <Parenthesized_Explicit_Shape_Spec_List>
  end

  rule parenthesized_expr
    t_paren_l expr t_paren_r <E>
  end

  rule parenthesized_section_subscript_list
    t_paren_l section_subscript_list t_paren_r <Parenthesized_Section_Subscript_List>
  end

  rule part_name
    # Multiple uses (not explicitly defined)

    name "" <Part_Name>
  end

  rule part_ref
    # F90:R613

    part_name parenthesized_section_subscript_list? <Part_Ref>
  end

  rule pause_stmt
    # F90:R844

    label:label? t_pause stop_code? t_newline <StmtJ>
  end

  rule pointer_assignment_stmt
    # F90:R736

    label:label? pointer_object t_point target t_newline <StmtC>
  end

  rule pointer_object
    # F90:R630

    structure_component /
    variable_name
  end

  rule pointer_object_list
    pointer_object ( t_comma pointer_object )* <Pointer_Object_List>
  end

  rule pointer_stmt
    # F90:R527

    label:label? t_pointer double_colon? object_names_and_spec_lists t_newline <Pointer_Stmt>
  end

  rule position_spec
    # F90:R922

    external_file_unit &t_comma <T> /
    t_unit t_equal external_file_unit <T> /
    t_iostat t_equal scalar_default_int_variable <T> /
    t_err t_equal label
  end

  rule position_spec_list
    position_spec ( t_comma position_spec )* <Position_Spec_List>
  end

  rule power_op
    # F90:R708

    "**" <Power_Op>
  end

  rule power_op_option
    power_op mult_operand <Power_Op_Option>
  end

  rule prefix_function
    # F90:R1217 + F95:1219

    prefix_function_option+ <Prefix_Function>
  end

  rule prefix_function_option
    type_spec /
    t_elemental /
    t_pure /
    t_recursive
  end

  rule prefix_subroutine
    # F95:1219

    prefix_subroutine_option+ <Prefix_Subroutine>
  end

  rule prefix_subroutine_option
    t_elemental /
    t_pure /
    t_recursive
  end

  rule primary
    # F90:R701

    function_reference /
    variable /
    constant /
    constant_subobject /
    array_constructor /
    structure_constructor /
    parenthesized_expr
  end

  rule print_stmt
    # F90:R911

    label:label? t_print format print_stmt_output_item_list? t_newline <Print_Stmt>
  end

  rule print_stmt_output_item_list
    t_comma output_item_list <Print_Stmt_Output_Item_List>
  end

  rule private_sequence_stmt
    # F90:R423

    label:label? ( t_private / t_sequence ) t_newline <StmtC>
  end

  rule private_sequence_stmts
    private_sequence_stmt* <E>
  end

  rule procedure_name
    # F90:12.4.1

    name "" <Procedure_Name>
  end

  rule procedure_name_list
    procedure_name ( t_comma procedure_name )* <Procedure_Name_List>
  end

  rule program_name
    # F90:11.1

    name "" <Program_Name>
  end

  rule program_stmt
    # F90:R1102

    label:label? t_program program_name t_newline <Program_Stmt>
  end

  rule program_unit
    # F90:R202

    external_subprogram /
    module &{ |e| sp_module(e[0]) } <E> /
    block_data &{ |e| sp_block_data } <E> /
    main_program &{ |e| sp_main_program } <E>
  end

  rule program_units
    program_unit+ <Program_Units>
  end

  rule read_stmt
    # F90:R909

    label:label? t_read t_paren_l io_control_spec_list t_paren_r input_item_list? t_newline <Read_Stmt_1> /
    label:label? t_read format read_stmt_input_item_list_option? t_newline <Read_Stmt_2>
  end

  rule read_stmt_input_item_list_option
    t_comma input_item_list <T>
  end

  rule real_literal_constant
    # F90:R413

    significand ( exponent_letter exponent )? ( t_underscore kind_param )? <T> /
    digit_string exponent_letter exponent ( t_underscore kind_param )? <T>
  end

  rule real_part
    # F90:R418

    signed_real_literal_constant /
    signed_int_literal_constant
  end

  rule rel_op_eq
    ".eq." <T> /
    "==" <T>
  end

  rule rel_op_ge
    ".ge." <T> /
    ">=" <T>
  end

  rule rel_op_gt
    ".gt." <T> /
    t_gt
  end

  rule rel_op_le
    ".le." <T> /
    "<=" <T>
  end

  rule rel_op_lt
    ".lt." <T> /
    t_lt
  end

  rule rel_op_ne
    ".ne." <T> /
    "/=" <T>
  end

  rule rel_op
    # F90:R714

    rel_op_eq /
    rel_op_ne /
    rel_op_le /
    rel_op_lt /
    rel_op_ge /
    rel_op_gt
  end

  rule rename
    # F90:R1108

    local_name t_point use_name <Rename>
  end

  rule rename_list
    rename rename_list_pair* <Rename_List>
  end

  rule rename_list_pair
    t_comma rename <Rename_List_Pair>
  end

  rule rename_list_option
    t_comma rename_list <Rename_List_Option>
  end

  rule rep_char
    # F90:4.3.2.1 (processor-dependent)

    character /
    [\[\]\~\`\@\#\^\|\{\}]
  end

  rule result_name
    # Multiple uses (not explicitly defined)

    name "" <Result_Name>
  end

  rule result_option
    t_result t_paren_l result_name t_paren_r <T>
  end

  rule return_stmt
    # F90:R1224

    label:label? t_return scalar_int_expr? t_newline <J>
  end

  rule rewind_stmt
    # F90:R921

    label:label? t_rewind t_paren_l position_spec_list t_paren_r t_newline <StmtC> /
    label:label? t_rewind external_file_unit t_newline <StmtJ>
  end

  rule save_stmt
    # F90:R523

    label:label? t_save save_stmt_entity_list? t_newline <Save_Stmt>
  end

  rule save_stmt_entity_list
    double_colon? saved_entity_list <Save_Stmt_Entity_List>
  end

  rule saved_entity
    # F90:R524

    object_name /
    t_slash common_block_name t_slash <E>
  end

  rule saved_entity_list
    saved_entity ( t_comma saved_entity )* <Saved_Entity_List>
  end

  rule scalar_char_constant
    # F90:8.4 (not explicitly defined)

    char_literal_constant /
    named_constant
  end

  rule scalar_char_expr
    # F90:8.1.3.1

    char_expr
  end

  rule scalar_char_initialization_expr
    # F90:8.1.3.1 (not explicitly defined)

    initialization_expr
  end

  rule scalar_constant
    # Multiple uses (not explicitly defined)

    literal_constant /
    named_constant
  end

  rule scalar_default_char_expr
    # Multiple uses (not explicitly defined)

    default_char_expr
  end

  rule scalar_default_char_variable
    # F90:9.6.1 (not explicitly defined)

    default_char_variable
  end

  rule scalar_default_int_variable
    # Multiple uses (not explicitly defined)

    variable
  end

  rule scalar_default_logical_variable
    # F90:9.6.1 (not explicitly defined)

    default_logical_variable
  end

  rule scalar_expr
    # F90:12.5.4 (not explicitly defined)

    expr
  end

  rule scalar_int_constant
    # Multiple uses (not explicitly defined)

    scalar_int_literal_constant /
    scalar_int_constant_name
  end

  rule scalar_int_constant_name
    # F90:4.3.1.1 (not explicitly defined)

    named_constant
  end

  rule scalar_int_expr
    # Multiple uses (not explicitly defined)

    expr
  end

  rule scalar_int_initialization_expr
    # Multiple uses (not explicitly defined)

    initialization_expr
  end

  rule scalar_int_literal_constant
    # F90:5.1.1.5 (not explicitly defined)

    signed_int_literal_constant
  end

  rule scalar_int_variable
    # Multiple uses (not explicitly defined)

    variable
  end

  rule scalar_logical_expr
    # Multiple uses (not explicitly defined)

    logical_expr
  end

  rule scalar_logical_initialization_expr
    # F90:8.1.3.1 (not explicitly defined)

    initialization_expr
  end

  rule scalar_numeric_expr
    # Multiple users (not explicitly defined)

    numeric_expr
  end

  rule scalar_structure_component
    # Multiple uses (not explicitly defined)

    structure_component
  end

  rule scalar_variable
    # F90:8.1.4.1.1 (not explicitly defiend)

    scalar_variable_name
  end

  rule scalar_variable_name
    # Section 6 (not explicitly defined)

    variable_name
  end

  rule section_subscript
    # F90:R618

    subscript_triplet /
    vector_subscript /
    subscript
  end

  rule section_subscript_list
    section_subscript ( t_comma section_subscript )* <Section_Subscript_List>
  end

  rule select_case_stmt
    # F90:R809

    label:label? case_construct_name_pair? t_select t_case t_paren_l case_expr t_paren_r t_newline <Select_Case_Stmt>
  end

  rule shared_term_do_construct
    # F90:R831

    inner_shared_do_construct /
    outer_shared_do_construct
  end

  rule sign
    # F90:R406

    t_plus /
    t_minus
  end

  rule signed_digit_string
    # F90:R401

    sign? digit_string <T>
  end

  rule signed_int_literal_constant
    # F90:R403

    sign? int_literal_constant <T>
  end

  rule signed_real_literal_constant
    # F90:R412

    sign? real_literal_constant <T>
  end

  rule significand
    # F90:R414

    digit_string t_dot !significand_disallowed digit_string? <T> /
    t_dot digit_string <T>
  end

  rule significand_disallowed
    # Note: The use of this rule as a negative lookahead assertion in rule
    # significand allows parsing of an if_then_stmt like:
    #
    #  if (a>0.and.b>1) then
    #
    # Without the negative lookahead assertion, "0." would be recognized as a
    # real_literal_constant and consumed, and the parse would fail.

    "and." /
    "or."
  end

  rule special_character
    # F90:3.1.4

    [\ \=\+\-\*\/\(\)\,\.\'\:\!\"\%\&\;\<\>\?\$]
  end

  rule specification_expr
    # F90:R734

    scalar_int_expr
  end

  rule specification_part
    # F90:R204

    use_part implicit_part? declaration_constructs <Specification_Part>
  end

  rule specification_stmt
    # F90:R214

    access_stmt /
    allocatable_stmt /
    common_stmt /
    data_stmt /
    dimension_stmt /
    equivalence_stmt /
    external_stmt /
    intent_stmt /
    intrinsic_stmt /
    namelist_stmt &{ |e| sp_namelist_stmt(e[0]) } <E> /
    optional_stmt /
    pointer_stmt /
    save_stmt /
    target_stmt
  end

  rule star_int
    t_star int_literal_constant <Star_Int>
  end

  rule stat_variable
    # F90:R623

    scalar_int_variable
  end

  rule stmt_function_stmt
    # F90:R1226

    label:label? function_name t_paren_l dummy_arg_name_list? t_paren_r t_equal scalar_expr t_newline <Stmt_Function_Stmt>
  end

  rule stop_code
    # F90:R843

    scalar_char_constant /
    t_digit 1..5 <T>
  end

  rule stop_stmt
    # F90:R842

    label:label? t_stop stop_code? t_newline <StmtJ>
  end

  rule stride
    # F90:R620

    scalar_int_expr
  end

  rule structure_component
    # F90:R614

    data_ref
  end

  rule structure_constructor
    # F90:R430

    type_name t_paren_l expr_list t_paren_r <E>
  end

  rule subroutine_name
    # Multiple uses (not explicitly defined)

    name "" <Subroutine_Name>
  end

  rule subroutine_stmt
    # F90:R1220 + F95:1222

    label:label? prefix_subroutine? t_subroutine subroutine_name dummy_arg_list_option? t_newline &{ |e| sp_subroutine_stmt(e[4]) } <Subroutine_Stmt>
  end

  rule subroutine_subprogram
    # F90:R1219

    subroutine_stmt specification_part? execution_part? internal_subprogram_part? end_subroutine_stmt <Subroutine_Subprogram>
  end

  rule subscript
    # F90:R617

    scalar_int_expr
  end

  rule subscript_triplet
    # F90:R619

    subscript? t_colon subscript? ( t_colon stride )? <T>
  end

  rule subobject
    # F90:R602

    array_section /
    array_element /
    structure_component /
    substring
  end

  rule substring
    # F90:R609

    parent_string t_paren_l substring_range t_paren_r <Substring>
  end

  rule substring_range
    # F90:R611

    scalar_int_expr? t_colon scalar_int_expr? <T>
  end

  rule substring_range_triplet
    t_paren_l substring_range t_paren_r <E>
  end

  rule t_access
    "access" <T>
  end

  rule t_action
    "action" <T>
  end

  rule t_advance
    "advance" <T>
  end

  rule t_allocatable
    "allocatable" <T>
  end

  rule t_allocate
    "allocate" <T>
  end

  rule t_apostrophe
    "'" <T>
  end

  rule t_assign
    "assign" !"ment" <T>
  end

  rule t_assignment
    "assignment" <T>
  end

  rule t_backspace
    "backspace" <T>
  end

  rule t_binary
    [01] <T>
  end

  rule t_blank
    "blank" <T>
  end

  rule t_block
    "block" <T>
  end

  rule t_call
    "call" <T>
  end

  rule t_case
    "case" <T>
  end

  rule t_character
    "character" <T>
  end

  rule t_close
    "close" <T>
  end

  rule t_colon
    ":" <T>
  end

  rule t_comma
    "," <T>
  end

  rule t_common
    "common" <T>
  end

  rule t_contains
    "contains" <T>
  end

  rule t_complex
    "complex" <T>
  end

  rule t_continue
    "continue" <T>
  end

  rule t_cycle
    "cycle" <T>
  end

  rule t_data
    "data" <T>
  end

  rule t_deallocate
    "deallocate" <T>
  end

  rule t_default
    "default" <T>
  end

  rule t_delim
    "delim" <T>
  end

  rule t_digit
    [0-9] <T>
  end

  rule t_dimension
    "dimension" <T>
  end

  rule t_direct
    "direct" <T>
  end

  rule t_do
    "do" <T>
  end

  rule t_dot
    "." <T>
  end

  rule t_doubleprecision
    "doubleprecision" <T>
  end

  rule t_elemental
    "elemental" <T>
  end

  rule t_else
    "else" !( "if" / "where" ) <T>
  end

  rule t_elseif
    "elseif" <T>
  end

  rule t_elsewhere
    "elsewhere" <T>
  end

  rule t_end
    "end" !t_end_disallowed <T>
  end

  rule t_end_disallowed
    # Note: Used as a negative lookahead assertion, prevents t_end from matching
    # "endfile", "enddo", etc. Also prevents t_end from matching an assignment
    # statement like "endxyz=1".

    "file" /
    "do" /
    "if" /
    "where" /
    alphanumeric_character* t_equal
  end

  rule t_enddo
    "enddo" <T>
  end

  rule t_endfile
    "endfile" <T>
  end

  rule t_endif
    "endif" <T>
  end

  rule t_endwhere
    "endwhere" <T>
  end

  rule t_entry
    "entry" <T>
  end

  rule t_eor
    "eor" <T>
  end

  rule t_equal
    "=" <T>
  end

  rule t_equivalence
    "equivalence" <T>
  end

  rule t_err
    "err" <T>
  end

  rule t_exist
    "exist" <T>
  end

  rule t_exit
    "exit" <T>
  end

  rule t_external
    "external" <T>
  end

  rule t_false
    ".false." <T>
  end

  rule t_file
    "file" <T>
  end

  rule t_fmt
    "fmt" <T>
  end

  rule t_form
    "form" !"at" <T>
  end

  rule t_format
    "format" !"ted" <T>
  end

  rule t_formatted
    "formatted" <T>
  end

  rule t_function
    "function" <T>
  end

  rule t_goto
    "goto" <T>
  end

  rule t_gt
    ">" <T>
  end

  rule t_if
    "if" <T>
  end

  rule t_implicit
    "implicit" <T>
  end

  rule t_in
    "in" !( "out" / "quire" / "teger" / "tent" / "trinsic" ) <T>
  end

  rule t_inout
    "inout" <T>
  end

  rule t_inquire
    "inquire" <T>
  end

  rule t_integer
    "integer" <T>
  end

  rule t_intent
    "intent" <T>
  end

  rule t_interface
    "interface" <T>
  end

  rule t_intrinsic
    "intrinsic" <T>
  end

  rule t_io_control_spec_end
    "end" &t_equal <T>
  end

  rule t_iolength
    "iolength" <T>
  end

  rule t_iostat
    "iostat" <T>
  end

  rule t_kind
    "kind" <T>
  end

  rule t_len
    "len" <T>
  end

  rule t_letter
    [a-zA-Z] <T>
  end

  rule t_logical
    "logical" <T>
  end

  rule t_lt
    "<" <T>
  end

  rule t_minus
    "-" <T>
  end

  rule t_module
    "module" <T>
  end

  rule t_name
    "name" !( "d" / "list" ) <T>
  end

  rule t_named
    "named" <T>
  end

  rule t_namelist
    "namelist" <T>
  end

  rule t_newline
    "\n" <T>
  end

  rule t_nextrec
    "nextrec" <T>
  end

  rule t_nml
    "nml" <T>
  end

  rule t_none
    "none" <T>
  end

  rule t_null
    "null" <T>
  end

  rule t_nullify
    "nullify" <T>
  end

  rule t_number
    "number" <T>
  end

  rule t_octal
    [01234567] <T>
  end

  rule t_only
    "only" <T>
  end

  rule t_open
    "open" !"ed" <T>
  end

  rule t_opened
    "opened" <T>
  end

  rule t_operator
    "operator" <T>
  end

  rule t_optional
    "optional" <T>
  end

  rule t_out
    "out" <T>
  end

  rule t_pad
    "pad" <T>
  end

  rule t_parameter
    "parameter" <T>
  end

  rule t_paren_l
    "(" <T>
  end

  rule t_paren_r
    ")" <T>
  end

  rule t_pause
    "pause" <T>
  end

  rule t_percent
    "%" <T>
  end

  rule t_plus
    "+" <T>
  end

  rule t_point
    "=>" <T>
  end

  rule t_pointer
    "pointer" <T>
  end

  rule t_position
    "position" <T>
  end

  rule t_print
    "print" <T>
  end

  rule t_private
    "private" <Access_Spec>
  end

  rule t_procedure
    "procedure" <T>
  end

  rule t_program
    "program" <T>
  end

  rule t_public
    "public" <Access_Spec>
  end

  rule t_pure
    "pure" <T>
  end

  rule t_quotemark
    "\"" <T>
  end

  rule t_read
    "read" !"write" <T>
  end

  rule t_readwrite
    "readwrite" <T>
  end

  rule t_real
    "real" <T>
  end

  rule t_rec
    "rec" !"l" <T>
  end

  rule t_recl
    "recl" <T>
  end

  rule t_recursive
    "recursive" <T>
  end

  rule t_result
    "result" <T>
  end

  rule t_return
    "return" <T>
  end

  rule t_rewind
    "rewind" <T>
  end

  rule t_save
    "save" <T>
  end

  rule t_select
    "select" <T>
  end

  rule t_sequence
    "sequence" <T>
  end

  rule t_sequential
    "sequential" <T>
  end

  rule t_size
    "size" <T>
  end

  rule t_slash
    "/" <T>
  end

  rule t_star
    "*" <T>
  end

  rule t_stat
    "stat" !"us" <T>
  end

  rule t_status
    "status" <T>
  end

  rule t_stop
    "stop" <T>
  end

  rule t_subroutine
    "subroutine" <T>
  end

  rule t_target
    "target" <T>
  end

  rule t_then
    "then" <T>
  end

  rule t_to
    "to" <T>
  end

  rule t_true
    ".true." <T>
  end

  rule t_type
    "type" <T>
  end

  rule t_underscore
    # F90:R303
    "_"
  end

  rule t_unformatted
    "unformatted" <T>
  end

  rule t_unit
    "unit" <T>
  end

  rule t_use
    "use" <T>
  end

  rule t_where
    "where" <T>
  end

  rule t_while
    "while" <T>
  end

  rule t_write
    "write" <T>
  end

  rule target
    # F90:R737

    variable /
    expr
  end

  rule target_object
    array_name_and_spec /
    variable_name
  end

  rule target_object_list
    target_object target_object_list_pair* <Target_Object_List>
  end

  rule target_object_list_pair
    t_comma target_object <Target_Object_List_Pair>
  end

  rule target_stmt
    # F90:R528

    label:label? t_target double_colon? target_object_list t_newline &{ |e| sp_target_stmt(e[3]) } <Target_Stmt>
  end

  rule type_declaration_stmt
    # F90:R501

    label:label? type_spec attr_spec_option? entity_decl_list t_newline &{ |e| sp_type_declaration_stmt(e[1],e[2],e[3]) } <Type_Declaration_Stmt>
  end

  rule type_name
    # Multiple uses (not explicitly defined)

    name "" <Type_Name>
  end

  rule type_param_value
    # F90:R509

    specification_expr /
    t_star
  end

  rule type_spec
    # F90:R502

    type_spec_with_kind_selector /
    type_spec_without_kind_selector
  end

  rule type_spec_with_kind_selector
    t_integer kind_selector <Type_Spec> /
    t_real kind_selector <Type_Spec> /
    t_complex kind_selector <Type_Spec> /
    t_logical kind_selector <Type_Spec>
  end

  rule type_spec_without_kind_selector
    t_integer star_int <Type_Spec> / # NONSTANDARD!
    t_integer "" <Type_Spec> /
    t_real star_int <Type_Spec> / # NONSTANDARD!
    t_real "" <Type_Spec> /
    t_doubleprecision "" <Type_Spec> /
    t_complex "" <Type_Spec> /
    t_character char_selector? <Type_Spec> /
    t_logical star_int <Type_Spec> / # NONSTANDARD!
    t_logical "" <Type_Spec> /
    t_type t_paren_l type_name t_paren_r <Type_Spec>
  end

  rule upper_bound
    # F90:R515

    specification_expr "" <Upper_Bound>
  end

  rule use_name
    # Multiple uses (not explicitly defined)

    name "" <Use_Name>
  end

  rule use_part
    ( use_stmt / directive )* <Use_Part>
  end

  rule use_stmt
    # F90:R1107

    label:label? t_use module_name rename_list_option? t_newline &{ |e| sp_use_stmt(e[2],e[3]) } <Use_Stmt_1> /
    label:label? t_use module_name t_comma t_only t_colon only_list? t_newline &{ |e| sp_use_stmt(e[2],e[6]) } <Use_Stmt_2>
  end

  rule variable
    # F90:R601

    subobject /
    array_variable_name /
    scalar_variable_name
  end

  rule variable_name
    # Multiple uses (not explicitly defined)

    name "" <Variable_Name>
  end

  rule vector_subscript
    # F90:R621

    int_expr
  end

  rule where_assignment_stmt_block
    assignment_stmt* <E>
  end

  rule where_construct
    # F90:R739

    where_construct_stmt where_assignment_stmt_block elsewhere_construct? end_where_stmt <E>
  end

  rule where_construct_stmt
    # F90:R740

    label:label? t_where t_paren_l mask_expr t_paren_r t_newline <Where_Construct_Stmt>
  end

  rule where_stmt
    # F90:R738

    label:label? t_where t_paren_l mask_expr t_paren_r !label assignment_stmt <Where_Stmt>
  end

  rule write_stmt
    # F90:R910

    label:label? t_write t_paren_l io_control_spec_list t_paren_r output_item_list? t_newline <Write_Stmt>
  end

end
