#!/usr/bin/env ruby

basedir=File.dirname(File.expand_path($0))

ENV['GEM_PATH']=File.join(basedir,'gems')

$: << basedir

require 'rubygems'
require 'treetop'
require 'fortran_nodes.rb'
require 'fortran_parser.rb'
require 'normalize_nodes.rb'
require 'normalize_parser.rb'

include Fortran

class PPP

  def initialize(basedir,args)
    @basedir=basedir
    @debug=false
    srcfile=args.pop
    fail(usage) unless srcfile
    srcfile=File.expand_path(srcfile)
    fail("Cannot read file: #{srcfile}") unless File.readable?(srcfile)
    incdirs=['.']
    args.reverse!
    while opt=args.pop
      case opt
      when '-I'
        dirlist=args.pop
        fail(usage) unless dirlist
        dirlist.split(':').each do |d|
          fail("No such directory: #{d}") unless File.directory?(d)
          incdirs << d
        end
      when 'normalize'
        @normalize=true
      when 'debug'
        @debug=true
      else
        fail(usage)
      end
    end
    s=File.open(srcfile,'rb').read
    s=assemble(s,incdirs,[srcfile])
    cppcheck(s)
    puts "normalized:\n\n" if @debug
    s=normalize(s)
    unless @normalize
      puts s if @debug
      puts "\nparsed:\n\n" if @debug
      s=parse(s)
    end
    fail "Parse failed." if s.empty?
    puts s
  end

  def clean(s)
    s.gsub!(/^\s*!.*/,'')         # zero out comment lines
    s.gsub!(/\s+$/,'')            # remove trailing whitespace
    s.gsub!(/^\s+/,'')            # left-justify lines
    s.gsub!(/&$\n&?/,'')          # join continuation lines
    s.gsub!(/\n\n/,"\n")          # remove blank lines
    s << "\n"  unless s[-1]=="\n" # ensure final newline
    s
  end

  def cppcheck(s)
    r=Regexp.new('^\s*#')
    i=1
    s.split("\n").each do |line|
      m=r.match(line)
      fail "Detected cpp directive:\n\n#{i}: #{line.strip}" if m
      i+=1
    end
  end

  def directive
    unless @directive
      f=File.join(@basedir,'sentinels')
      d=File.open(f,'rb').read.gsub(/\$/,'\$').split("\n").<<('sms\$').join('|')
      @directive=Regexp.new("^\s*!((#{d}).*)",true)
    end
    @directive
  end
    
  def fail(msg)
    $stderr.puts "\n#{msg}\n\n"
    exit 1
  end

  def assemble(s,incdirs,seen)
    current=seen.last
    a=''
    r=Regexp.new('^\s*include\s*(\'[^\']+\'|\"[^\"]+\").*',true)
    s.split("\n").each do |line|
      m=r.match(line)
      if m
        incfile=m[1][1..-2]
        if incfile[0]=='/' or incfile[0]=='.'
          incfile=File.expand_path(File.join(File.dirname(current),incfile))
          unless File.exist?(incfile)
            fail "Could not find included file #{incfile}"
          end
        else
          found=false
          incdirs.each do |d|
            maybe=File.expand_path(File.join(d,incfile))
            if File.exist?(maybe)
              found=true
              incfile=maybe
              break
            end
          end
          unless found
            fail "Could not find included file #{incfile} on search path"
          end
        end
        if seen.include?(incfile)
          msg="File #{current} includes #{incfile} recursively:\n"
          msg+=incchain(seen,incfile)
          fail(msg)
        end
        unless File.readable?(incfile)
          msg="Could not read file #{incfile} "
          msg+=incchain(seen,incfile)
          fail(msg)
        end
        a+=assemble(File.open(incfile,'rb').read,incdirs,seen+[incfile])
      else
        a+="#{line}\n"
      end
    end
    a
  end

  def incchain(seen,incfile)
    "\n  "+(seen+[incfile]).join(" includes\n  ")
  end

  def normalize(s)
    s=s.gsub(/!sms\$insert */i,'')                           # process inserts
    s=s.gsub(/!sms\$remove +begin.*?!sms\$remove +end/im,'') # process removes
    np=NormalizeParser.new
    s.gsub!(directive,'@\1') # hide directives
    s=np.parse(s).to_s       # pass 1: normalize
    s=clean(s)               # pass 1: clean
    tree=np.parse(s)         # pass 2: normalize
    s=clean(tree.to_s)       # pass 2: clean
    s.gsub!(/^@(.*)/i,'!\1') # show directives
    if tree.nil?
      fail "#{p.failure_reason}: #{p.failure_line}:#{p.failure_column}"
    end
    s
  end

  def parse(s)
    tree=FortranParser.new.parse(s)
#   strip(tree)
    p tree if @debug
    tree.to_s
  end

  def prunable(tree)
    strict=false
    return false unless tree.class==Treetop::Runtime::SyntaxNode
    if strict
      return true
    else
      return true if tree.elements.nil?
      tree.elements.reduce(true) { |p,e| p and prunable(e) }
    end
  end

  def strip(tree)
    return if tree.nil? or tree.elements.nil?
    tree.elements.delete_if { |e| prunable(e) }
    tree.elements.each { |e| strip(e) }
  end
  
  def usage
    f=File.basename(__FILE__)
    "usage: #{f} [-I dir[:dir:...]] source"
  end

end

PPP.new(basedir,ARGV) if (__FILE__==$0)

# paul.a.madden@noaa.gov
