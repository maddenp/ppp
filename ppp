#!/usr/bin/env ruby

basedir=File.dirname(File.expand_path($0))
$: << basedir
$: << File.join(basedir,'lib')

require 'treetop'
require 'fortran_nodes.rb'
require 'fortran_parser.rb'
require 'normalize_nodes.rb'
require 'normalize_parser.rb'

include Fortran

class PPP

  def initialize(props={})
    @debug=false
    @fp=FortranParser.new
    @incdirs=[]
    @normalize=false
    @root=:program_units
    @srcfile=nil
    props.each { |k,v| instance_variable_set("@#{k}".to_sym,v) }
  end

  def out(s,root=:program_units)
    s=s.gsub(/^\s*!sms\$insert */i,'')                           # process inserts
    s=s.gsub(/^\s*!sms\$remove +begin.*?!sms\$remove +end/im,'') # process removes
    s=assemble(s,[@srcfile],@incdirs)
    cppcheck(s)
    puts "normalized:\n\n" if @debug
    s=normalize(s)
    unless @normalize
      puts s if @debug
      puts "\nparsed:\n\n" if @debug
      @tree=@fp.parse(s,:root=>root)
      p @tree if @debug
      s=@tree.to_s
      fail "Parse failed." if s.empty?
      s=wrap(s)
    end
    s
  end

  def tree(s,root=:program_units)
    out(s,root)
    @tree
  end
  
end

def unpack(props,args)
  props[:incdirs]=['.']
  args.reverse!
  while opt=args.pop
    case opt
    when '-I'
      dirlist=args.pop
      fail(usage) unless dirlist
      dirlist.split(':').each do |d|
        fail("No such directory: #{d}") unless File.directory?(d)
        props[:incdirs] << d
      end
    when 'normalize'
      props[:normalize]=true
    when 'debug'
      props[:debug]=true
    else
      fail(usage)
    end
  end
  props
end

def usage
  f=File.basename(__FILE__)
  "usage: #{f} [-I dir[:dir:...]] source"
end

if (__FILE__==$0)
  fail(usage) unless srcfile=ARGV.pop
  srcfile=File.expand_path(srcfile)
  fail("Cannot read file: #{srcfile}") unless File.readable?(srcfile)
  s=File.open(srcfile,'rb').read
  props={:srcfile=>srcfile}
  props=unpack(props,ARGV)
  ppp=PPP.new(props)
  puts ppp.out(s)
end

# paul.a.madden@noaa.gov
