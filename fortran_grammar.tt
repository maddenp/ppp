# NOTES: Grammar rule numbers or section numbers from the Fortran 90 standard
# document are given when possible. Grammar rule names used here match those
# from the standard document, with underscores in place of hyphens. Some left-
# recursive rules given by the standard have been translated to right-recursive
# for PEG compatability; the original (implied) rules are given in comments. The
# "start" rule must go first; other rules are in alphabetical order. Constraints
# described in the standard document are given in comments. Rule names for
# literal terminals not defined in the standard are prefixed with "t_".

grammar Fortran

  rule start
    program_unit
  end

  rule action_stmt
    # R216 -- INCOMPLETE
    #
    # Note: Provide label handling in rules for individual statements.

    # allocate_stmt /
    assignment_stmt /
    # backspace_stmt /
    # call_stmt /
    # close_stmt /
    computed_goto_stmt /
    continue_stmt /
    cycle_stmt /
    # deallocate_stmt /
    # endfile_stmt /
    # end_function_stmt /
    end_program_stmt /
    # end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    if_stmt /
    # inquire_stmt /
    # nullify_stmt /
    # open_stmt /
    # pointer_assignement_stmt /
    print_stmt /
    # read_stmt /
    # return_stmt /
    # rewind_stmt /
    stop_stmt /
    # where_stmt /
    # write_stmt /
    arithmetic_if_stmt /
    assign_stmt /
    assigned_goto_stmt /
    pause_stmt
  end

  rule action_term_do_construct
    # R827

    label_do_stmt !{ |e| dolabel_dupe? } do_body do_term_action_stmt <Cat>
  end

  rule add_op
    # R710

    t_plus /
    t_minus
  end

  rule add_operand
    # R706
    #
    # Note: Left-recursive rule implied by standard:
    # ( add_operand mult_op)? mult_operand

    mult_operand ( mult_op add_operand )? <Verbatim>
  end

  rule and_op
    # R720

    ".and." <Verbatim>
  end

  rule alphanumeric_character
    # R302

    t_letter /
    t_digit /
    t_underscore
  end

  rule arithmetic_if_stmt
    # R840
    #
    # Constraint: Each label must be the label of a branch target statement that
    # appears in the same scoping unit as the arithmetic_if_stmt. The
    # scalar_numeric_expr must not be of type complex.

    label:label? t_if t_paren_l scalar_numeric_expr t_paren_r label t_comma
      label t_comma label t_newline <Arithmetic_If_Stmt>
  end

  rule assign_stmt
    # R838
    #
    # Constraint: The label must be the statement label of a branch target
    # statement of format_stmt that appears in the same scoping unit as the
    # assign_stmt. scalar_int_variable must be named and of type default
    # integer.

    label:label? t_assign label t_to scalar_int_variable t_newline <Stmt>
  end

  rule assigned_goto_stmt
    # R839
    #
    # Constraint: Each label in label_list must be the statement label of a
    # branch target statement that appears in the same scoping unit as the
    # assigned_goto_stmt. scalar_int_variable must be named and of type
    # default integer.

    label:label? t_goto scalar_int_variable assigned_goto_stmt_label_list?
      t_newline <Assigned_Goto_Stmt>
  end

  rule assigned_goto_stmt_label_list
    t_comma? t_paren_l label_list t_paren_r <Verbatim>
  end

  rule assignment_stmt
    # R735
    #
    # Constraint: A variable in an assignment_stmt must not be an assumed-size
    # array.

    label:label? variable t_equal expr t_newline <Assignment_Stmt>
  end

  rule binary_constant
    # R408
    #
    # Constraint: digit must have one of the values 0 or 1. Note: 'digit is
    # replaced by 't_binary' here to enforce the constraint.

    "b" ( ( t_apostrophe t_binary+ t_apostrophe ) /
      ( t_quotemark t_binary+ t_quotemark ) ) <Verbatim>
  end

  rule block
    # R801

    execution_part_construct
  end

  rule block_do_construct
    # R817

    do_stmt do_block end_do <Cat>
  end

  rule boz_literal_constant
    # R407
    #
    # Constraint: A boz-literal-constant may appear only in a DATA statement.

    binary_constant /
    octal_constant /
    hex_constant
  end

  rule char_expr
    # R726
    #
    # Constraint: char_expr must be type character.

    expr
  end

  rule char_literal_constant
    # R420
    #
    # Constraint: The value of kind_param must specify a representation method
    # that exists on the processor.

    ( kind_param t_underscore )? t_apostrophe (!t_apostrophe rep_char)*
      t_apostrophe <Verbatim> /
    ( kind_param t_underscore )? t_quotemark (!t_quotemark rep_char)*
      t_quotemark <Verbatim>
  end

  rule character
    # R301

    alphanumeric_character /
    special_character
  end

  rule complex_literal_constant
    # R417

    t_paren_l real_part t_comma imag_part t_paren_r <Verbatim>
  end

  rule computed_goto_stmt
    # R837
    #
    # Constraint: Each label in label_list must be the statement label of a
    # branch target statement that appears in the same scoping unit as the
    # computed_goto_stmt.

    label:label? t_goto t_paren_l label_list t_paren_r t_comma? scalar_int_expr
      t_newline <Computed_Goto_Stmt>
  end

  rule concat_op
    # R712

    "//" <Verbatim>
  end

  rule constant
    # R305

    literal_constant /
    named_constant
  end

  rule continue_stmt
    # R841

    label:label? t_continue t_newline <Stmt>
  end

  rule cycle_stmt
    # R834
    #
    # Constraint: If a cycle_stmt refers to a do_construct_name, it must be
    # within the range of that do_construct; otherwise, it must be within the
    # range of at least one do_construct.

    label:label? t_cycle do_construct_name? t_newline <Stmt>
  end

  rule data_i_do_object
    # R536 -- INCOMPLETE
    #
    # Constraint: The array_element must not have a constant parent. The
    # scalar_structure_component must not have a constant parent. In an
    # array_element or a scalar_structure_component that is a data_i_do_object,
    # any subscript must be an expression whose primaries are either constant or
    # DO variables of the containing data_implied_dos, and each operation must
    # be intrinsic.

    # array_element /
    # scalar_structure_component /
    data_implied_do
  end

  rule data_i_do_object_list
    data_i_do_object ( t_comma data_i_do_object )* <Verbatim>
  end

  rule data_i_do_variable
    # R537
    #
    # Constraint: The data_i_do_variable must be a named variable.

    scalar_int_variable
  end

  rule data_implied_do
    # R535
    #
    # Constraint: A scalar_int_expr of a data_implied_do must involve as
    # primaries only constants or DO variables of the containing
    # data_implied_dos, and each operation must be intrinsic.

    t_paren_l data_i_do_object_list t_comma data_i_do_variable t_equal
      scalar_int_expr t_comma scalar_int_expr ( t_comma scalar_int_expr )*
      t_paren_r <Verbatim>
  end

  rule data_stmt
    # R529

    label:label? t_data data_stmt_set_list t_newline <Stmt>
  end

  rule data_stmt_constant
    # R533 -- INCOMPLETE
    #
    # Constraint: If a data_stmt_constant is a structure_constructor, each
    # component must be an initialization expression. Note: Choice order changed
    # vs that presented in standard.

    signed_real_literal_constant /
    signed_int_literal_constant /
    boz_literal_constant /
    # structure_constructor /
    scalar_constant
  end

  rule data_stmt_object
    # R531
    #
    # Constraint: In a variable that is a data_stmt_object, any subscript,
    # section subscript, substring starting point, and substring ending point
    # must be an initialization expression. A variable whose name or
    # designator is included in a data_stmt_object_list or a
    # data_i_do_object_list must not be: a dummy argument, made accessible by
    # use assocation or host association, in a named common block unless the
    # DATA statement is in a block data program unit, in a blank common block,
    # a function name, a function result name, an automatic object, a pointer,
    # or an allocatable array.

    variable /
    data_implied_do
  end

  rule data_stmt_object_list
    data_stmt_object ( t_comma data_stmt_object )* <Verbatim>
  end

  rule data_stmt_repeat
    # R534
    #
    # Constraint: The DATA statement repeat factor must be positive or zero. If
    # the DATA statement repeat factor is a named constant, it must have been
    # declared previously in the scoping unit or made accessible by use
    # association or host association.

    scalar_int_constant
  end

  rule data_stmt_set
    # R530

    data_stmt_object_list t_slash data_stmt_value_list t_slash <Verbatim>
  end

  rule data_stmt_set_list
    data_stmt_set ( t_comma data_stmt_set )* <Verbatim>
  end

  rule data_stmt_value
    # R531

    data_stmt_repeat_pair? data_stmt_constant <Verbatim>
  end

  rule data_stmt_repeat_pair
    data_stmt_repeat t_star <Verbatim>
  end

  rule data_stmt_value_list
    data_stmt_value ( t_comma data_stmt_value )* <Verbatim>
  end

  rule declaration_construct
    # R207 -- INCOMPLETE

    specification_stmt /
    format_stmt
  end

  rule default_char_expr
    # R727
    #
    # Constraint: default_char_expr must be of type default character.

    expr
  end

  rule defined_binary_op
    # R724
    #
    # Constraint: Must not contain more than 31 letters and must not be the same
    # as any intrinsic_operator or logical_literal_constant.

    t_dot t_letter t_letter+ t_dot <Verbatim>
  end

  rule defined_unary_op
    # R704
    #
    # Constraint: Must not contain more than 31 letters and must not be the same
    # as any intrinsic_operator or logical_literal_constant.

    !( intrinsic_operator / logical_literal_constant ) t_dot t_letter t_letter+
      t_dot <Verbatim>
  end

  rule digit_string
    # R402

    t_digit+ <Verbatim>
  end

  rule do_block
    # R823

    block
  end

  rule do_body
    # R828

    execution_part_construct
  end

  rule do_construct
    # R816

    nonblock_do_construct /
    block_do_construct
  end

  rule do_construct_name
    # 8.1.4.1.1 (not explicitly defiend)
    #
    # Note: Unclear what is needed here, making assumption...

    name
  end

  rule do_construct_name_label
    do_construct_name t_colon <Verbatim>
  end

  rule do_stmt
    # R818

    label_do_stmt /
    nonlabel_do_stmt
  end

  rule do_term_action_stmt
    # R829
    #
    # Constraint: A do_term_action_stmt must not be a continue_stmt, a
    # goto_stmt, a return_stmt, a stop_stmt, an exit_stmt, a cycle_stmt, an
    # end_function_stmt, an end_subroutine_stmt, an end_program_stmt, an
    # arithmetic_if_stmt, or an assigned_goto_stmt. The do_term_action_stmt
    # must be identified with a label and the corresponding label_do_stmt
    # must refer to the same label.

    !do_term_action_stmt_disallowed action_stmt &{ |e| nonblock_do_end!(e[1]) }
      <Do_Term_Action_Stmt>
  end

  rule do_term_action_stmt_disallowed
    arithmetic_if_stmt /
    assigned_goto_stmt /
    continue_stmt /
    cycle_stmt /
    # end_function_stmt /
    end_program_stmt /
    # end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    # return_stmt /
    stop_stmt
  end

  rule do_term_shared_stmt
    # R833
    #
    # Constraint: A do_term_shared_stmt must not be a goto_stmt, a return_stmt,
    # a stop_stmt, an exit_stmt, a cycle_stmt, an end_fuction_stmt, an
    # end_subroutine_stmt, and end_program_stmt, an arithmetic_if_stmt, or an
    # assigned_goto_stmt.

    !do_term_shared_stmt_disallowed action_stmt &{ |e| nonblock_do_end!(e[1]) }
      <Do_Term_Shared_Stmt>
  end

  rule do_term_shared_stmt_disallowed
    arithmetic_if_stmt /
    assigned_goto_stmt /
    cycle_stmt /
    # end_function_stmt /
    end_program_stmt /
    # end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    # return_stmt /
    stop_stmt
  end

  rule do_variable
    # R822
    #
    # Constraint: The do_variable must be a name scalar variable of type
    # integer, default real, or double precision real.

    scalar_variable
  end

  rule else_construct
    else_stmt block <Cat>
  end

  rule else_if_construct
    else_if_construct_element+ <Cat>
  end

  rule else_if_construct_element
    else_if_stmt block <Cat>
  end

  rule else_if_stmt
    # R804

    label:label? t_elseif t_paren_l scalar_logical_expr t_paren_r t_then
      t_newline <Else_If_Stmt>
  end

  rule else_stmt
    # R805

    label:label? t_else if_construct_name? t_newline <Else_Stmt>
  end

  rule end_do
    # R824
    # Constraint: If the do_stmt of a block_do_construct is identified by a
    # do_construct_name, the corresponding end_do must be an end_do_stmt
    # specifying the same do_construct_name. If the do_stmt of a
    # block_do_construct is not identified by a do_construct_name, the
    # corresponding end_do must not specify a do_construct_name. If the do_stmt
    # is a nonlabel_do_stmt, the corresponding end_do must be an end_do_stmt.
    # If the do_stmt is a label_do_stmt, the corresponding end_do must be
    # identified with the same label.

    end_do_stmt /
    end_do_continue_stmt
  end

  rule end_do_continue_stmt
    label:label? t_continue t_newline &{ |e| dolabel_pop(e[0]) } <End_Do_Stmt>
  end

  rule end_do_stmt
    # R825

    label:label? t_enddo do_construct_name? t_newline &{ |e| dolabel_pop(e[0]) }
      <End_Do_Stmt>
  end

  rule end_if_stmt
    # R806

    label:label? t_endif if_construct_name? t_newline <End_If_Stmt>
  end

  rule end_program_stmt
    # R1103
    #
    # Constraint: The program_name may be included in the end_program_stmt only
    # if the optional program_stmt is used and, if included, must be identical
    # to the program_name specified in the program_stmt.

    label:label? t_end t_program? name:program_name? t_newline?
      <End_Program_Stmt>
  end

  rule equiv_op
    # R722

    ".eqv." <Verbatim> /
    ".neqv." <Verbatim>
  end

  rule equiv_operand
    # R715

    not_op? level_4_expr <Verbatim>
  end

  rule executable_construct
    # R215 -- INCOMPLETE

    executable_construct_action_stmt /
    # case_construct /
    do_construct /
    if_construct # /
    # where_construct
  end

  rule executable_construct_action_stmt
    !execution_part_disallowed action_stmt !{ |e| nonblock_do_end?(e[1]) }
      <Stmt>
  end

  rule execution_part
    # R208
    #
    # Constraint: An execution_part must not contain an end_function_stmt,
    # end_program_stmt, or end_subroutine_stmt.

    executable_construct execution_part_construct <Cat>
  end

  rule execution_part_disallowed
    # end_function_stmt /
    end_program_stmt # /
    # end_subroutine_stmt
  end

  rule execution_part_construct
    # R209 -- INCOMPLETE

    (
      executable_construct /
      format_stmt /
      data_stmt # /
      # entry_stmt
    )* <Cat>
  end

  rule exit_stmt
    # R835
    #
    # Constraint: If an exit_stmt refers to a do_construct_name, it must be
    # within the range of that do_construct; otherwise, it must be within the
    # range of at least one do_construct.

    label:label? t_exit do_construct_name? t_newline <Stmt>
  end

  rule exponent
    # R416

    signed_digit_string
  end

  rule exponent_letter
    # R415

    [ed] <Verbatim>
  end

  rule expr
    # R723
    #
    # Note: Left-recursive rule implied by standard:
    # ( expr defined_binary_op )? level_5_expr

    level_5_expr ( defined_binary_op expr )? <Verbatim>
  end

  rule format
    # R913
    #
    # Constraint: The label must be the label of a FORMAT statement that appears
    # in the same scoping unit as the statement containing the format specifier.
    # The scalar_default_int_variable must have been assigned (8.2.4) the
    # statement label of a FORMAT statement that appears in the same scoping
    # unit as the format.

    default_char_expr /
    label /
    t_star /
    scalar_default_int_variable
  end

  rule format_specification
    # R1002
    #
    # Note: A vast simplification is made here under the assumption that it is
    # only necessary to pass a format-specification through verbatim, not to
    # analyze its contents.

    t_paren_l (!t_paren_r character)+ t_paren_r <Verbatim>
  end

 rule format_stmt
    # R1001
    #
    # Constraint: The format_stmt must be labeled.

    label t_format format_specification t_newline <Stmt>
  end

  rule goto_stmt
    # R836
    #
    # Constraint: The label must be the statement label of a branch target
    # statement that appears in the same scoping unit as the goto_stmt.

    label:label? t_goto label t_newline <Stmt>
  end

  rule hex_constant
    # R410

    "z" ( ( t_apostrophe hex_digit+ t_apostrophe ) / ( t_quotemark hex_digit+
      t_quotemark ) ) <Verbatim>
  end

  rule hex_digit
    # R411

    [0123456789abcdef]
  end

  rule if_construct
    # R802
    #
    # Note: if_then_construct, else_if_construct and else_construct added for
    # clarity, not specified in standard.

    label:label? if_then_construct else_if_construct? else_construct?
      end_if_stmt <Cat>
  end

  rule if_construct_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule if_construct_name_label
    if_construct_name t_colon <Verbatim>
  end

  rule if_stmt
    # R807
    #
    # Constraint: The action_stmt in the if_stmt must not be an if_stmt,
    # end_program_stmt, end_function_stmt, or end_subroutine_stmt.

    label:label? t_if t_paren_l scalar_logical_expr t_paren_r action_stmt
      <If_Stmt>
  end

  rule if_then_construct
    if_then_stmt block <Cat>
  end

  rule if_then_stmt
    # R803

    label:label? if_construct_name_label? t_if t_paren_l scalar_logical_expr
      t_paren_r t_then t_newline <If_Then_Stmt>
  end

  rule imag_part
    # R419

    signed_real_literal_constant /
    signed_int_literal_constant
  end

  rule inner_shared_do_construct
    # R832

    label_do_stmt do_body do_term_shared_stmt <Inner_Shared_Do_Construct>
  end

  rule int_expr
    # R728
    #
    # Constraint: int_expr must be type integer.

    expr
  end

  rule int_literal_constant
    # R404

    digit_string ( t_underscore kind_param )? <Verbatim>
  end

  rule internal_subprogram_part
    ""
  end

  rule intrinsic_operator
    # R310

    power_op /
    mult_op /
    add_op /
    concat_op /
    rel_op /
    not_op /
    and_op /
    or_op /
    equiv_op
  end

  rule kind_param
    # R405
    #
    # Constraint: The value of kind_param must be nonnegative. The value of
    # kind_param must specify a representation method that exists on the
    # processor.

    digit_string /
    scalar_int_constant_name
  end

  rule label
    # R313
    #
    # Constraint: At least one digit in a label must be nonzero. If a statement
    # is labeled, the statement must contain a nonblank character. The same
    # statement label must not be given to more than one statement in a scoping
    # unit. Leading zeros are not significant in distinguishing between
    # statement labels.

    t_digit 1..5 <Verbatim>
  end

  rule label_do_stmt
    # R819

    label:label? do_construct_name_label? t_do dolabel:label loop_control?
      t_newline &{ |e| dolabel_push(e[3]) } <Label_Do_Stmt>
  end

  rule label_list
    label ( t_comma label )* <Verbatim>
  end

  rule level_1_expr
    # R703

    defined_unary_op? primary <Verbatim>
  end

  rule level_2_expr
    # R707
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_2_expr? add_op )? add_operand

    add_op? add_operand level_2_expr? <Verbatim>
  end

  rule level_3_expr
    # R711
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr concat_op )? level_2_expr

    level_2_expr ( concat_op level_3_expr )? <Verbatim>
  end

  rule level_4_expr
    # R713
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr rel_op )? level_3_expr

    level_3_expr ( rel_op level_3_expr )? <Verbatim>
  end

  rule level_5_expr
    # R718
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_5_expr equiv_op)? equiv_operand

    equiv_operand ( equiv_op level_5_expr )? <Verbatim>
  end

  rule literal_constant
    # R306
    #
    # Note: The choice order is different than that given in the standard, e.g.
    # an int_literal_constant should only be matched after failure to match a
    # real_literal_constant. Also, signed versions of real_literal_constant and
    # int_literal_constant are used here, though the standard (seemingly
    # incorrectly) specifies the unsigned versions.

    complex_literal_constant /
    signed_real_literal_constant /
    signed_int_literal_constant /
    logical_literal_constant /
    char_literal_constant /
    boz_literal_constant
  end

  rule logical_expr
    # R725
    #
    # Constraint: logical_expr must be type logical.

    expr
  end

  rule logical_literal_constant
    # R421
    #
    # Constraint: The value of kind_param must specify a representation that
    # exists on the processor.

    ( t_true / t_false ) ( t_underscore kind_param )? <Verbatim>
  end

  rule loop_control
    # R821
    #
    # Constraint: Each scalar_numeric_expr in loop_control must be of type
    # integer, default real, or double precision real.

    t_comma? do_variable t_equal scalar_numeric_expr loop_control_pair
      loop_control_pair? <Loop_Control_1> /
    t_comma? t_while t_paren_l scalar_logical_expr t_paren_r <Loop_Control_2>
  end

  rule loop_control_pair
    t_comma scalar_numeric_expr <Verbatim>
  end

  rule main_program
    # R1101 -- INCOMPLETE
    #
    # Constraint: In a main_program, the execution_part must not contain a
    # RETURN statement or an ENTRY statement.

    program_stmt? specification_part? execution_part? end_program_stmt <Cat>
  end

  rule mult_op
    # R709

    t_star /
    t_slash
  end

  rule mult_operand
    # R705

    level_1_expr ( power_op mult_operand )? <Verbatim>
  end

  rule name
    # R304
    #
    # Constraint: The maximum length of a name is 31 characters.

    t_letter alphanumeric_character* <Verbatim>
  end

  rule named_constant
    # R307

    name
  end

  rule nonblock_do_construct
    # R826

    outer_shared_do_construct /
    action_term_do_construct
  end

  rule nonlabel_do_stmt
    # R820

    label:label? do_construct_name_label? t_do loop_control? t_newline
      &{ |e| dolabel_push(:nolabel) } <Nonlabel_Do_Stmt>
  end

  rule not_op
    # R719

    ".not." <Verbatim>
  end

  rule numeric_expr
    # R729
    #
    # Constraint: numeric_expr must be of type integer, real or complex.

    expr
  end

  rule octal_constant
    # R409
    #
    # Constraint: digit must have one of the values 0 through 7. Note: 'digit is
    # replaced by 't_octal' here to enforce the constraint.

    "o" ( ( t_apostrophe t_octal+ t_apostrophe ) /
      ( t_quotemark t_octal+ t_quotemark ) ) <Verbatim>
  end

  rule or_op
    # R721

    ".or." <Verbatim>
  end

  rule outer_shared_do_construct
    # R830

    label_do_stmt !{ |e| dolabel_dupe? } do_body shared_term_do_construct <Cat>
  end

  rule output_item
    # R915 -- INCOMPLETE

    expr
  end

  rule output_item_list
    # 9.4.2
    #
    # Constraint: In an output_item_list, an io_implied_do_object must be an
    # output_item.

    ( t_comma output_item )+ <Verbatim>
  end

  rule parenthesized_expr
    t_paren_l expr t_paren_r <Verbatim>
  end

  rule pause_stmt
    # R844

    label:label? t_pause stop_code? t_newline <Stmt>
  end

  rule power_op
    # R708

    "**" <Verbatim>
  end

  rule primary
    # R701 -- INCOMPLETE
    #
    # Constraint: subobject must be a subobject whose parent is a constant. A
    # variable that is a primary must not be an assumed-size array.

    constant /
    # constant_subobject /
    variable /
    # array_constructor /
    # structure_constructor /
    # function_reference /
    parenthesized_expr
  end

  rule print_stmt
    # R911

    label:label? t_print format output_item_list? t_newline <Print_Stmt>
  end

  rule program_name
    # 11.1

    name
  end

  rule program_stmt
    # R1102

    label:label? t_program name:program_name t_newline <Program_Stmt>
  end

  rule program_unit
    # R202 -- INCOMPLETE

    main_program # /
    # external_subprogram /
    # module /
    # block_data
  end

  rule real_literal_constant
    # R413
    #
    # Constraint: If both kind_param and exponent_letter are present,
    # exponent_letter bust be E. The value of kind_param must specify an
    # approximation method that exists on the processor.

    significand ( exponent_letter exponent )? ( t_underscore kind_param )?
      <Verbatim> /
    digit_string exponent_letter exponent ( t_underscore kind_param )?
      <Verbatim>
  end

  rule real_part
    # R418

    signed_real_literal_constant /
    signed_int_literal_constant
  end

  rule rel_op_eq
    ".eq." <Verbatim> /
    "==" <Verbatim>
  end

  rule rel_op_ge
    ".ge." <Verbatim> /
    ">=" <Verbatim>
  end

  rule rel_op_gt
    ".gt." <Verbatim> /
    ">" <Verbatim>
  end

  rule rel_op_le
    ".le." <Verbatim> /
    "<=" <Verbatim>
  end

  rule rel_op_lt
    ".lt." <Verbatim> /
    "<" <Verbatim>
  end

  rule rel_op_ne
    ".ne." <Verbatim> /
    "/=" <Verbatim>
  end

  rule rel_op
    # R714

    rel_op_eq /
    rel_op_ne /
    rel_op_lt /
    rel_op_le /
    rel_op_gt /
    rel_op_ge
  end

  rule rep_char
    # 4.3.2.1 (processor-dependent)
    #
    # Constraint: For the type character with kind kind_param, and for type
    # default character otherwise, a representable character, rep_char, is:
    # (1) Any character in the processor-dependent character set in fixed source
    # form. A processor may restrict the occurrence of some of all of the
    # control characters. (2) Any graphic character in the processor-dependent
    # character set in free source form.

    character
  end

  rule scalar_char_constant
    # 8.4 (not explicitly defined)
    #
    # Note: Assumed constraint: named_constant must be of type default
    # character.

    char_literal_constant /
    named_constant
  end

  rule scalar_constant
    # Multiple uses (not explicitly defined)
    #
    # Note: Unclear what this is supposed to be... Assumed constraint: Any
    # named_constant must be scalar.

    literal_constant /
    named_constant
  end

  rule scalar_default_int_variable
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_default_int_variable must be scalar,
    # and must be of type default integer.    

    variable
  end

  rule scalar_int_constant
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: must be scalar and, if a variable name, must be
    # of type integer and must have the PARAMETER attribute.

    scalar_int_literal_constant /
    scalar_int_constant_name
  end

  rule scalar_int_constant_name
    # 4.3.1.1 (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_int_constant_name must be scalar, and
    # must be of type integer.

    named_constant
  end

  rule scalar_int_expr
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: must refer to a scalar entity of type integer.

    expr
  end
    
  rule scalar_int_literal_constant
    # 5.1.1.5 (not explicitly defined)
    #
    # Note: Assumed constraint: must be scalar of type integer.

    signed_int_literal_constant
  end

  rule scalar_int_variable
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_int_variable must be scalar, and must
    # be of type integer.    

    variable
  end

  rule scalar_logical_expr
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: logical_expr must be scalar.

    logical_expr
  end

  rule scalar_numeric_expr
    # Multiple users (not explicitly defined)
    #
    # Note: Assumed constraint: numeric_expr must be scalar.

    numeric_expr
  end

  rule scalar_variable
    # 8.1.4.1.1 (not explicitly defiend)
    #
    # Note: Unclear what is needed here, making assumption...

    scalar_variable_name
  end

  rule scalar_variable_name
    # Section 6 (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_variable_name must be scalar.

    variable_name
  end

  rule shared_term_do_construct
    # R831

    outer_shared_do_construct /
    inner_shared_do_construct
  end

  rule sign
    # R406

    t_plus /
    t_minus
  end

  rule signed_digit_string
    # R401

    sign? digit_string <Verbatim>
  end

  rule signed_int_literal_constant
    # R403

    sign? int_literal_constant <Verbatim>
  end

  rule signed_real_literal_constant
    # R412

    sign? real_literal_constant <Verbatim>
  end

  rule significand
    # R414

    digit_string t_dot digit_string? <Verbatim> /
    t_dot digit_string <Verbatim>
  end

  rule special_character
    # 3.1.4

    [\ \=\+\-\*\/\(\)\,\.\'\:\!\"\%\&\;\<\>\?\$]
  end

  rule specification_part
    # R204 -- INCOMPLETE

    #use_stmt* implicit_part? declaration_construct* <Cat>
    declaration_construct* <Cat>
  end

  rule specification_stmt
    # R214 -- INCOMPLETE

    data_stmt
  end

  rule stop_code
    # R843
    #
    # Constraint: scalar_char_constant must be of type default character.

    scalar_char_constant /
    t_digit 1..5 <Verbatim>
  end

  rule stop_stmt
    # R842

    label:label? t_stop stop_code? t_newline <Stmt>
  end

  rule t_apostrophe
    "'" <Verbatim>
  end

  rule t_assign
    "assign" <Verbatim>
  end

  rule t_binary
    [01] <Verbatim>
  end

  rule t_colon
    ":" <Verbatim>
  end

  rule t_comma
    "," <Verbatim>
  end

  rule t_continue
    "continue" <Verbatim>
  end

  rule t_cycle
    "cycle" <Verbatim>
  end

  rule t_data
    "data" <Verbatim>
  end

  rule t_digit
    [0-9] <Verbatim>
  end

  rule t_do
    "do" <Verbatim>
  end

  rule t_dot
    "." <Verbatim>
  end

  rule t_else
    "else" <Verbatim>
  end

  rule t_elseif
    "elseif" <Verbatim>
  end

  rule t_end
    "end" <Verbatim>
  end

  rule t_endif
    "endif" <Verbatim>
  end

  rule t_enddo
    "enddo" <Verbatim>
  end

  rule t_equal
    "=" <Verbatim>
  end

  rule t_exit
    "exit" <Verbatim>
  end

  rule t_false
    ".false." <Verbatim>
  end

  rule t_format
    "format" <Verbatim>
  end

  rule t_goto
    "goto" <Verbatim>
  end

  rule t_if
    "if" <Verbatim>
  end

  rule t_letter
    [a-z] <Verbatim>
  end

  rule t_minus
    "-" <Verbatim>
  end

  rule t_newline
    "\n" <Verbatim>
  end

  rule t_octal
    [01234567] <Verbatim>
  end

  rule t_pause
    "pause" <Verbatim>
  end

  rule t_paren_l
    "(" <Verbatim>
  end

  rule t_paren_r
    ")" <Verbatim>
  end

  rule t_plus
    "+" <Verbatim>
  end

  rule t_print
    "print" <Verbatim>
  end

  rule t_program
    "program" <Verbatim>
  end

  rule t_quotemark
    "\"" <Verbatim>
  end

  rule t_slash
    "/" <Verbatim>
  end

  rule t_star
    "*" <Verbatim>
  end

  rule t_stop
    "stop" <Verbatim>
  end

  rule t_then
    "then" <Verbatim>
  end

  rule t_to
    "to" <Verbatim>
  end

  rule t_true
    ".true." <Verbatim>
  end

  rule t_underscore
    # R303
    "_"
  end

  rule t_while
    "while" <Verbatim>
  end

  rule variable
    # R601 -- INCOMPLETE
    #
    # Constraint: scalar_variable_name must not have the PARAMETER attribute.
    # array_variable_name must be the name of a data object that is an array.
    # array_variable_name must not have the PARAMETER attribute. subobject
    # must not be a subobject designator (for example, a substring) whose
    # parent is a constant.

    scalar_variable_name
  end

  rule variable_name
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: variable_name must not have the PARAMETER
    # attribute.

    name
  end

#PM#
  rule t_allocatable
    "allocatable" <Verbatim>
  end

  rule t_character
    "character" <Verbatim>
  end

  rule t_complex
    "complex" <Verbatim>
  end

  rule t_dimension
    "dimension" <Verbatim>
  end

  rule t_doubleprecision
    "doubleprecision" <Verbatim>
  end

  rule t_external
    "external" <Verbatim>
  end

  rule t_integer
    "integer" <Verbatim>
  end

  rule t_intent
    "intent" <Verbatim>
  end

  rule t_intrinsic
    "intrinsic" <Verbatim>
  end

  rule t_len
    "len" <Verbatim>
  end

  rule t_logical
    "logical" <Verbatim>
  end

  rule t_parameter
    "parameter" <Verbatim>
  end

  rule t_optional
    "optional" <Verbatim>
  end

  rule t_pointer
    "pointer" <Verbatim>
  end

  rule t_real
    "real" <Verbatim>
  end

  rule t_save
    "save" <Verbatim>
  end

  rule t_target
    "target" <Verbatim>
  end

  rule t_type
    "type" <Verbatim>
  end

  rule type_declaration_stmt
    # R501
    #
    # Constraint: The same attr_spec must not appear more than once in a given
    # type_declaration_stmt.

    label:label? type_spec attr_spec_list? entity_decl_list t_newline <Verbatim>
  end

  rule attr_spec_list
    attr_spec ( t_comma attr_spec )* <Verbatim>
  end

  rule entity_decl_list
    entity_decl ( t_comma entity_decl )* <Verbatim>
  end

  rule type_spec
    # R502

    t_integer kind_selector? <Verbatim> /
    t_real kind_selector? <Verbatim> /
    t_doubleprecision /
    t_complex kind_selector? <Verbatim> /
    t_character char_selector? <Verbatim> /
    t_logical kind_selector? <Verbatim> /
    t_type t_paren_l type_name t_paren_r <Verbatim>
  end

  rule char_selector
    # R506
    #
    # Constraint: The value of scalar_int_initialization_expr must be
    # nonnegative and must specify a representation method that exists on the
    # processor.

    length_selector /
    t_paren_l len_pair type_param_value t_comma kind_pair scalar_int_initialization_expr t_paren_r <Verbatim> /
    t_paren_l type_param_value t_comma kind_pair? scalar_int_initialization_expr t_paren_r <Verbatim> /
    t_paren_l kind_pair scalar_int_initialization_expr ( t_comma len_pair type_param_value )? t_paren_r <Verbatim>
  end

  rule len_pair
    t_len t_equal <Verbatim>
  end

  rule length_selector
    # R507
    #
    # Constraint: The optional comma in a length_selector is permitted only in a
    # type_spec in a type_declaration_stmt. The optional comma in a
    # length_selector is permitted only if no double colon separator appears in
    # the type_declaration_stmt.

    t_paren_l len_pair? type_param_value t_paren_r <Verbatim> /
    char_length_pair t_comma? <Verbatim>
  end

  rule char_length
    # R508
    #
    # Constraint: The value of scalar_int_literal_constant must not include a
    # kind_param.

    t_paren_l type_param_value t_paren_r <Verbatim> /
    scalar_int_literal_constant
  end

  rule type_param_value
    # R509
    #
    # Constraint: A function name must not be declared with an asterisk
    # type_param_value if the function is an internal or module function,
    # array-valued, pointer-valued, or recursive.

    specification_expr /
    t_star
  end

  rule attr_spec
    # R503

    t_parameter /
    access_spec /
    t_allocatable /
    t_dimension t_paren_l array_spec t_paren_r <Verbatim> /
    t_external /
    t_intent t_paren_l intent_spec t_paren_r <Verbatim> /
    t_intrinsic /
    t_optional /
    t_pointer /
    t_save /
    t_target
  end

  rule entity_decl
    # R504
    #
    # Constraint: The function_name must be the name of an external function,
    # an intrinsic function, a function dummy procedure, or a statement
    # function. The initialization_expr_pair must appear if the statement
    # contains a PARAMETER attribute. If initialization_expr_pair appears, a
    # double colon separator must appear before the entity_decl_list. The
    # initialization_expr_pair must not appear if object_name is a dummy
    # argument, a function result, an object in a named common block unless the
    # type declaration is in a block data program unit, an object in blank
    # common, an allocatable array, a pointer, an external name, an intrinsic
    # name, or an automatic object. The char_length_pair is permitted only if
    # type type specified is character. The ALLOCATABLE attribute may be used
    # only when declaring an array that is not a dummy argument or a function
    # result. An array declared with a POINTER or an ALLOCATABLE attribute must
    # be specified with an array_spec that is a deferred_share_spec_list. If
    # the POINTER attribute is specified, the TARGET, INTENT, EXTERNAL, or
    # INTRINSIC attribute must not be specified. If the TARGET attribute is
    # specified, the POINTER, EXTERNAL, INTRINSIC, or PARAMETER attribute must
    # not be specified. The PARAMETER attribute must not be specified for dummy
    # arguments, pointers, allocatable arrays, functions, or objects in a common
    # block. The INTENT and OPTIONAL attributes may be specified only for dummy
    # arguments. An entity must not have the PUBLIC attribute if its type has
    # the PRIVATE attribute. The SAVE attribute must not be specified for an
    # object that is in a common block, a dummy argument, a procedure, a function
    # result, or an automatic data object. An entity must not have the EXTERNAL
    # attribute if it has the INTRINSIC attribute. An entity in a
    # type_declaration_stmt must not have the EXTERNAL or INTRINSIC attribute
    # specified unless it is a function. An array must not have both the
    # ALLOCATABLE and the POINTER attribute. An entity must not be given
    # explicitly any attribute more than once in a scoping unit.

    object_name entity_decl_array_spec? char_length_pair? initialization_expr_pair? <Verbatim> /
    function_name char_length_pair? <Verbatim>
  end

  rule entity_decl_array_spec
    t_paren_l array_spec t_paren_r <Verbatim>
  end

  rule char_length_pair
    t_star char_length <Verbatim>
  end

  rule initialization_expr_pair
    t_equal initialization_expr <Verbatim>
  end

  rule kind_selector
    # R505
    #
    # Constraint: The value of a scalar_int_initialization_expr must be
    # nonnegative and must specify a representation method that exists on the
    # processor.

    t_paren_l kind_pair? scalar_int_initialization_expr t_paren_r <Verbatim>
  end

  rule kind_pair
    t_kind t_equal <Verbatim>
  end

  rule type_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule object_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule function_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule scalar_int_initialization_expr
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: initialization_expr is scalar and is of type
    # integer.

    initialization_expression
  end

  rule specification_expr
    "specification_expr"
  end

  rule access_spec
    "access_spec"
  end

  rule array_spec
    "array_spec"
  end

  rule intent_spec
    "intent_spec"
  end

  rule initialization_expr
    # R730
    #
    # Constraint: An initialization_expr must be an initialization expression.

    expr
  end

  rule char_initialization_expr
    # R731
    #
    # Constraint: A char_initialization_expr must be an initialization
    # expression.

    char_expr
  end

  rule int_initialization_expr
    # R732
    #
    # Constraint: An int_initialization_expr must be an initialization
    # expression.

    int_expr
  end

  rule logical_initialization_expr
    # R733
    #
    # Constraint: A logical_initialization_expr must be an initialization
    # expression.

    logical_expr
  end

#PM#

end

# paul.a.madden@noaa.gov
