# NOTES: Grammar rule numbers or section numbers from the Fortran 90 standard
# document are given when possible. Grammar rule names used here match those
# from the standard document, with underscores in place of hyphens. Some left-
# recursive rules given by the standard have been translated to right-recursive
# for PEG compatability; the original (implied) rules are given in comments. The
# "start" rule must go first; other rules are in alphabetical order. Constraints
# described in the standard document are given in comments. Rule names for
# literal terminals not defined in the standard are prefixed with "t_". Rules
# not defined by the standard are introduced where they appear to be useful to
# for parsing. Ordered-choice order difference in many places from that given in
# the standard, for correctness.

grammar Fortran

  rule start
    program_unit+ <Program_Units>
  end

  rule ac_do_variable
    # F90:R435
    #
    # Constraint: ac_do_variable must be a named variable.

    scalar_int_variable
  end

  rule ac_implied_do
    # F90:R433

    t_paren_l ac_value_list t_comma ac_implied_do_control t_paren_r <E>
  end

  rule ac_implied_do_control
    # F90:R434

    ac_do_variable t_equal scalar_int_expr ( t_comma scalar_int_expr )? <E>
  end

  rule ac_value
    # F90:R432
    #
    # Constraint: Each ac_value expression in the array_constructor must have
    # the same type and type parameters.

    expr !t_equal /
    ac_implied_do
  end

  rule ac_value_list
    ac_value ( t_comma ac_value )* <E>
  end

  rule access_id
    # F90:R522
    #
    # Constraint: Each use_name must be the name of a named variable, procedure,
    # derived type, named constant, or namelist group.

    use_name /
    generic_spec
  end

  rule access_id_list
    access_id ( t_comma access_id )* <T>
  end

  rule access_spec
    # F90:R510
    #
    # Constraint: An access_spec attribute may appear only in the scoping unit
    # of a module.

    t_public /
    t_private
  end

  rule access_stmt
    # F90:R521
    #
    # Constraint: An access_stmt may appear only in the scoping unit of a
    # module. Only one accessibility statement with an omitted access_id_list is
    # permitted in the scoping unit of a module. A module procedure that has a
    # dummy argument or function result of a type that has PRIVATE accessibility
    # must have PRIVATE accessibility and must not have a generic identifier
    # that has PUBLIC accessibility.

    label:label? access_spec access_stmt_option? t_newline <StmtC>
  end

  rule access_stmt_option
    double_colon? access_id_list <Access_Stmt_Option>
  end

  rule action_stmt
    # F90:R216

    allocate_stmt /
    assignment_stmt /
    backspace_stmt /
    call_stmt /
    close_stmt /
    computed_goto_stmt /
    continue_stmt /
    cycle_stmt /
    deallocate_stmt /
    endfile_stmt /
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    if_stmt /
    inquire_stmt /
    nullify_stmt /
    open_stmt /
    pointer_assignment_stmt /
    print_stmt /
    read_stmt /
    return_stmt /
    rewind_stmt /
    stop_stmt /
    where_stmt /
    write_stmt /
    arithmetic_if_stmt /
    assign_stmt /
    assigned_goto_stmt /
    pause_stmt
  end

  rule action_term_do_construct
    # F90:R827

    label_do_stmt !{ |e| dolabel_dupe? } do_body do_term_action_stmt <E>
  end

  rule actual_arg
    # F90:R1213
    #
    # Constraint: A procedure_name actual_arg must not be the name of an
    # internal procedure or of a statement function and must not be the generic
    # name of a procedure (12.3.2.1, 13.1).

    expr /
    variable /
    procedure_name /
    alt_return_spec
  end

  rule actual_arg_spec
    # F90:R1211
    #
    # Constraint: The keyword = must not appear if the interface of the
    # procedure is implicit in the scoping unit. The keyword = may be omitted
    # from an actual_arg_spec only if the keyword = has been omitted from each
    # preceding actual_arg_spec in the argument list.

    keyword_option actual_arg <T>
  end

  rule actual_arg_spec_list
    actual_arg_spec ( t_comma actual_arg_spec )* <T>
  end

  rule add_op
    # F90:R710

    t_plus /
    t_minus
  end

  rule add_operand
    # F90:R706
    #
    # Note: Left-recursive rule implied by standard:
    # ( add_operand mult_op)? mult_operand

    mult_operand ( mult_op add_operand )? <T>
  end

  rule and_op
    # F90:R720

    ".and." <T>
  end

  rule allocatable_stmt
    # F90:R526
    #
    # Constraint: The array_name [ in an array_name_and_spec_list ] must not be
    # a dummy argument or function result. If the DIMENSION attribute for an
    # array_name is specified elsewhere in teh scoping unit, the array_spec must
    # be a deferred_shape_spec_list.

    label:label? t_allocatable double_colon?
      array_names_and_deferred_shape_spec_lists t_newline <Allocatable_Stmt>
  end

  rule allocate_lower_bound
    # F90:R627

    scalar_int_expr
  end

  rule allocate_object
    # F90:R625
    #
    # Constraint: Each allocate_object must be a pointer or an allocatable
    # array.

    !( t_stat t_equal ) structure_component /
    !( t_stat t_equal ) variable_name
  end

  rule allocate_object_list
    allocate_object ( t_comma allocate_object )* <T>
  end

  rule allocate_shape_spec
    # F90:R626

    ( allocate_lower_bound t_colon )? allocate_upper_bound <E>
  end

  rule allocate_shape_spec_list
    # F90:6.3.1
    #
    # Constraint: The number of allocate_shape_specs in an
    # allocate_shape_spec_list must be the same as the rank of the pointer or
    # allocatable array.

    allocate_shape_spec ( t_comma allocate_shape_spec )* <E>
  end

  rule allocate_stat_construct
    t_comma t_stat t_equal stat_variable <E>
  end

  rule allocate_stmt
    # F90:R622

    label:label? t_allocate t_paren_l allocation_list allocate_stat_construct?
      t_paren_r t_newline <StmtC>
  end

  rule allocate_upper_bound
    # F90:R628

    scalar_int_expr
  end

  rule allocation
    # F90:R624

    allocate_object parenthesized_allocate_shape_spec_list? <E>
  end

  rule allocation_list
    allocation ( t_comma allocation )* <T>
  end

  rule alphanumeric_character
    # F90:R302

    t_letter /
    t_digit /
    t_underscore
  end

  rule alt_return_spec
    # F90:R1214
    #
    # Constraint: The label used in the alt_return_spec must be the statement
    # label of a branch target statement that appears in the same scoping unit
    # as the call_stmt.

    t_star label <T>
  end

  rule arithmetic_if_stmt
    # F90:R840
    #
    # Constraint: Each label must be the label of a branch target statement that
    # appears in the same scoping unit as the arithmetic_if_stmt. The
    # scalar_numeric_expr must not be of type complex.

    label:label? t_if t_paren_l scalar_numeric_expr t_paren_r label t_comma
      label t_comma label t_newline <Arithmetic_If_Stmt>
  end

  rule array_constructor
    # F90:R431

    t_paren_l t_slash ac_value_list t_slash t_paren_r <E>
  end

  rule array_element
    # F90:R615
    #
    # Constraint: In an array_element, every part_ref must have rank zero and
    # the last part_ref must contain a subscript_list.
    #
    # Note: The requirement that the last part_ref contain a subscript_list is
    # not enforced or checked for here.

    data_ref
  end

  rule array_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule array_name_and_deferred_shape_spec_list
    array_name parenthesized_deferred_shape_spec_list? <E>
  end

  rule array_name_and_deferred_shape_spec_list_pair
    t_comma array_name_and_deferred_shape_spec_list <E>
  end

  rule array_names_and_deferred_shape_spec_lists
    array_name_and_deferred_shape_spec_list
      array_name_and_deferred_shape_spec_list_pair* <T>
  end

  rule array_name_and_spec
    array_name t_paren_l array_spec t_paren_r <E>
  end

  rule array_name_and_spec_pair
    t_comma array_name_and_spec <E>
  end

  rule array_names_and_specs
    array_name_and_spec array_name_and_spec_pair* <T>
  end

  rule array_section
    # F90:R616
    #
    # Constraint: In an array_section, exactly one part_ref must have nonzero
    # rank, and either the final part_ref has a section_subscript with nonzero
    # rank or another part_ref has nonzero rank. In an array_section with a
    # substring_range, the rightmost part_name has nonzero rank.

    data_ref substring_range_triplet? <E>
  end

  rule array_spec
    # F90:R512
    #
    # Constraint: The maximum rank is seven.

    explicit_shape_spec_list /
    assumed_shape_spec_list /
    deferred_shape_spec_list /
    assumed_size_spec
  end

  rule array_variable_name
    # Section 6 (not explicitly defined)
    #
    # Note: Assumed constraint: The object named by variable_name is an array.

    variable_name
  end

  rule assign_stmt
    # F90:R838
    #
    # Constraint: The label must be the statement label of a branch target
    # statement or format_stmt that appears in the same scoping unit as the
    # assign_stmt. scalar_int_variable must be named and of type default
    # integer.

    label:label? t_assign label t_to scalar_int_variable t_newline <StmtJ>
  end

  rule assigned_goto_stmt
    # F90:R839
    #
    # Constraint: Each label in label_list must be the statement label of a
    # branch target statement that appears in the same scoping unit as the
    # assigned_goto_stmt. scalar_int_variable must be named and of type
    # default integer.

    label:label? t_goto scalar_int_variable assigned_goto_stmt_label_list?
      t_newline <Assigned_Goto_Stmt>
  end

  rule assigned_goto_stmt_label_list
    t_comma? t_paren_l label_list t_paren_r <T>
  end

  rule assignment_stmt
    # F90:R735
    #
    # Constraint: A variable in an assignment_stmt must not be an assumed-size
    # array.

    label:label? variable t_equal expr t_newline <StmtC>
  end

  rule assumed_shape_spec
    # F90:R516

    lower_bound? t_colon <T>
  end

  rule assumed_size_spec
    # F90:R518
    #
    # Constraint: The function name of an array-valued function must not be
    # declared as an assumed-size array.

    ( explicit_shape_spec_list t_comma )? lower_bound_pair? t_star <T>
  end

  rule assumed_shape_spec_list
    assumed_shape_spec ( t_comma assumed_shape_spec )* <T>
  end

  rule attr_spec
    # F90:R503

    t_parameter /
    access_spec /
    t_allocatable /
    t_dimension t_paren_l array_spec t_paren_r <T> /
    t_external /
    t_intent t_paren_l intent_spec t_paren_r <T> /
    t_intrinsic /
    t_optional /
    t_pointer /
    t_save /
    t_target
  end

  rule attr_spec_list
    attr_spec ( t_comma attr_spec )* <T>
  end

  rule attr_spec_option
    t_comma attr_spec_list double_colon <T> /
    double_colon
  end

  rule backspace_stmt
    # F90:R919

    label:label? t_backspace t_paren_l position_spec_list t_paren_r t_newline
      <StmtC> /
    label:label? t_backspace external_file_unit t_newline <StmtJ>
  end

  rule binary_constant
    # F90:R408
    #
    # Constraint: digit must have one of the values 0 or 1. Note: 'digit is
    # replaced by 't_binary' here to enforce the constraint.

    "b" ( ( t_apostrophe t_binary+ t_apostrophe ) /
      ( t_quotemark t_binary+ t_quotemark ) ) <T>
  end

  rule block
    # F90:R801

    execution_part_construct
  end

  rule block_data
    # F90:R1110
    #
    # Constraint: A block_data specification_part may contain only USE
    # statements, type declaration statements, IMPLICIT statements,
    # derived-type definitions, and the following specification statements:
    # COMMON, DATA, DIMENSION, EQUIVALENCE, INTRINSIC, POINTER, SAVE, and
    # TARGET. A type declaration statement in a block_data specification_part
    # must not contains ALLOCATABLE, EXTERNAL, INTENT, OPTIONAL, PRIVATE, or
    # PUBLIC attribute specifiers.

    block_data_stmt specification_part? end_block_data_stmt <E>
  end

  rule block_data_name
    # F90:11.4 (not explicitly defined)

    name
  end

  rule block_data_stmt
    # F90:R1111

    label:label? t_block t_data block_data_name? t_newline <Block_Data_Stmt>
  end

  rule block_do_construct
    # F90:R817

    do_stmt do_block end_do <E>
  end

  rule boz_literal_constant
    # F90:R407
    #
    # Constraint: A boz-literal-constant may appear only in a DATA statement.

    binary_constant /
    octal_constant /
    hex_constant
  end

  rule call_stmt
    # F90:R1210

    label:label? t_call subroutine_name parenthesized_args? t_newline
      <Call_Stmt>
  end

  rule case_construct
    # F90:R808
    #
    # Constraint: If the select_case_stmt of a case_construct is identified by a
    # case_construct_name, the corresponding end_select_stmt must specify the
    # same case_construct_name. If the select_case_stmt of a case_construct is
    # not identified by a case_construct_name, the corresponding end_select_stmt
    # must not specify a case_construct_name. If a case_stmt is identified by a
    # case_construct_name, the corresponding select_case_stmt must specify the
    # same case_construct_name.

    select_case_stmt case_stmt_construct_block end_select_stmt <E>
  end

  rule case_construct_name
    name
  end

  rule case_construct_name_pair
    case_construct_name t_colon <T>
  end

  rule case_expr
    # F90:R812

    scalar_int_expr /
    scalar_char_expr /
    scalar_logical_expr
  end

  rule case_selector
    # F90:R813
    #
    # Constraint: No more than one of the selectors of one of the CASE
    # statements may be DEFAULT.

    case_selector_range /
    t_default
  end

  rule case_selector_range
    t_paren_l case_value_range_list t_paren_r <E>
  end

  rule case_stmt
    # F90:R810

    label:label? t_case case_selector case_construct_name? t_newline <Case_Stmt>
  end

  rule case_stmt_construct
    case_stmt block <E>
  end

  rule case_stmt_construct_block
    case_stmt_construct* <E>
  end

  rule case_value
    # F90:R815
    #
    # Constraint: For a given case_construct, each case_value must be of the
    # same type as case_expr. For character type, length differences are
    # allowed, but the kind type parameters must be the same.

    scalar_int_initialization_expr /
    scalar_char_initialization_expr /
    scalar_logical_initialization_expr
  end

  rule case_value_range
    # F90:R814
    #
    # Constraint: A case_value_range using a colon must not be used if case_expr
    # is of type logical. For a given case_construct, the case_value_ranges must
    # not overlap; that is, there must be no possible value of the case_expr
    # that matches more than one case_value_range.

    t_colon case_value <T> /
    case_value t_colon case_value <T> /
    case_value t_colon <T> /
    case_value
  end

  rule case_value_range_list
    case_value_range ( t_comma case_value_range )* <T>
  end

  rule char_expr
    # F90:R726
    #
    # Constraint: char_expr must be type character.

    expr
  end

  rule char_initialization_expr
    # F90:R731
    #
    # Constraint: A char_initialization_expr must be an initialization
    # expression (7.1.6.1).

    char_expr
  end

  rule char_length
    # F90:R508
    #
    # Constraint: The value of scalar_int_literal_constant must not include a
    # kind_param.

    t_paren_l type_param_value t_paren_r <T> /
    scalar_int_literal_constant
  end

  rule char_length_pair
    t_star char_length <T>
  end

  rule char_literal_constant
    # F90:R420
    #
    # Constraint: The value of kind_param must specify a representation method
    # that exists on the processor.

    ( kind_param t_underscore )? char_literal_constant_sq <T> /
    ( kind_param t_underscore )? char_literal_constant_dq <T>
  end

  rule char_literal_constant_dq
    t_quotemark (!t_quotemark rep_char)* t_quotemark <T>
  end

  rule char_literal_constant_sq
    t_apostrophe (!t_apostrophe rep_char)* t_apostrophe <T>
  end

  rule char_selector
    # F90:R506
    #
    # Constraint: The value of scalar_int_initialization_expr must be
    # nonnegative and must specify a representation method that exists on the
    # processor.

    length_selector /
    t_paren_l len_pair type_param_value t_comma kind_pair
      scalar_int_initialization_expr t_paren_r <T> /
    t_paren_l type_param_value t_comma kind_pair? scalar_int_initialization_expr
      t_paren_r <T> /
    t_paren_l kind_pair scalar_int_initialization_expr ( t_comma len_pair
      type_param_value )? t_paren_r <T>
  end

  rule char_variable
    # F90:R605
    #
    # Constraint: char_variable must be of type character.

    variable
  end

  rule character
    # F90:R301

    alphanumeric_character /
    special_character
  end

  rule close_spec
    # F90:R908
    #
    # Constraint: If the optional characters UNIT = are omitted from the unit
    # specifier, the unit specifier must be the first item in the
    # close_spec_list. Each specifier must not appear more than once in a given
    # close_stmt; an external_file_unit must be specified. The label used in the
    # ERR = specifier must be the statement label of a branch target statement
    # that appears in the same scoping unit as the CLOSE statement.

    t_iostat t_equal scalar_default_int_variable <T> /
    t_err t_equal label <T> /
    t_status t_equal scalar_default_char_expr <T> /
    ( t_unit t_equal )? external_file_unit <T>
  end

  rule close_spec_list
    close_spec ( t_comma close_spec )* <T>
  end

  rule close_stmt
    # F90:R907

    label:label? t_close t_paren_l close_spec_list t_paren_r t_newline <StmtC>
  end

  rule common_block_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule common_block_name_and_object_list
    t_comma? common_block_name_triplet common_block_object_list
      <Common_Block_Name_And_Object_List>
  end

  rule common_block_name_and_object_lists
    common_block_name_and_object_list* <E>
  end

  rule common_block_name_triplet
    t_slash common_block_name? t_slash <T>
  end

  rule common_block_object
    # F90:R549
    #
    # Constraint: Each bound in the explicit_shape_list must be a constant
    # specification expression (7.1.6.2) If a variable_name appears with an
    # explicit_shape_spec_list, it must not have the POINTER attribute.

    variable_name common_block_object_explicit_shape_spec_list? <T>
  end

  rule common_block_object_explicit_shape_spec_list
    parenthesized_explicit_shape_spec_list
  end

  rule common_block_object_list
    common_block_object common_block_object_pairs <E>
  end

  rule common_block_object_pair
    t_comma common_block_object <E>
  end

  rule common_block_object_pairs
    common_block_object_pair* <E>
  end

  rule common_stmt
    # F90:R548
    #
    # Constraint: Only one appearance of a given variable_name is permitted in
    # all common_block_object_lists withing a scoping unit. A
    # common_block_object must not be a dummy argument, an allocatable array,
    # an automatic object, a function name, an entry name, or a result name. If
    # a common_block_object is of a derived type, it must be a sequence type
    # (4.4.1).

    label:label? t_common common_block_name_triplet? common_block_object_list
      common_block_name_and_object_lists t_newline <Common_Stmt>
  end

  rule complex_literal_constant
    # F90:R417

    t_paren_l real_part t_comma imag_part t_paren_r <T>
  end

  rule component_array_spec
    # F90:R428
    #
    # Constraint: Each bound in the explicit_shape_spec (R428) must be a
    # constant specification expression (7.1.6.2).

    explicit_shape_spec_list /
    deferred_shape_spec_list
  end

  rule component_attr_spec
    # F90:R427
    #
    # Constraint: No component_attr_spec may appear more than once in a given
    # component_def_stmt. If the POINTER attribute is not specified for a
    # component, a type_spec in the component_def_stmt must specify an intrinsic
    # type or a previously defined derived type. If the POINTER attribute is
    # specified for a component, a type_spec in the component_def_stmt must
    # specify an intrinsic type of any accessible derived type including the
    # type being defined. If the POINTER attribute is not specified, each
    # component_array_spec must be an explicit_shape_spec_list. If the POINTER
    # attribute is specified, each component_array_spec must be a
    # deferred_share_spec_list.

    t_pointer /
    t_dimension t_paren_l component_array_spec t_paren_r <E>
  end

  rule component_attr_spec_list
    component_attr_spec ( t_comma component_attr_spec )* <E>
  end

  rule component_attr_spec_list_option
    ( t_comma component_attr_spec_list )? double_colon <T>
  end

  rule component_decl
    # F90:R429
    #
    # Constraint: The t_star char_length option is permitted only if the type
    # specified is character. The character length specified by the char_length
    # in a component_decl or the char_selector in a type_spec (5.1, 5.1.1.5)
    # must be a constant specification expression (7.1.6.2).

    component_name parenthesized_component_array_spec? ( t_star char_length )?
      <E>
  end

  rule component_decl_list
    component_decl ( t_comma component_decl )* <T>
  end

  rule component_def_stmt
    # F90:R426

    label:label? type_spec component_attr_spec_list_option? component_decl_list
      t_newline <Component_Def_Stmt>
  end

  rule component_def_stmts
    component_def_stmt+ <E>
  end

  rule component_name
    # F90:4.4.1 (not explicitly defined)

    name
  end

  rule computed_goto_stmt
    # F90:R837
    #
    # Constraint: Each label in label_list must be the statement label of a
    # branch target statement that appears in the same scoping unit as the
    # computed_goto_stmt.

    label:label? t_goto t_paren_l label_list t_paren_r t_comma? scalar_int_expr
      t_newline <Computed_Goto_Stmt>
  end

  rule concat_op
    # F90:R712

    "//" <T>
  end

  rule connect_spec
    # F90:R905
    #
    # Constraint: If the optional characters UNIT = are omitted from the unit
    # specifier, the unit specifier must be the first item in the
    # connect_spec_list. Each specifier must not appear more than once in a
    # given open_stmt; an external_file_unit must be specified. The label used
    # in the ERR = specifier must be the statement label of a branch target
    # statement that appears in the same scoping unit as the OPEN statement.

    t_iostat t_equal scalar_default_int_variable <T> /
    t_err t_equal label <T> /
    t_file t_equal file_name_expr <T> /
    t_status t_equal scalar_default_char_expr <T> /
    t_access t_equal scalar_default_char_expr <T> /
    t_form t_equal scalar_default_char_expr <T> /
    t_recl t_equal scalar_int_expr <T> /
    t_blank t_equal scalar_default_char_expr <T> /
    t_position t_equal scalar_default_char_expr <T> /
    t_action t_equal scalar_default_char_expr <T> /
    t_delim t_equal scalar_default_char_expr <T> /
    t_pad t_equal scalar_default_char_expr <T> /
    ( t_unit t_equal )? external_file_unit <T>
  end

  rule connect_spec_list
    connect_spec ( t_comma connect_spec )* <T>
  end

  rule constant
    # F90:R305

    literal_constant /
    named_constant
  end

  rule constant_subobject
    # F90:R702
    #
    # Constrint: subobject must be a subobject designator whose parent is a

    subobject
  end

  rule contains_stmt
    # F90:R1225

    label:label? t_contains t_newline <Contains_Stmt>
  end

  rule continue_stmt
    # F90:R841

    label:label? t_continue t_newline <StmtJ>
  end

  rule cycle_stmt
    # F90:R834
    #
    # Constraint: If a cycle_stmt refers to a do_construct_name, it must be
    # within the range of that do_construct; otherwise, it must be within the
    # range of at least one do_construct.

    label:label? t_cycle do_construct_name? t_newline <StmtJ>
  end

  rule data_i_do_object
    # F90:R536
    #
    # Constraint: The array_element must not have a constant parent. The
    # scalar_structure_component must not have a constant parent. In an
    # array_element or a scalar_structure_component that is a data_i_do_object,
    # any subscript must be an expression whose primaries are either constant or
    # DO variables of the containing data_implied_dos, and each operation must
    # be intrinsic.

    array_element !t_equal <E> /
    scalar_structure_component !t_equal <E> /
    data_implied_do
  end

  rule data_i_do_object_list
    data_i_do_object ( t_comma data_i_do_object )* <E>
  end

  rule data_i_do_variable
    # F90:R537
    #
    # Constraint: The data_i_do_variable must be a named variable.

    scalar_int_variable
  end

  rule data_implied_do
    # F90:R535
    #
    # Constraint: A scalar_int_expr of a data_implied_do must involve as
    # primaries only constants or DO variables of the containing
    # data_implied_dos, and each operation must be intrinsic.

    t_paren_l data_i_do_object_list t_comma data_i_do_variable t_equal
      scalar_int_expr t_comma scalar_int_expr ( t_comma scalar_int_expr )*
      t_paren_r <T>
  end

  rule data_ref
    # F90:R612
    #
    # Constraint: In a data_ref, each part_name except the rightmost must be
    # of derived type. In a data_ref, each part_name except the leftmost must be
    # the name of a component of the derived type definition of the type of the
    # preceding part_name.

    part_ref ( t_percent part_ref )* <T>
  end

  rule data_stmt
    # F90:R529

    label:label? t_data data_stmt_set_list t_newline <StmtJ>
  end

  rule data_stmt_constant
    # F90:R533
    #
    # Constraint: If a data_stmt_constant is a structure_constructor, each
    # component must be an initialization expression (7.1.6.1). Note: Choice
    # order changed vs that presented in standard.

    signed_real_literal_constant /
    signed_int_literal_constant /
    boz_literal_constant /
    structure_constructor /
    scalar_constant
  end

  rule data_stmt_object
    # F90:R531
    #
    # Constraint: In a variable that is a data_stmt_object, any subscript,
    # section subscript, substring starting point, and substring ending point
    # must be an initialization expression (7.1.6.1). A variable whose name or
    # designator is included in a data_stmt_object_list or a
    # data_i_do_object_list must not be: a dummy argument, made accessible by
    # use assocation or host association, in a named common block unless the
    # DATA statement is in a block data program unit, in a blank common block,
    # a function name, a function result name, an automatic object, a pointer,
    # or an allocatable array.

    variable /
    data_implied_do
  end

  rule data_stmt_object_list
    data_stmt_object ( t_comma data_stmt_object )* <T>
  end

  rule data_stmt_repeat
    # F90:R534
    #
    # Constraint: The DATA statement repeat factor must be positive or zero. If
    # the DATA statement repeat factor is a named constant, it must have been
    # declared previously in the scoping unit or made accessible by use
    # association or host association.

    scalar_int_constant
  end

  rule data_stmt_set
    # F90:R530

    data_stmt_object_list t_slash data_stmt_value_list t_slash <E>
  end

  rule data_stmt_set_list
    data_stmt_set data_stmt_set_list_pairs <E>
  end

  rule data_stmt_set_list_pair
    t_comma data_stmt_set <E>
  end

  rule data_stmt_set_list_pairs
    data_stmt_set_list_pair* <E>
  end

  rule data_stmt_value
    # F90:R531

    data_stmt_repeat_pair? data_stmt_constant <T>
  end

  rule data_stmt_repeat_pair
    data_stmt_repeat t_star <T>
  end

  rule data_stmt_value_list
    data_stmt_value ( t_comma data_stmt_value )* <T>
  end

  rule deallocate_stmt
    # F90:R631
    #
    # Constraint: Each allocate_object must be a pointer or an allocatable
    # array.

    label:label? t_deallocate t_paren_l allocate_object_list
      allocate_stat_construct? t_paren_r t_newline <StmtC>
  end

  rule declaration_construct
    # F90:R207

    derived_type_def /
    interface_block /
    type_declaration_stmt /
    specification_stmt /
    parameter_stmt /
    format_stmt /
    entry_stmt /
    stmt_function_stmt /
#    sms_declarative
    directive
  end

  rule declaration_constructs
    declaration_construct* <E>
  end

  rule default_char_variable
    # F90:R606
    #
    # Constraint: default_char_variable must be of type default character.

    variable
  end

  rule default_char_expr
    # F90:R727
    #
    # Constraint: default_char_expr must be of type default character.

    expr
  end

  rule default_int_variable
    # F90:R608
    #
    # Constraint: default_int_variable must be of type default integer.

    variable
  end

  rule default_logical_variable
    # F90:R604
    #
    # Constraint: default_logical_variable must be of type default logical.

    variable
  end

  rule deferred_shape_spec
    # F90:R517

    t_colon
  end

  rule deferred_shape_spec_list
    deferred_shape_spec ( t_comma deferred_shape_spec )* <T>
  end

  rule defined_binary_op
    # F90:R724
    #
    # Constraint: Must not contain more than 31 letters and must not be the same
    # as any intrinsic_operator or logical_literal_constant.

    t_dot t_letter t_letter+ t_dot <T>
  end

  rule defined_operator
    # F90:R311

    defined_unary_op /
    defined_binary_op /
    extended_intrinsic_op
  end

  rule defined_unary_op
    # F90:R704
    #
    # Constraint: Must not contain more than 31 letters and must not be the same
    # as any intrinsic_operator or logical_literal_constant.

    !( intrinsic_operator / logical_literal_constant ) t_dot t_letter t_letter+
      t_dot <T>
  end

  rule derived_type_def
    # F90:R422
    #
    # Constraint: An access_spec (5.1.2.2) or a PRIVATE statement within the
    # definition is permitted only if the type definition is within the
    # specification part of a module. If a component of a derived type is of a
    # type declared to be private, either the derived type definition must
    # contain the PRIVATE statement, or the derived type must be private.

    derived_type_stmt private_sequence_stmts component_def_stmts end_type_stmt
      <E>
  end

  rule derived_type_stmt
    # F90:R424
    #
    # Constraint: A derived type type_name must not be the same as the name of
    # any intrinsic type nor the same as any other accessible derived type
    # type_name.

    label:label? t_type derived_typeaccess_spec? type_name t_newline
      <Derived_Type_Stmt>
  end

  rule derived_typeaccess_spec
    ( t_comma access_spec )? double_colon <T>
  end

  rule digit_string
    # F90:R402

    t_digit+ <T>
  end

  rule dimension_stmt
    # F90:R525

    label:label? t_dimension double_colon? array_names_and_specs t_newline
      <Dimension_Stmt>
  end

  rule directive
    # Note: Any "comment" not stripped out during normalization is assumed to be
    # a directive.

    "!" character+ t_newline <T>
  end

  rule do_block
    # F90:R823

    block
  end

  rule do_body
    # F90:R828

    execution_part_construct
  end

  rule do_construct
    # F90:R816

    nonblock_do_construct /
    block_do_construct
  end

  rule do_construct_name
    # F90:8.1.4.1.1 (not explicitly defiend)
    #
    # Note: Unclear what is needed here, making assumption...

    name
  end

  rule do_construct_name_label
    do_construct_name t_colon <T>
  end

  rule do_stmt
    # F90:R818

    label_do_stmt /
    nonlabel_do_stmt
  end

  rule do_term_action_stmt
    # F90:R829
    #
    # Constraint: A do_term_action_stmt must not be a continue_stmt, a
    # goto_stmt, a return_stmt, a stop_stmt, an exit_stmt, a cycle_stmt, an
    # end_function_stmt, an end_subroutine_stmt, an end_program_stmt, an
    # arithmetic_if_stmt, or an assigned_goto_stmt. The do_term_action_stmt
    # must be identified with a label and the corresponding label_do_stmt
    # must refer to the same label.

    !do_term_action_stmt_disallowed action_stmt &{ |e| nonblock_do_end!(e[1]) }
      <Do_Term_Action_Stmt>
  end

  rule do_term_action_stmt_disallowed
    arithmetic_if_stmt /
    assigned_goto_stmt /
    continue_stmt /
    cycle_stmt /
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    return_stmt /
    stop_stmt
  end

  rule do_term_shared_stmt
    # F90:R833
    #
    # Constraint: A do_term_shared_stmt must not be a goto_stmt, a return_stmt,
    # a stop_stmt, an exit_stmt, a cycle_stmt, an end_fuction_stmt, an
    # end_subroutine_stmt, and end_program_stmt, an arithmetic_if_stmt, or an
    # assigned_goto_stmt.

    !do_term_shared_stmt_disallowed action_stmt &{ |e| nonblock_do_end!(e[1]) }
      <Do_Term_Shared_Stmt>
  end

  rule do_term_shared_stmt_disallowed
    arithmetic_if_stmt /
    assigned_goto_stmt /
    cycle_stmt /
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt /
    exit_stmt /
    goto_stmt /
    return_stmt /
    stop_stmt
  end

  rule do_variable
    # F90:R822
    #
    # Constraint: The do_variable must be a name scalar variable of type
    # integer, default real, or double precision real.

    scalar_variable
  end

  rule double_colon
    t_colon t_colon <T>
  end

  rule dummy_arg
    # F90:R1221

    dummy_arg_name /
    t_star
  end

  rule dummy_arg_list
    dummy_arg ( t_comma dummy_arg )* <T>
  end

  rule dummy_arg_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule dummy_arg_list_option
    t_paren_l dummy_arg_list? t_paren_r <E>
  end

  rule dummy_arg_name_list
    dummy_arg_name ( t_comma dummy_arg_name )* <T>
  end

  rule else_construct
    else_stmt block <E>
  end

  rule else_if_construct
    else_if_construct_element+ <E>
  end

  rule else_if_construct_element
    else_if_stmt block <E>
  end

  rule else_if_stmt
    # F90:R804

    label:label? t_elseif t_paren_l scalar_logical_expr t_paren_r t_then
      t_newline <Else_If_Stmt>
  end

  rule else_stmt
    # F90:R805

    label:label? t_else if_construct_name? t_newline <Else_Stmt>
  end

  rule elsewhere_construct
    elsewhere_stmt where_assignment_stmt_block <E>
  end

  rule elsewhere_stmt
    # F90:R742

    label:label? t_elsewhere t_newline <Elsewhere_Stmt>
  end

  rule end_block_data_option
    t_block t_data block_data_name? <End_Block_Data_Option>
  end

  rule end_block_data_stmt
    # F90:R1112
    #
    # Constraint: The block_data_name may be included in the end_block_data_stmt
    # only if it was provided in the block_stat_stmt and, if included, must be
    # identical to the block_data_name in the block_data_stmt.

    label:label? t_end end_block_data_option? t_newline <End_Block_Data_Stmt>
  end

  rule end_do
    # F90:R824
    # Constraint: If the do_stmt of a block_do_construct is identified by a
    # do_construct_name, the corresponding end_do must be an end_do_stmt
    # specifying the same do_construct_name. If the do_stmt of a
    # block_do_construct is not identified by a do_construct_name, the
    # corresponding end_do must not specify a do_construct_name. If the do_stmt
    # is a nonlabel_do_stmt, the corresponding end_do must be an end_do_stmt.
    # If the do_stmt is a label_do_stmt, the corresponding end_do must be
    # identified with the same label.

    end_do_stmt /
    end_do_continue_stmt
  end

  rule end_do_continue_stmt
    label:label? t_continue t_newline &{ |e| dolabel_pop(e[0]) } <End_Do_Stmt>
  end

  rule end_do_stmt
    # F90:R825

    label:label? t_enddo do_construct_name? t_newline &{ |e| dolabel_pop(e[0]) }
      <End_Do_Stmt>
  end

  rule end_function_option
    t_function function_name? <J>
  end

  rule end_function_stmt
    # F90:R1218
    #
    # Constraint: FUNCTION must be present on the end_function_stmt of an
    # internal or module function. If a function_name is present on the
    # end_function_stmt, it must be identical to the function_name specified in
    # the function_stmt.

    label:label? t_end end_function_option? t_newline <End_Function_Stmt>
  end

  rule end_if_stmt
    # F90:R806

    label:label? t_endif if_construct_name? t_newline <End_If_Stmt>
  end

  rule end_interface_stmt
    # F90:R1203

    label:label? t_end t_interface t_newline <End_Interface_Stmt>
  end

  rule end_module_option
    t_module module_name? <End_Module_Option>
  end

  rule end_module_stmt
    # F90:R1106
    #
    # Constraint: If the module_name is specified in the end_module_stmt, it
    # must be identical to the module_name specified in the module_stmt.

    label:label? t_end end_module_option? t_newline <End_Module_Stmt>
  end

  rule end_program_stmt
    # F90:R1103
    #
    # Constraint: The program_name may be included in the end_program_stmt only
    # if the optional program_stmt is used and, if included, must be identical
    # to the program_name specified in the program_stmt.

    label:label? t_end !end_program_stmt_disallowed t_program?
      name:program_name? t_newline? <End_Program_Stmt>
  end

  rule end_program_stmt_disallowed
    t_block /
    t_function /
    t_interface /
    t_module /
    t_select /
    t_subroutine /
    t_type
  end

  rule end_select_stmt
    # F90:R811

    label:label? t_end t_select case_construct_name? t_newline <End_Select_Stmt>
  end

  rule end_subroutine_stmt
    # F90:R1222
    #
    # Constraint: SUBROUTINE must be present on the end_subroutine_stmt of an
    # internal or module subroutine. If a subroutine_name is present on the
    # end_subroutine_stmt, it must be identical to the subroutine_name specified
    # in the subroutine_stmt.

    label:label? t_end end_subroutine_option? t_newline <End_Subroutine_Stmt>
  end

  rule end_subroutine_option
    t_subroutine subroutine_name? <J>
  end

  rule end_type_stmt
    # F90:R415
    #
    # Constraint: If END TYPE is followed by a type_name, the type_name must be
    # the same as that in the corresponding derived_type_stmt.

    label:label? t_end t_type type_name? t_newline <End_Type_Stmt>
  end

  rule end_where_stmt
    # F90:R743

    label:label? t_endwhere t_newline <End_Where_Stmt>
  end

  rule endfile_stmt
    # F90:R920

    label:label? t_endfile t_paren_l position_spec_list t_paren_r t_newline
      <StmtC> /
    label:label? t_endfile external_file_unit t_newline <StmtJ>
  end

  rule entity_decl
    # F90:R504
    #
    # Constraint: The function_name must be the name of an external function,
    # an intrinsic function, a function dummy procedure, or a statement
    # function. The initialization_expr_pair must appear if the statement
    # contains a PARAMETER attribute. If initialization_expr_pair appears, a
    # double colon separator must appear before the entity_decl_list. The
    # initialization_expr_pair must not appear if object_name is a dummy
    # argument, a function result, an object in a named common block unless the
    # type declaration is in a block data program unit, an object in blank
    # common, an allocatable array, a pointer, an external name, an intrinsic
    # name, or an automatic object. The char_length_pair is permitted only if
    # type type specified is character. The ALLOCATABLE attribute may be used
    # only when declaring an array that is not a dummy argument or a function
    # result. An array declared with a POINTER or an ALLOCATABLE attribute must
    # be specified with an array_spec that is a deferred_share_spec_list. If
    # the POINTER attribute is specified, the TARGET, INTENT, EXTERNAL, or
    # INTRINSIC attribute must not be specified. If the TARGET attribute is
    # specified, the POINTER, EXTERNAL, INTRINSIC, or PARAMETER attribute must
    # not be specified. The PARAMETER attribute must not be specified for dummy
    # arguments, pointers, allocatable arrays, functions, or objects in a common
    # block. The INTENT and OPTIONAL attributes may be specified only for dummy
    # arguments. An entity must not have the PUBLIC attribute if its type has
    # the PRIVATE attribute. The SAVE attribute must not be specified for an
    # object that is in a common block, a dummy argument, a procedure, a
    # function result, or an automatic data object. An entity must not have the
    # EXTERNAL attribute if it has the INTRINSIC attribute. An entity in a
    # type_declaration_stmt must not have the EXTERNAL or INTRINSIC attribute
    # specified unless it is a function. An array must not have both the
    # ALLOCATABLE and the POINTER attribute. An entity must not be given
    # explicitly any attribute more than once in a scoping unit.

    object_name entity_decl_array_spec? char_length_pair?
      initialization_expr_pair? <Entity_Decl> /
    function_name char_length_pair? <T>
  end

  rule entity_decl_list
    entity_decl entity_decl_list_pairs <Entity_Decl_List>
  end

  rule entity_decl_list_pair
    t_comma entity_decl <Entity_Decl_List_Pair>
  end

  rule entity_decl_list_pairs
    entity_decl_list_pair* <Entity_Decl_List_Pairs>
  end

  rule entity_decl_array_spec
    t_paren_l array_spec t_paren_r <T>
  end

  rule entry_name
    # F90:12.5.2.5 (not explicitly defined)

    name
  end

  rule entry_stmt
    # F90:R1223
    #
    # Constraint: If RESULT is specified, the entry_name must not appear in any
    # specification statement in the scoping unit of the function program. An
    # entry_stmt may appear only in an external_subprogram or module_subprogram.
    # An entry_stmt must not appear within an executable_construct. RESULT may
    # be present only if the entry_stmt is contained in a function subprogram.
    # Within the subprogram containing the entry_stmt, the entry_name must not
    # appear as a dummy argument in the FUNCTION or SUBROUTINE statement or in
    # another ENTRY statement and it must not appear in an EXTERNAL or INTRINSIC
    # statement. A dummy-arg may be an alternate return indicator only if the
    # ENTRY statement is contained in a subroutine subprogram. If RESULT is
    # specified, result_name must not be the same as entry_name.

    label:label? t_entry entry_name dummy_arg_list_option? result_option?
      t_newline <Entry_Stmt>
  end

  rule equiv_op
    # F90:R722

    ".eqv." <T> /
    ".neqv." <T>
  end

  rule equiv_operand
    # F90:R715

    not_op? level_4_expr <T>
  end

  rule equivalence_object
    # F90:R547
    #
    # Constraint: An equivalence_object must not be a dummy argument, a pointer,
    # an allocatable array, an object of a nonsequence derived type or of a
    # sequence derived type containing a pointer at any level of component
    # selection, an automatic object, a function name, an entry name, a result
    # name, a named constant, a structure component, or a subobject of any of
    # the preceding objects. Each subscript or substring range expression in an
    # equivalence_object must be an integer initialization expression (7.1.6.1).
    # If an equivalence_object is of type default integer, default real, double
    # precision real, default complex, default logical, or numeric sequence
    # type, all of the objects in the equivalence set must be of these types. If
    # an equivalence_object is of type default character or character sequence
    # type, all of the objects in the equivalence set must be of these types. If
    # an equivalence_object is of a derived type that is not a numeric sequence
    # or character sequence type, all of the objects in the equivalence set must
    # be of the same type. If an equivalence_object is of an intrinsic type
    # other than default integer, default real, double precision real, default
    # complex, default logical, or default character, all of the objects in the
    # equivalence set must be of the same type with the same kind type parameter
    # value.

    substring /
    array_element /
    variable_name
  end

  rule equivalence_object_list
    equivalence_object ( t_comma equivalence_object )? <T>
  end

  rule equivalence_set
    # F90:R546

    t_paren_l equivalence_object t_comma equivalence_object_list t_paren_r <T>
  end

  rule equivalence_set_list
    equivalence_set ( t_comma equivalence_set )* <T>
  end

  rule equivalence_stmt
    # F90:R545

    label:label? t_equivalence equivalence_set_list t_newline <StmtJ>
  end

  rule executable_construct
    # F90:R215

    executable_construct_action_stmt /
    case_construct /
    do_construct /
    if_construct /
    where_construct /
#    sms_executable
    directive
  end

  rule executable_construct_action_stmt
    !execution_part_disallowed action_stmt !{ |e| nonblock_do_end?(e[1]) }
      <StmtJ>
  end

  rule execution_part
    # F90:R208
    #
    # Constraint: An execution_part must not contain an end_function_stmt,
    # end_program_stmt, or end_subroutine_stmt.

    executable_construct execution_part_construct <E>
  end

  rule execution_part_disallowed
    end_function_stmt /
    end_program_stmt /
    end_subroutine_stmt
  end

  rule execution_part_construct
    # F90:R209

    (
      executable_construct /
      format_stmt /
      data_stmt /
      entry_stmt
    )* <E>
  end

  rule exit_stmt
    # F90:R835
    #
    # Constraint: If an exit_stmt refers to a do_construct_name, it must be
    # within the range of that do_construct; otherwise, it must be within the
    # range of at least one do_construct.

    label:label? t_exit do_construct_name? t_newline <StmtJ>
  end

  rule explicit_shape_spec
    # F90:R513
    #
    # Constraint: An explicit-shape array whose bounds depend on the values of
    # nonconstant expressions must be a dummy argument, a function result, or an
    # automatic array of a procedure.

    lower_bound_pair? upper_bound <T>
  end

  rule explicit_shape_spec_list
    explicit_shape_spec ( t_comma explicit_shape_spec )* <T>
  end

  rule exponent
    # F90:R416

    signed_digit_string
  end

  rule exponent_letter
    # F90:R415

    [ed] <T>
  end

  rule expr
    # F90:R723
    #
    # Note: Left-recursive rule implied by standard:
    # ( expr defined_binary_op )? level_5_expr

    level_5_expr ( defined_binary_op expr )? <T>
  end

  rule expr_list
    expr ( t_comma expr )* <E>
  end

  rule extended_intrinsic_op
    # F90:R312

    intrinsic_operator
  end
  
  rule external_file_unit
    # F90:R902

    scalar_int_expr
  end

  rule external_name
    # F90:12.3.2.2

    name
  end

  rule external_name_list
    external_name ( t_comma external_name )* <T>
  end

  rule external_stmt
    # F90:R1207

    label:label? t_external external_name_list t_newline <StmtJ>
  end

  rule external_subprogram
    # F90:R203

    subroutine_subprogram /
    function_subprogram
  end

  rule file_name_expr
    # F90:R906

    scalar_default_char_expr
  end

  rule format
    # F90:R913
    #
    # Constraint: The label must be the label of a FORMAT statement that appears
    # in the same scoping unit as the statement containing the format specifier.
    # The scalar_default_int_variable must have been assigned (8.2.4) the
    # statement label of a FORMAT statement that appears in the same scoping
    # unit as the format.

    default_char_expr /
    label /
    t_star /
    scalar_default_int_variable
  end

  rule format_specification
    # F90:R1002
    #
    # Note: A vast simplification is made here under the assumption that it is
    # only necessary to pass a format-specification through verbatim, not to
    # analyze its contents.

    t_paren_l (!t_paren_r character)+ t_paren_r <T>
  end

 rule format_stmt
    # F90:R1001
    #
    # Constraint: The format_stmt must be labeled.

    label t_format format_specification t_newline <StmtJ>
  end

  rule function_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule function_reference
    # F90:R1209

    function_name t_paren_l parenthesized_args? t_paren_r <T>
  end

  rule function_stmt
    # F90:R1216
    #
    # Constraint: If RESULT is specified, result_name must not be the same as
    # function_name.

    label:label? prefix? t_function function_name t_paren_l dummy_arg_name_list?
      t_paren_r result_option? t_newline <Function_Stmt>
  end

  rule function_subprogram
    # F90:R1215
    #
    # Constraint: An internal function must not contain an ENTRY statement. An
    # internal function must not contain an internal_subprogram_part.

    function_stmt specification_part? execution_part? internal_subprogram_part?
      end_function_stmt <E>
  end

  rule generic_name
    # F90:12.3.2.1 (not explicitly defined)

    name
  end

  rule generic_spec
    # F90:R1206

    generic_name /
    t_operator t_paren_l defined_operator t_paren_r <T> /
    t_assignment t_paren_l e_equal t_paren_r <T>
  end

  rule goto_stmt
    # F90:R836
    #
    # Constraint: The label must be the statement label of a branch target
    # statement that appears in the same scoping unit as the goto_stmt.

    label:label? t_goto label t_newline <StmtJ>
  end

  rule hex_constant
    # F90:R410

    "z" ( ( t_apostrophe hex_digit+ t_apostrophe ) / ( t_quotemark hex_digit+
      t_quotemark ) ) <T>
  end

  rule hex_digit
    # F90:R411

    [0123456789abcdef]
  end

  rule if_construct
    # F90:R802
    #
    # Note: if_then_construct, else_if_construct and else_construct added for
    # clarity, not specified in standard.

    label:label? if_then_construct else_if_construct? else_construct?
      end_if_stmt <E>
  end

  rule if_construct_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule if_construct_name_label
    if_construct_name t_colon <T>
  end

  rule if_stmt
    # F90:R807
    #
    # Constraint: The action_stmt in the if_stmt must not be an if_stmt,
    # end_program_stmt, end_function_stmt, or end_subroutine_stmt.

    label:label? t_if t_paren_l scalar_logical_expr t_paren_r action_stmt
      <If_Stmt>
  end

  rule if_then_construct
    if_then_stmt block <E>
  end

  rule if_then_stmt
    # F90:R803

    label:label? if_construct_name_label? t_if t_paren_l scalar_logical_expr
      t_paren_r t_then t_newline <If_Then_Stmt>
  end

  rule imag_part
    # F90:R419

    signed_real_literal_constant /
    signed_int_literal_constant
  end

  rule implicit_part
    # F90:R205
    #
    # Note: The standard requires that the last statement in implicit_part be
    # an implicit_stmt but, given that this seems unlikely to affect parsing,
    # and the availibility of 3rd-party syntax-checking compilers, it is not
    # enforced here.

    implicit_part_stmt+ <E>
  end

  rule implicit_part_stmt
    # F90:R206

    implicit_stmt /
    format_stmt /
    parameter_stmt /
    entry_stmt
  end

  rule implicit_spec
    # F90:R541

     type_spec_with_kind_selector t_paren_l letter_spec_list t_paren_r <T> /
     type_spec_without_kind_selector t_paren_l letter_spec_list t_paren_r <T>
  end

  rule implicit_spec_list
    implicit_spec ( t_comma implicit_spec )* <T>
  end

  rule implicit_stmt
    # F90:R540
    #
    # Constraint: If IMPLICIT NONE is specified in a scoping unit, it must
    # precede any PARAMETER statements that appear in the scoping unit and
    # there must be no other IMPLICIT statements in the scoping unit.

    label:label? t_implicit t_none t_newline <Implicit_None_Stmt> /
    label:label? t_implicit implicit_spec_list t_newline <Implicit_Stmt>
  end

  rule initialization_expr
    # F90:R730
    #
    # Constraint: An initialization_expr must be an initialization expression
    # (7.1.6.1).

    expr
  end

  rule initialization_expr_pair
    t_equal initialization_expr <T>
  end

  rule inner_shared_do_construct
    # F90:R832

    label_do_stmt do_body do_term_shared_stmt <Inner_Shared_Do_Construct>
  end

  rule input_item
    # F90:R914

    io_implied_do /
    variable
  end

  rule input_item_list
    # F90:9.4.2
    #
    # Constraint: In an input_item_list, an io_implied_do_object must be an
    # input_item.

    input_item ( t_comma input_item )* <E>
  end

  rule inquire_spec
    # F90:R924
    #
    # Constraint: An inquire_spec_list must contain one FILE= specifier or one
    # UNIT= specifier, but not both, and at most one of each of the other
    # specifiers. In the inquire by unit form of the INQUIRE statement, all of
    # the inquiry specifier variables become undefined, except for the variable
    # in the IOSTAT= specifier (if any).

    external_file_unit &t_comma <T> /
    t_unit t_equal external_file_unit <T> /
    t_file t_equal file_name_expr <T> /
    t_iostat t_equal scalar_default_int_variable <T> /
    t_err t_equal label <T> /
    t_exist t_equal scalar_default_logical_variable <T> /
    t_opened t_equal scalar_default_logical_variable <T> /
    t_number t_equal scalar_default_int_variable <T> /
    t_named t_equal scalar_default_logical_variable <T> /
    t_name t_equal scalar_default_char_variable <T> /
    t_access t_equal scalar_default_char_variable <T> /
    t_sequential t_equal scalar_default_char_variable <T> /
    t_direct t_equal scalar_default_char_variable <T> /
    t_form t_equal scalar_default_char_variable <T> /
    t_formatted t_equal scalar_default_char_variable <T> /
    t_unformatted t_equal scalar_default_char_variable <T> /
    t_recl t_equal scalar_default_int_variable <T> /
    t_nextrec t_equal scalar_default_int_variable <T> /
    t_blank t_equal scalar_default_char_variable <T> /
    t_position t_equal scalar_default_char_variable <T> /
    t_action t_equal scalar_default_char_variable <T> /
    t_read t_equal scalar_default_char_variable <T> /
    t_write t_equal scalar_default_char_variable <T> /
    t_readwrite t_equal scalar_default_char_variable <T> /
    t_delim t_equal scalar_default_char_variable <T> /
    t_pad t_equal scalar_default_char_variable <T>
  end

  rule inquire_spec_list
    inquire_spec ( t_comma inquire_spec )* <T>
  end

  rule inquire_stmt
    # F90:R923

    label:label? t_inquire t_paren_l inquire_spec_list t_paren_r t_newline
      <StmtC> /
    label:label? t_inquire t_paren_l t_iolength t_equal
      scalar_default_int_variable t_paren_r output_item_list t_newline <StmtC>
  end

  rule int_expr
    # F90:R728
    #
    # Constraint: int_expr must be type integer.

    expr
  end

  rule int_initialization_expr
    # F90:R732
    #
    # Constraint: An int_initialization_expr must be an initialization
    # expression (7.1.6.1).

    int_expr
  end

  rule int_literal_constant
    # F90:R404

    digit_string ( t_underscore kind_param )? <T>
  end

  rule int_variable
    # F90:R607
    #
    # Constraint: int_variable must be of type integer.

    variable
  end

  rule intent_spec
    # F90:R511
    #
    # Constraint: The INTENT attribute must not be specified for a dummy
    # argument that is a dummy procedure or a dummy pointer.

    t_in /
    t_out /
    t_inout
  end

  rule intent_stmt
    # F90:R519
    #
    # Constraint: An intent_stmt may appear only in the specification_part of a
    # subprogram or an interface body (12.3.2.1). dummy_arg_name must not be the
    # name of a dummy procedure or a dummy pointer.

    label:label? t_intent t_paren_l intent_spec t_paren_r double_colon?
      dummy_arg_name_list t_newline <Intent_Stmt>
  end

  rule interface_block
    # F90:R1201
    #
    # Constraint: An interface_body must not contain an entry_stmt, data_stmt,
    # format_stmt, or stmt_function_stmt. The MODULE PROCEDURE specification is
    # allowed only if the interface_block has a generic_spec and has a host that
    # is a module or accesses a module by use association; each procedure_name
    # must be the name of a module procedure that is accessible in the host. An
    # interface_block must not appear in a BLOCK DATA program unit. An
    # interface_block in a subprogram must not contain an interface_body for a
    # procedure defined by that subprogram.

    interface_stmt interface_bodies module_procedure_stmts end_interface_stmt <E>
  end

  rule interface_bodies
    interface_body* <E>
  end

  rule interface_body
    # F90:R1204

    subroutine_stmt specification_part? end_subroutine_stmt <E> /
    function_stmt specification_part? end_function_stmt <E>
  end

  rule interface_stmt
    # F90:R1202

    label:label? t_interface generic_spec? t_newline <Interface_Stmt>
  end

  rule internal_file_unit
    # F90:R903
    #
    # Constraint: The default_char_variable must not be an array section with a
    # vector subscript.

    default_char_variable
  end

  rule internal_subprogram_part
    # F90:R210

    contains_stmt internal_subprograms <E>
  end

  rule internal_subprogram
    # F90:R211

    subroutine_subprogram /
    function_subprogram /
    directive # REMOVE!
  end

  rule internal_subprograms
    internal_subprogram internal_subprogram* <E>
  end

  rule intrinsic_operator
    # F90:R310

    power_op /
    mult_op /
    add_op /
    concat_op /
    rel_op /
    not_op /
    and_op /
    or_op /
    equiv_op
  end

  rule intrinsic_procedure_name
    # F90:12.3.2.3 (not explicitly defined)

    name
  end

  rule intrinsic_procedure_name_list
    intrinsic_procedure_name ( t_comma intrinsic_procedure_name )* <T>
  end

  rule intrinsic_stmt
    # F90:R1208

    label:label? t_intrinsic intrinsic_procedure_name_list t_newline <StmtJ>
  end

  rule io_control_spec
    # F90:R912
    #
    # Constraint: An io_control_spec_list must contain exactly one io_unit and
    # may contain at most one of each of the other specifiers. An END=, EOR=, or
    # SIZE= specifier must not appear in a write_stmt. The label in the ERR=,
    # EOR=, or END= specifier must be the statement label of a branch target
    # statement that appears in the same scoping unit as the data transfer
    # statement. A namelist_group_name must not be present if an input_item_list
    # or an output_item_list is present in the data transfer statement. An
    # io_control_spec_list must not contain both a format and a
    # namelist_group_name. If the optional characters UNIT= are omitted from the
    # unit specifier, the unit specifier must be the first item in the control
    # information list. If the optional characters FMT= are omitted from the
    # format specifier, the format specifier must be the second item in the
    # control information list and the first item must be the unit specifier
    # without the optional characters UNIT=. If the optional characters NML= are
    # omitted from the namelist specifier, the namelist specifier must be the
    # second item in the control information list and the first item must be the
    # unit specifier without the optional characters UNIT=. If the unit
    # specifier specifies an internal file, the io_control_spec_list must not
    # contain a REC= specifier or a namelist_group_name. If the REC= specifier
    # is present, and END= specifier must not appear, a namelist_group_name must
    # not appear, and the format, if any, must not be an asterisk specifying
    # list-directed input/output. An ADVANCE= specifier may be present only in a
    # formatted sequential input/output statement with explicit format
    # specification (10.1) whose control information list does not contain an
    # internal file unit specifier. If an EOR= specifier is present, an ADVANCE=
    # specifier must also appear. If a SIZE= specifier is present, an ADVANCE=
    # specifier must also appear.

    io_unit t_comma format !t_equal <T> /
    io_unit t_comma namelist_group_name !t_equal <T> /
    t_advance t_equal scalar_default_char_expr <T> /
    t_end t_equal label <T> /
    t_eor t_equal label <T> /
    t_err t_equal label <T> /
    t_fmt t_equal format <T> /
    t_iostat t_equal scalar_default_int_variable <T> /
    t_nml t_equal namelist_group_name <T> /
    t_rec t_equal scalar_int_expr <T> /
    t_size t_equal scalar_default_int_variable <T> /
    t_unit t_equal io_unit <T> /
    io_unit &t_comma <T>
  end

  rule io_control_spec_list
    io_control_spec ( t_comma io_control_spec )* <T>
  end

  rule io_implied_do
    # F90:R916

    t_paren_l io_implied_do_object_list t_comma io_implied_do_control t_paren_r
      <T>
  end

  rule io_implied_do_control
    # F90:R918
    #
    # Constraint: The do_variable must be a named scalar variable of type
    # integer, default real, or double precision real. Each scalar_numeric_expr
    # in an io_implied_do_control must be of type integer, default real, or
    # double precision real.

    do_variable t_equal scalar_numeric_expr t_comma scalar_numeric_expr
      ( t_comma scalar_numeric_expr )? <T>
  end

  rule io_implied_do_object
    # F90:R917
    #
    # Constraint: A variable that is an input_item must not be an assumed-size
    # array. In an input_item_list, an io_implied_do_object must be an
    # input_item. In an output_item_list, an io_implied_do_object must be an
    # output_item.

    output_item !t_equal <T> /
    input_item !t_equal <T>
  end

  rule io_implied_do_object_list
    io_implied_do_object ( t_comma io_implied_do_object )* <T>
  end

  rule io_unit
    # F90:R901

    t_star /
    external_file_unit /
    internal_file_unit
  end

  rule keyword
    # F90:R1212
    #
    # Constraint: Each keyword must be the name of a dummy argument in the
    # explicit interface of the procedure.

    dummy_arg_name
  end

  rule keyword_option
    keyword_pair?
  end

  rule keyword_pair
    keyword t_equal <T>
  end

  rule kind_pair
    t_kind t_equal <T>
  end

  rule kind_param
    # F90:R405
    #
    # Constraint: The value of kind_param must be nonnegative. The value of
    # kind_param must specify a representation method that exists on the
    # processor.

    digit_string /
    scalar_int_constant_name
  end

  rule kind_selector
    # F90:R505
    #
    # Constraint: The value of a scalar_int_initialization_expr must be
    # nonnegative and must specify a representation method that exists on the
    # processor.

    t_paren_l kind_pair? scalar_int_initialization_expr t_paren_r <T>
  end

  rule label
    # F90:R313
    #
    # Constraint: At least one digit in a label must be nonzero. If a statement
    # is labeled, the statement must contain a nonblank character. The same
    # statement label must not be given to more than one statement in a scoping
    # unit. Leading zeros are not significant in distinguishing between
    # statement labels.

    t_digit 1..5 <T>
  end

  rule label_do_stmt
    # F90:R819

    label:label? do_construct_name_label? t_do dolabel:label loop_control?
      t_newline &{ |e| dolabel_push(e[3]) } <Label_Do_Stmt>
  end

  rule label_list
    label ( t_comma label )* <T>
  end

  rule len_pair
    t_len t_equal <T>
  end

  rule length_selector
    # F90:R507
    #
    # Constraint: The optional comma in a length_selector is permitted only in a
    # type_spec in a type_declaration_stmt. The optional comma in a
    # length_selector is permitted only if no double colon separator appears in
    # the type_declaration_stmt.

    t_paren_l len_pair? type_param_value t_paren_r <T> /
    char_length_pair &( [^\:\n]* double_colon ) <T> /
    char_length_pair t_comma <T>
  end

  rule letter_spec
    # F90:R542
    #
    # Constraint: If the minus and the second letter appear, the second letter
    # must follow the first letter alphabetically.

    t_letter ( t_minus t_letter )? <T>
  end

  rule letter_spec_list
    letter_spec ( t_comma letter_spec )* <T>
  end

  rule level_1_expr
    # F90:R703

    defined_unary_op? primary <T>
  end

  rule level_2_expr
    # F90:R707
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_2_expr? add_op )? add_operand

    add_op? add_operand level_2_expr? <T>
  end

  rule level_3_expr
    # F90:R711
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr concat_op )? level_2_expr

    level_2_expr level_3_expr_option? <T>
  end

  rule level_3_expr_option
    concat_op level_3_expr <T>
  end

  rule level_4_expr
    # F90:R713
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr rel_op )? level_3_expr

    level_3_expr level_4_expr_option? <T>
  end

  rule level_4_expr_option
    rel_op level_3_expr <T>
  end

  rule level_5_expr
    # F90:R718
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_5_expr equiv_op)? equiv_operand

    equiv_operand level_5_expr_option? <T>
  end

  rule level_5_expr_option
    equiv_op level_5_expr <T>
  end

  rule literal_constant
    # F90:R306
    #
    # Note: The choice order is different than that given in the standard, e.g.
    # an int_literal_constant should only be matched after failure to match a
    # real_literal_constant. Also, signed versions of real_literal_constant and
    # int_literal_constant are used here, though the standard (seemingly
    # incorrectly) specifies the unsigned versions.

    complex_literal_constant /
    signed_real_literal_constant /
    signed_int_literal_constant /
    logical_literal_constant /
    char_literal_constant /
    boz_literal_constant
  end

  rule local_name
    # F90:11.3.2 (not explicitly defined)

    name
  end
    
  rule logical_expr
    # F90:R725
    #
    # Constraint: logical_expr must be type logical.

    expr
  end

  rule logical_initialization_expr
    # F90:R733
    #
    # Constraint: A logical_initialization_expr must be an initialization
    # expression (7.1.6.1).

    logical_expr
  end

  rule logical_literal_constant
    # F90:R421
    #
    # Constraint: The value of kind_param must specify a representation that
    # exists on the processor.

    ( t_true / t_false ) ( t_underscore kind_param )? <T>
  end

  rule logical_variable
    # F90:R603
    #
    # Constraint: logical_variable must be of type logical.

    variable
  end

  rule loop_control
    # F90:R821
    #
    # Constraint: Each scalar_numeric_expr in loop_control must be of type
    # integer, default real, or double precision real.

    t_comma? do_variable t_equal scalar_numeric_expr loop_control_pair
      loop_control_pair? <Loop_Control_1> /
    t_comma? t_while t_paren_l scalar_logical_expr t_paren_r <Loop_Control_2>
  end

  rule loop_control_pair
    t_comma scalar_numeric_expr <T>
  end

  rule lower_bound
    # F90:R514

    specification_expr
  end

  rule lower_bound_pair
    lower_bound t_colon <T>
  end

  rule main_program
    # F90:R1101
    #
    # Constraint: In a main_program, the execution_part must not contain a
    # F90:RETURN statement or an ENTRY statement.

    program_stmt? specification_part? execution_part? internal_subprogram_part?
      end_program_stmt <E>
  end

  rule mask_expr
    # F90:R741

    logical_expr
  end

  rule module
    # F90:R1104
    #
    # Constraint: A module specification_part must not contain a
    # stmt_function_stmt, an entry_stmt, or a format_stmt. An automatic object
    # must not appear in the specification_part (R204) of a module.

    module_stmt specification_part? module_subprogram_part? end_module_stmt <E>
  end

  rule module_name
    # F90:11.3 (not explicitly defined)

    name
  end

  rule module_procedure_stmt
    # F90:R1205

    label:label? t_module t_procedure procedure_name_list t_newline <StmtJ>
  end

  rule module_procedure_stmts
    module_procedure_stmt* <E>
  end

  rule module_subprogram
    # F90:R213

    subroutine_subprogram /
    function_subprogram /
    directive # REMOVE!
  end

  rule module_subprogram_part
    # F90:R212

    contains_stmt module_subprogram+ <Module_Subprogram_Part>
  end

  rule module_stmt
    # F90:R1105

    label:label? t_module module_name t_newline <Module_Stmt>
  end

  rule mult_op
    # F90:R709

    t_star /
    t_slash
  end

  rule mult_operand
    # F90:R705

    level_1_expr ( power_op mult_operand )? <T>
  end

  rule name
    # F90:R304
    #
    # Constraint: The maximum length of a name is 31 characters.

    t_letter alphanumeric_character* <T>
  end

  rule named_constant
    # F90:R307

    name
  end

  rule named_constant_def
    # F90:R539

    named_constant t_equal initialization_expr <E>
  end

  rule named_constant_def_list
    named_constant_def ( t_comma named_constant_def )* <T>
  end

  rule namelist_group_name
    # Multiple uses (not explicitly defined)
    #
    # Constraint: If a namelist_group_name has the PUBLIC attribute, no item in
    # the namelist_group_object_list may have the PRIVATE attribute.

    name
  end

  rule namelist_group_object
    # F90:R544
    #
    # Constraint: A namelist_group_object must not be an array dummy argument
    # with a nonconstant bound, a variable with nonconstant character length, an
    # automatic object, a pointer, a variable of a type that has an ultimate
    # component that is a pointer, or an allocatable array.

    variable_name
  end

  rule namelist_group_object_list
    namelist_group_object ( t_comma namelist_group_object )* <T>
  end

  rule namelist_group_set
    t_slash namelist_group_name t_slash namelist_group_object_list <T>
  end

  rule namelist_group_set_pair
    t_comma? namelist_group_set <Namelist_Group_Set_Pair>
  end

  rule namelist_group_sets
    namelist_group_set_pair* <E>
  end

  rule namelist_stmt
    # F90:R543

    label:label? t_namelist namelist_group_set namelist_group_sets t_newline
      <Namelist_Stmt>
  end

  rule nonblock_do_construct
    # F90:R826

    outer_shared_do_construct /
    action_term_do_construct
  end

  rule nonlabel_do_stmt
    # F90:R820

    label:label? do_construct_name_label? t_do loop_control? t_newline
      &{ |e| dolabel_push(:nolabel) } <Nonlabel_Do_Stmt>
  end

  rule not_op
    # F90:R719

    ".not." <T>
  end

  rule nullify_stmt
    # F90:R629
    #
    # Constraint: Each pointer_object must have the POINTER attribute.

    label:label? t_nullify t_paren_l pointer_object_list t_paren_r t_newline
      <StmtC>
  end

  rule numeric_expr
    # F90:R729
    #
    # Constraint: numeric_expr must be of type integer, real or complex.

    expr
  end

  rule object_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule object_name_and_spec_list
    object_name parenthesized_deferred_shape_spec_list? <E>
  end

  rule object_name_and_spec_list_pair
    t_comma object_name_and_spec_list <E>
  end

  rule object_names_and_spec_lists
    object_name_and_spec_list object_name_and_spec_list_pair* <T>
  end

  rule octal_constant
    # F90:R409
    #
    # Constraint: digit must have one of the values 0 through 7. Note: 'digit is
    # replaced by 't_octal' here to enforce the constraint.

    "o" ( ( t_apostrophe t_octal+ t_apostrophe ) /
      ( t_quotemark t_octal+ t_quotemark ) ) <T>
  end

  rule only
    # F90:R1109
    #
    # Constraint: Each access_id must be a public entity in the module. Each
    # use_name must be the name of a public entity in the module.

    ( local_name t_point )? use_name <E> /
    access_id
  end

  rule only_list
    only ( t_comma only )* <T>
  end

  rule open_stmt
    # F90:R904

    label:label? t_open t_paren_l connect_spec_list t_paren_r t_newline <StmtC>
  end

  rule optional_stmt
    # F90:R520
    #
    # Constraint: An optional_stmt may occur only in the scoping unit of a
    # subprogram of an interface body.

    label:label? t_optional double_colon? dummy_arg_name_list t_newline
      <Optional_Stmt>
  end

  rule or_op
    # F90:R721

    ".or." <T>
  end

  rule outer_shared_do_construct
    # F90:R830

    label_do_stmt !{ |e| dolabel_dupe? } do_body shared_term_do_construct <E>
  end

  rule output_item
    # F90:R915

    io_implied_do /
    expr
  end

  rule output_item_list
    # F90:9.4.2
    #
    # Constraint: In an output_item_list, an io_implied_do_object must be an
    # output_item.

    output_item ( t_comma output_item )* <E>
  end

  rule parameter_stmt
    # F90:R538

    label:label? t_parameter t_paren_l named_constant_def_list t_paren_r
      t_newline <StmtC>
  end

  rule parent_string
    # F90:R610
    #
    # Constraint: parent_string must be of type character.

    array_element /
    scalar_structure_component /
    scalar_variable_name /
    scalar_constant
  end

  rule parenthesized_allocate_shape_spec_list
    t_paren_l allocate_shape_spec_list t_paren_r <T>
  end

  rule parenthesized_args
    t_paren_l actual_arg_spec_list? t_paren_r <T>
  end

  rule parenthesized_component_array_spec
    t_paren_l component_array_spec t_paren_r <T>
  end

  rule parenthesized_deferred_shape_spec_list
    t_paren_l deferred_shape_spec_list t_paren_r <T>
  end

  rule parenthesized_explicit_shape_spec_list
    t_paren_l explicit_shape_spec_list t_paren_r <T>
  end

  rule parenthesized_expr
    t_paren_l expr t_paren_r <T>
  end

  rule parenthesized_section_subscript_list
    t_paren_l section_subscript_list t_paren_r <T>
  end

  rule part_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule part_ref
    # F90:R613
    #
    # Constraint: In a part_ref containing a section_subscript_list, the number
    # of section_subscripts must equal the rank of part_name.

    part_name parenthesized_section_subscript_list? <T>
  end

  rule pause_stmt
    # F90:R844

    label:label? t_pause stop_code? t_newline <StmtJ>
  end

  rule pointer_assignment_stmt
    # F90:R736
    #
    # Constraint: The pointer_object must have the POINTER attirbute. The
    # target must be of the same type, type parameters, and rank as the
    # pointer.

    label:label? pointer_object t_point target t_newline <StmtC>
  end

  rule pointer_object
    # F90:R630

    structure_component /
    variable_name
  end

  rule pointer_object_list
    pointer_object ( t_comma pointer_object )* <T>
  end

  rule pointer_stmt
    # F90:R527
    #
    # Constraint: The INTENT attribute must not be specified for an object_name.
    # If the DIMENSION attribute ofr an object_name is specified elsewhere in
    # the scoping unit, the array_spec must be a deferred_shape_spec_list.

    label:label? t_pointer double_colon? object_names_and_spec_lists t_newline
      <Pointer_Stmt>
  end

  rule position_spec
    # F90:R922
    #
    # Constraint: The label in the ERR= specifier must be the statement label
    # of a branch target statement that appears in the same scoping unit as the
    # file positioning statement. If the optional characters UNIT= are omitted
    # from the unit specifier, the unit specifier must be the first item in the
    # position_spec_list. A position_spec_list must contain exactly one
    # external_file_unit and may contain at most one of each of the other
    # specifiers.

    external_file_unit &t_comma <T> /
    t_unit t_equal external_file_unit <T> /
    t_iostat t_equal scalar_default_int_variable <T> /
    t_err t_equal label
  end

  rule position_spec_list
    position_spec ( t_comma position_spec )* <T>
  end

  rule power_op
    # F90:R708

    "**" <T>
  end

  rule prefix
    # F90:R1217

    type_spec t_recursive? <J> /
    t_recursive type_spec? <J>
  end

  rule primary
    # F90:R701
    #
    # Constraint: subobject must be a subobject whose parent is a constant. A
    # variable that is a primary must not be an assumed-size array.

    function_reference /
    variable /
    constant /
    constant_subobject /
    array_constructor /
    structure_constructor /
    parenthesized_expr
  end

  rule print_stmt
    # F90:R911

    label:label? t_print format print_stmt_output_item_list? t_newline
      <Print_Stmt>
  end

  rule print_stmt_output_item_list
    t_comma output_item_list <T>
  end

  rule private_sequence_stmt
    # F90:R423
    #
    # Constraint: The same private_sequence_stmt must not appear more than once
    # in a given derived_type_def. If SEQUENCE is present, all derived types
    # specified in component definitions must be sequence types.

    label:label? ( t_private / t_sequence ) t_newline <StmtC>
  end

  rule private_sequence_stmts
    private_sequence_stmt* <E>
  end

  rule procedure_name
    # F90:12.4.1

    name
  end

  rule procedure_name_list
    procedure_name ( t_comma procedure_name )* <T>
  end
  
  rule program_name
    # F90:11.1

    name
  end

  rule program_stmt
    # F90:R1102

    label:label? t_program name:program_name t_newline <Program_Stmt>
  end

  rule program_unit
    # F90:R202

    main_program /
    external_subprogram /
    module /
    block_data
  end

  rule read_stmt
    # F90:R909

    label:label? t_read t_paren_l io_control_spec_list t_paren_r
      input_item_list? t_newline <Read_Stmt_1> /
    label:label? t_read format read_stmt_input_item_list_option? t_newline
      <Read_Stmt_2>
  end

  rule read_stmt_input_item_list_option
    t_comma input_item_list <T>
  end

  rule real_literal_constant
    # F90:R413
    #
    # Constraint: If both kind_param and exponent_letter are present,
    # exponent_letter bust be E. The value of kind_param must specify an
    # approximation method that exists on the processor.

    significand ( exponent_letter exponent )? ( t_underscore kind_param )?
      <T> /
    digit_string exponent_letter exponent ( t_underscore kind_param )?
      <T>
  end

  rule real_part
    # F90:R418

    signed_real_literal_constant /
    signed_int_literal_constant
  end

  rule rel_op_eq
    ".eq." <T> /
    "==" <T>
  end

  rule rel_op_ge
    ".ge." <T> /
    ">=" <T>
  end

  rule rel_op_gt
    ".gt." <T> /
    ">" <T>
  end

  rule rel_op_le
    ".le." <T> /
    "<=" <T>
  end

  rule rel_op_lt
    ".lt." <T> /
    "<" <T>
  end

  rule rel_op_ne
    ".ne." <T> /
    "/=" <T>
  end

  rule rel_op
    # F90:R714

    rel_op_eq /
    rel_op_ne /
    rel_op_le /
    rel_op_lt /
    rel_op_ge /
    rel_op_gt
  end

  rule rename
    # F90:R1108

    local_name t_point use_name <E>
  end

  rule rename_list
    rename ( t_comma rename )* <E>
  end

  rule rename_list_option
    t_comma rename_list <T>
  end

  rule rep_char
    # F90:4.3.2.1 (processor-dependent)
    #
    # Constraint: For the type character with kind kind_param, and for type
    # default character otherwise, a representable character, rep_char, is:
    # (1) Any character in the processor-dependent character set in fixed source
    # form. A processor may restrict the occurrence of some of all of the
    # control characters. (2) Any graphic character in the processor-dependent
    # character set in free source form.

    character /
    [\[\]\~\`\@\#\^\|\{\}]
  end

  rule result_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule result_option
    t_result t_paren_l result_name t_paren_r <T>
  end

  rule return_stmt
    # F90:R1224
    #
    # Constraint: The return_stmt must be contained in the scoping unit of a
    # function or subroutine subprogram. The scalar_int_expr is allowed only
    # in the scoping unit of a subroutine subprogram.

    label:label? t_return scalar_int_expr? t_newline <J>
  end

  rule rewind_stmt
    # F90:R921

    label:label? t_rewind t_paren_l position_spec_list t_paren_r t_newline
      <StmtC> /
    label:label? t_rewind external_file_unit t_newline <StmtJ>
  end

  rule save_stmt
    # F90:R523
    #
    # Constraint: If a SAVE statement with an omitted saved entity list occurs
    # in a scoping unit, no other explicit occurrence of the SAVE attribute or
    # SAVE statement is permitted in the same scoping unit.

    label:label? t_save save_stmt_entity_list? t_newline <Save_Stmt>
  end

  rule save_stmt_entity_list
    double_colon? saved_entity_list <Save_Stmt_Entity_List>
  end

  rule saved_entity
    # F90:R524
    #
    # Constraint: An object_name must not be a dummy argument name, a procedure
    # name, a function result name, an automatic data object name, or the name
    # of an entity in a common block.

    object_name /
    t_slash common_block_name t_slash <E>
  end

  rule saved_entity_list
    saved_entity ( t_comma saved_entity )* <T>
  end

  rule scalar_char_constant
    # F90:8.4 (not explicitly defined)
    #
    # Note: Assumed constraint: named_constant must be of type default
    # character.

    char_literal_constant /
    named_constant
  end

  rule scalar_char_expr
    # F90:8.1.3.1
    #
    # Note: Assumed constraint: char_expr is scalar.

    char_expr  
  end

  rule scalar_char_initialization_expr
    # F90:8.1.3.1 (not explicitly defined)
    #
    # Note: Assumed constraint: initialization_expr is scalar and is of type
    # character.

    initialization_expr
  end

  rule scalar_constant
    # Multiple uses (not explicitly defined)
    #
    # Note: Unclear what this is supposed to be... Assumed constraint: Any
    # named_constant must be scalar.

    literal_constant /
    named_constant
  end

  rule scalar_default_char_expr
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: default_char_expr is scalar.

    default_char_expr
  end

  rule scalar_default_char_variable
    # F90:9.6.1 (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_default_char_variable must be scalar.

    default_char_variable
  end

  rule scalar_default_int_variable
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_default_int_variable must be scalar,
    # and must be of type default integer.    

    variable
  end

  rule scalar_default_logical_variable
    # F90:9.6.1 (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_default_logical_variable must be of type
    # default logical.

    default_logical_variable
  end

  rule scalar_expr
    # F90:12.5.4 (not explicitly defined)

    expr
  end

  rule scalar_int_constant
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: must be scalar and, if a variable name, must be
    # of type integer and must have the PARAMETER attribute.

    scalar_int_literal_constant /
    scalar_int_constant_name
  end

  rule scalar_int_constant_name
    # F90:4.3.1.1 (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_int_constant_name must be scalar, and
    # must be of type integer.

    named_constant
  end

  rule scalar_int_expr
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: must refer to a scalar entity of type integer.

    expr
  end
    
  rule scalar_int_initialization_expr
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: initialization_expr is scalar and is of type
    # integer.

    initialization_expr
  end

  rule scalar_int_literal_constant
    # F90:5.1.1.5 (not explicitly defined)
    #
    # Note: Assumed constraint: must be scalar of type integer.

    signed_int_literal_constant
  end

  rule scalar_int_variable
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_int_variable must be scalar, and must
    # be of type integer.    

    variable
  end

  rule scalar_logical_expr
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: logical_expr must be scalar.

    logical_expr
  end

  rule scalar_logical_initialization_expr
    # F90:8.1.3.1 (not explicitly defined)
    #
    # Note: Assumed constraint: initialization_expr is scalar and is of type
    # logical.

    initialization_expr
  end

  rule scalar_numeric_expr
    # Multiple users (not explicitly defined)
    #
    # Note: Assumed constraint: numeric_expr must be scalar.

    numeric_expr
  end

  rule scalar_structure_component
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: The structure_component must be scalar.

    structure_component
  end

  rule scalar_variable
    # F90:8.1.4.1.1 (not explicitly defiend)
    #
    # Note: Unclear what is needed here, making assumption...

    scalar_variable_name
  end

  rule scalar_variable_name
    # Section 6 (not explicitly defined)
    #
    # Note: Assumed constraint: scalar_variable_name must be scalar.

    variable_name
  end

  rule section_subscript
    # F90:R618

    subscript_triplet /
    vector_subscript /
    subscript
  end

  rule section_subscript_list
    section_subscript ( t_comma section_subscript )* <E>
  end

  rule select_case_stmt
    # F90:R809

    label:label? case_construct_name_pair? t_select t_case t_paren_l case_expr
      t_paren_r t_newline <Select_Case_Stmt>
  end

  rule shared_term_do_construct
    # F90:R831

    outer_shared_do_construct /
    inner_shared_do_construct
  end

  rule sign
    # F90:R406

    t_plus /
    t_minus
  end

  rule signed_digit_string
    # F90:R401

    sign? digit_string <T>
  end

  rule signed_int_literal_constant
    # F90:R403

    sign? int_literal_constant <T>
  end

  rule signed_real_literal_constant
    # F90:R412

    sign? real_literal_constant <T>
  end

  rule significand
    # F90:R414

    digit_string t_dot !significand_disallowed digit_string? <T> /
    t_dot digit_string <T>
  end

  rule significand_disallowed
    # Note: The use of this rule as a negative lookahead assertion in rule
    # significand allows parsing of an if_then_stmt like:
    #
    #  if (a>0.and.b>1) then
    #
    # Without the negative lookahead assertion, '0.' would be recognized as a
    # real_literal_constant and consumed, and the parse would fail.

    "and." /
    "or."
  end

## SMS ##

#  rule sms_barrier
#    sms_sentinel "barrier" t_newline <T>
#  end
#
#  rule sms_t_begin
#    "begin" <T>
#  end
#
#  rule sms_t_end
#    "end" <T>
#  end
#
#  rule sms_t_compare_var
#    "compare_var" <T>
#  end
#
#  rule sms_t_create_decomp
#    "create_decomp" <T>
#  end
#
#  rule sms_t_distribute
#    "distribute" <T>
#  end
#
#  rule sms_t_exchange
#    "exchange" <T>
#  end
#
#  rule sms_t_halo_comp
#    "halo_comp" <T>
#  end
#
#  rule sms_t_ignore
#    "ignore" <T>
#  end
#
#  rule sms_t_parallel
#    "parallel" <T>
#  end
#
#  rule sms_t_reduce
#    "reduce" <T>
#  end
#
#  rule sms_t_serial
#    "serial" <T>
#  end
#
#  rule sms_t_set_communicator
#    "set_communicator" <T>
#  end
#
#  rule sms_t_to_local
#    "to_local" <T>
#  end
#
#  rule sms_t_unstructured_grid
#    "unstructured_grid" <T>
#  end
#
#  rule sms_junk
#    # GET RID OF THIS!
#    t_paren_l (!t_paren_r character)* t_paren_r <T>
#  end
#
#  rule sms_compare_var
#    sms_sentinel sms_t_compare_var character* t_newline <T>
#  end
#
#  rule sms_create_decomp
#    sms_sentinel sms_t_create_decomp character* t_newline <T>
#  end
#
#  rule sms_distribute_begin
#    sms_sentinel sms_t_distribute sms_junk sms_t_begin t_newline <SMS_Distribute_Begin>
#  end
#
#  rule sms_distribute_end
#    sms_sentinel sms_t_distribute sms_t_end t_newline <SMS_Distribute_End>
#  end
#
#  rule sms_exchange
#    sms_sentinel sms_t_exchange character* t_newline <T>
#  end
#
#  rule sms_halo_comp_begin
#    sms_sentinel sms_t_halo_comp sms_junk sms_t_begin t_newline <SMS_Halo_Comp_Begin>
#  end
#
#  rule sms_halo_comp_end
#    sms_sentinel sms_t_halo_comp sms_t_end t_newline <SMS_Halo_Comp_End>
#  end
#
#  rule sms_ignore_begin
#    sms_sentinel sms_t_ignore sms_junk sms_t_begin t_newline <SMS_Ignore_Begin>
#  end
#
#  rule sms_ignore_end
#    sms_sentinel sms_t_ignore sms_t_end t_newline <SMS_Ignore_End>
#  end
#
#  rule sms_parallel_begin
#    sms_sentinel sms_t_parallel sms_junk sms_t_begin t_newline <SMS_Parallel_Begin>
#  end
#
#  rule sms_parallel_end
#    sms_sentinel sms_t_parallel sms_t_end t_newline <SMS_Parallel_End>
#  end
#
#  rule sms_reduce
#    sms_sentinel sms_t_reduce sms_junk t_newline <T>
#  end
#
#  rule sms_serial_begin
#    sms_sentinel sms_t_serial sms_junk sms_t_begin t_newline <SMS_Serial_Begin>
#  end
#
#  rule sms_serial_end
#    sms_sentinel sms_t_serial sms_t_end t_newline <SMS_Serial_End>
#  end
#
#  rule sms_set_communicator
#    sms_sentinel sms_t_set_communicator sms_junk t_newline <T>
#  end
#
#  rule sms_to_local_begin
#    sms_sentinel sms_t_to_local sms_junk sms_t_begin t_newline <SMS_To_Local_Begin>
#  end
# 
#  rule sms_to_local_end
#    sms_sentinel sms_t_to_local sms_t_end t_newline <SMS_To_Local_End>
#  end
#
#  rule sms_unstructured_grid
#    sms_sentinel sms_t_unstructured_grid sms_junk t_newline <T>
#  end
#
#  rule sms_string
#    char_literal_constant_dq /
#    char_literal_constant_sq
#  end
#
#  rule sms_sentinel
#    "!sms$" <T>
#  end
#
#  rule sms_declarative
#    # Note: Eventually, we do not want the 'ignore' directive in
#    # specification_part, if at all.
#
#    sms_create_decomp /
#    sms_distribute_begin /
#    sms_distribute_end /
#    sms_ignore_begin /
#    sms_ignore_end
#  end
#
#  rule sms_executable
#    sms_barrier /
#    sms_compare_var /
#    sms_halo_comp_begin /
#    sms_halo_comp_end /
#    sms_ignore_begin /
#    sms_ignore_end /
#    sms_parallel_begin /
#    sms_parallel_end /
#    sms_reduce /
#    sms_serial_begin /
#    sms_serial_end /
#    sms_set_communicator /
#    sms_to_local_begin /
#    sms_to_local_end /
#    sms_unstructured_grid
#  end

## SMS ##

  rule special_character
    # F90:3.1.4

    [\ \=\+\-\*\/\(\)\,\.\'\:\!\"\%\&\;\<\>\?\$]
  end

  rule specification_expr
    # F90:R734
    #
    # Constraint: The scalar_int_expr must be a restricted expression (7.1.6.2).

    scalar_int_expr
  end

  rule specification_part
    # F90:R204

    use_part implicit_part? declaration_constructs <E>
  end

  rule specification_stmt
    # F90:R214

    access_stmt /
    allocatable_stmt /
    common_stmt /
    data_stmt /
    dimension_stmt /
    equivalence_stmt /
    external_stmt /
    intent_stmt /
    intrinsic_stmt /
    namelist_stmt /
    optional_stmt /
    pointer_stmt /
    save_stmt /
    target_stmt
  end

  rule star_int
    t_star int_literal_constant <T>
  end

  rule stat_variable
    # F90:R623

    scalar_int_variable
  end

  rule stmt_function_stmt
    # F90:R1226
    #
    # Constraint: The scalar_expr may be composed only of constants (literal and
    # named), references to variables, references to functions and function
    # dummy procedures, and intrinsic operations. If scalar_expr contains a
    # reference to a function or a function dummy procedure, the reference must
    # not require an explicit interface, the function must not require an
    # explicit interface or be a transformational intrinsic, and the result must
    # be scalar. If an argument to a function or a function dummy procedure is
    # array valued, it must be an array name. If a reference to a statement
    # function appears in scalar_expr, its definition must have been provided
    # earlier in the scoping unit and must not be the name of the statement
    # function being defined. Named constants in scalar_expr must have been
    # declared earlier in the scoping unit or made accessible by use or host
    # association. If array elements appear in scalar_expr, the parent array
    # must have been declared as an array earlier in the scoping unit or made
    # accessible by use or host association. If a dummy_arg_name, variable,
    # function reference, or dummy function reference is typed by the implicit
    # typing rules, its appearance in any subsequent type declaration must
    # confirm this implied type and the values of any implied type parameters.
    # The function_name and each dummy_arg_name must be specified, explicitly or
    # implicitly, to be scalar data objects. A given dummy_arg_name may appear
    # only once in any dummy_arg_name_list. Each variable reference in
    # scalar_expr may be either a reference to a dummy argument of the statement
    # function or a reference to a variable accessible in the same scoping unit
    # as the statement function statement.

    label:label? function_name t_paren_l dummy_arg_name_list? t_paren_r t_equal
      scalar_expr t_newline <StmtC>
  end

  rule stop_code
    # F90:R843
    #
    # Constraint: scalar_char_constant must be of type default character.

    scalar_char_constant /
    t_digit 1..5 <T>
  end

  rule stop_stmt
    # F90:R842

    label:label? t_stop stop_code? t_newline <StmtJ>
  end

  rule stride
    # F90:R620

    scalar_int_expr
  end

  rule structure_component
    # F90:R614
    #
    # Constraint: In a structure_component, there must be more than one part_ref
    # and the rightmost part_ref must be of the form part_name.

    data_ref
  end

  rule structure_constructor
    # F90:R430

    type_name t_paren_l expr_list t_paren_r <E>
  end

  rule subroutine_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule subroutine_stmt
    # F90:R1220

    label:label? t_recursive? t_subroutine subroutine_name
      dummy_arg_list_option? t_newline <Subroutine_Stmt>
  end

  rule subroutine_subprogram
    # F90:R1219
    #
    # Constraint: An internal subroutine must not contain an ENTRY statement. An
    # internal subroutine must not contain an internal_subprogram_part.

    subroutine_stmt specification_part? execution_part?
      internal_subprogram_part? end_subroutine_stmt <E>
  end

  rule subscript
    # F90:R617

    scalar_int_expr
  end

  rule subscript_triplet
    # F90:R619
    #
    # Constraint: The second subscript must not be omitted from a
    # subscript_triplet in the last dimension of an assumed-size array.

    subscript? t_colon subscript? ( t_colon stride )? <T>
  end

  rule subobject
    # F90:R602

    array_section /
    array_element /
    structure_component /
    substring
  end

  rule substring
    # F90:R609

    parent_string t_paren_l substring_range t_paren_r <T>
  end

  rule substring_range
    # F90:R611

    scalar_int_expr? t_colon scalar_int_expr? <T>
  end

  rule substring_range_triplet
    t_paren_l substring_range t_paren_r <E>
  end

  rule t_access
    "access" <T>
  end

  rule t_action
    "action" <T>
  end

  rule t_advance
    "advance" <T>
  end

  rule t_allocatable
    "allocatable" <T>
  end

  rule t_allocate
    "allocate" <T>
  end

  rule t_apostrophe
    "'" <T>
  end

  rule t_assign
    "assign" !"ment" <T>
  end

  rule t_assignment
    "assignment" <T>
  end
   
  rule t_backspace
    "backspace" <T>
  end

  rule t_binary
    [01] <T>
  end

  rule t_blank
    "blank" <T>
  end

  rule t_block
    "block" <T>
  end

  rule t_call
    "call" <T>
  end

  rule t_case
    "case" <T>
  end

  rule t_character
    "character" <T>
  end

  rule t_close
    "close" <T>
  end

  rule t_colon
    ":" <T>
  end

  rule t_comma
    "," <T>
  end

  rule t_common
    "common" <T>
  end

  rule t_contains
    "contains" <T>
  end

  rule t_complex
    "complex" <T>
  end

  rule t_continue
    "continue" <T>
  end

  rule t_cycle
    "cycle" <T>
  end

  rule t_data
    "data" <T>
  end

  rule t_deallocate
    "deallocate" <T>
  end

  rule t_default
    "default" <T>
  end

  rule t_delim
    "delim" <T>
  end

  rule t_digit
    [0-9] <T>
  end

  rule t_dimension
    "dimension" <T>
  end

  rule t_direct
    "direct" <T>
  end

  rule t_do
    "do" <T>
  end

  rule t_dot
    "." <T>
  end

  rule t_doubleprecision
    "doubleprecision" <T>
  end

  rule t_else
    "else" !( "if" / "where" ) <T>
  end

  rule t_elseif
    "elseif" <T>
  end

  rule t_elsewhere
    "elsewhere" <T>
  end

  rule t_end
    "end" !t_end_disallowed <T>
  end

  rule t_end_disallowed
    # Note: Used as a negative lookahead assertion, prevents t_end from matching
    # 'endfile', 'enddo', etc. Also prevents t_end from matching an assignment
    # statement like 'endxyz=1'.

    "file" /
    "do" /
    "if" /
    "where" /
    alphanumeric_character* t_equal
  end

  rule t_enddo
    "enddo" <T>
  end

  rule t_endfile
    "endfile" <T>
  end

  rule t_endif
    "endif" <T>
  end

  rule t_endwhere
    "endwhere" <T>
  end

  rule t_entry
    "entry" <T>
  end

  rule t_eor
    "eor" <T>
  end

  rule t_equal
    "=" <T>
  end

  rule t_equivalence
    "equivalence" <T>
  end

  rule t_err
    "err" <T>
  end

  rule t_exist
    "exist" <T>
  end

  rule t_exit
    "exit" <T>
  end

  rule t_external
    "external" <T>
  end

  rule t_false
    ".false." <T>
  end

  rule t_file
    "file" <T>
  end

  rule t_fmt
    "fmt" <T>
  end

  rule t_form
    "form" !"at" <T>
  end

  rule t_format
    "format" !"ted" <T>
  end

  rule t_formatted
    "formatted" <T>
  end

  rule t_function
    "function" <T>
  end

  rule t_goto
    "goto" <T>
  end

  rule t_if
    "if" <T>
  end

  rule t_implicit
    "implicit" <T>
  end

  rule t_in
    "in" !( "out" / "quire" / "teger" / "tent" / "trinsic" ) <T>
  end

  rule t_inout
    "inout" <T>
  end

  rule t_inquire
    "inquire" <T>
  end

  rule t_integer
    "integer" <T>
  end

  rule t_intent
    "intent" <T>
  end

  rule t_interface
    "interface" <T>
  end

  rule t_intrinsic
    "intrinsic" <T>
  end

  rule t_iolength
    "iolength" <T>
  end

  rule t_iostat
    "iostat" <T>
  end

  rule t_kind
    "kind" <T>
  end

  rule t_len
    "len" <T>
  end

  rule t_letter
    [a-zA-Z] <T>
  end

  rule t_logical
    "logical" <T>
  end

  rule t_minus
    "-" <T>
  end

  rule t_module
    "module" <T>
  end

  rule t_name
    "name" !( "d" / "list" ) <T>
  end

  rule t_named
    "named" <T>
  end

  rule t_namelist
    "namelist" <T>
  end

  rule t_newline
    "\n" <T>
  end

  rule t_nextrec
    "nextrec" <T>
  end

  rule t_nml
    "nml" <T>
  end

  rule t_none
    "none" <T>
  end

  rule t_nullify
    "nullify" <T>
  end

  rule t_number
    "number" <T>
  end

  rule t_octal
    [01234567] <T>
  end

  rule t_only
    "only" <T>
  end

  rule t_open
    "open" !"ed" <T>
  end

  rule t_opened
    "opened" <T>
  end

  rule t_operator
    "operator" <T>
  end

  rule t_optional
    "optional" <T>
  end

  rule t_out
    "out" <T>
  end

  rule t_pad
    "pad" <T>
  end

  rule t_parameter
    "parameter" <T>
  end

  rule t_paren_l
    "(" <T>
  end

  rule t_paren_r
    ")" <T>
  end

  rule t_pause
    "pause" <T>
  end

  rule t_percent
    "%" <T>
  end

  rule t_plus
    "+" <T>
  end

  rule t_point
    "=>" <T>
  end

  rule t_pointer
    "pointer" <T>
  end

  rule t_position
    "position" <T>
  end

  rule t_print
    "print" <T>
  end

  rule t_private
    "private" <T>
  end

  rule t_procedure
    "procedure" <T>
  end

  rule t_program
    "program" <T>
  end

  rule t_public
    "public" <T>
  end

  rule t_quotemark
    "\"" <T>
  end

  rule t_read
    "read" !"write" <T>
  end

  rule t_readwrite
    "readwrite" <T>
  end

  rule t_real
    "real" <T>
  end

  rule t_rec
    "rec" !"l" <T>
  end

  rule t_recl
    "recl" <T>
  end

  rule t_recursive
    "recursive" <T>
  end

  rule t_result
    "result" <T>
  end

  rule t_return
    "return" <T>
  end

  rule t_rewind
    "rewind" <T>
  end

  rule t_save
    "save" <T>
  end

  rule t_select
    "select" <T>
  end

  rule t_sequence
    "sequence" <T>
  end

  rule t_sequential
    "sequential" <T>
  end

  rule t_size
    "size" <T>
  end

  rule t_slash
    "/" <T>
  end

  rule t_star
    "*" <T>
  end

  rule t_stat
    "stat" !"us" <T>
  end

  rule t_status
    "status" <T>
  end

  rule t_stop
    "stop" <T>
  end

  rule t_subroutine
    "subroutine" <T>
  end

  rule t_target
    "target" <T>
  end

  rule t_then
    "then" <T>
  end

  rule t_to
    "to" <T>
  end

  rule t_true
    ".true." <T>
  end

  rule t_type
    "type" <T>
  end

  rule t_underscore
    # F90:R303
    "_"
  end

  rule t_unformatted
    "unformatted" <T>
  end

  rule t_unit
    "unit" <T>
  end

  rule t_use
    "use" <T>
  end

  rule t_where
    "where" <T>
  end

  rule t_while
    "while" <T>
  end

  rule t_write
    "write" <T>
  end

  rule target
    # F90:R737
    #
    # Constraint: The variable must have the TARGET attribute or be a subobject
    # of an object with the TARGET attribute, or it must have the pointer
    # attribute. The target must not be an array section with a vector
    # subscript. The expr must deliver a pointer result.

    variable /
    expr
  end

  rule target_stmt
    # F90:R528
    #
    # Constraint: The PARAMETER attribute must not be specified for an
    # object_name.

    label:label? t_target double_colon? array_names_and_specs t_newline
      <Target_Stmt>
  end

  rule type_declaration_stmt
    # F90:R501
    #
    # Constraint: The same attr_spec must not appear more than once in a given
    # type_declaration_stmt.

    label:label? type_spec attr_spec_option? entity_decl_list t_newline
#      &{ |e| m_s_g "type: #{e[1].type}"; m_s_g "names: #{e[3].names.join(' ')}" }
      <Type_Declaration_Stmt>
  end

  rule type_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule type_param_value
    # F90:R509
    #
    # Constraint: A function name must not be declared with an asterisk
    # type_param_value if the function is an internal or module function,
    # array-valued, pointer-valued, or recursive.

    specification_expr /
    t_star
  end

  rule type_spec
    # F90:R502

    type_spec_with_kind_selector /
    type_spec_without_kind_selector
  end

  rule type_spec_with_kind_selector
    t_integer kind_selector <Type_Spec> /
    t_real kind_selector <Type_Spec> /
    t_complex kind_selector <Type_Spec> /
    t_logical kind_selector <Type_Spec>
  end

  rule type_spec_without_kind_selector
    t_integer "" <Type_Spec> /
    t_real star_int <Type_Spec> / # NONSTANDARD!
    t_real "" <Type_Spec> /
    t_doubleprecision "" <Type_Spec> /
    t_complex "" <Type_Spec> /
    t_character char_selector? <Type_Spec> /
    t_logical "" <Type_Spec> /
    t_type t_paren_l type_name t_paren_r <Type_Spec>
  end

  rule upper_bound
    # F90:R515

    specification_expr
  end

  rule use_name
    # Multiple uses (not explicitly defined)

    name
  end

  rule use_part
#    ( use_stmt / sms_declarative )* <E>
    ( use_stmt / directive )* <E>
  end

  rule use_stmt
    # F90:R1107

    label:label? t_use module_name rename_list_option? t_newline <Use_Stmt_1> /
    label:label? t_use module_name t_comma t_only t_colon only_list? t_newline
      <Use_Stmt_2>
  end

  rule variable
    # F90:R601
    #
    # Constraint: scalar_variable_name must not have the PARAMETER attribute.
    # array_variable_name must be the name of a data object that is an array.
    # array_variable_name must not have the PARAMETER attribute. subobject
    # must not be a subobject designator (for example, a substring) whose
    # parent is a constant.

    subobject /
    array_variable_name /
    scalar_variable_name
  end

  rule variable_name
    # Multiple uses (not explicitly defined)
    #
    # Note: Assumed constraint: variable_name must not have the PARAMETER
    # attribute.

    name
  end

  rule vector_subscript
    # F90:R621
    #
    # Constraint: A vector_subscript must be an integer array expression of rank
    # one.

    int_expr
  end

  rule where_assignment_stmt_block
    assignment_stmt* <E>
  end

  rule where_construct
    # F90:R739
    #
    # Constraint: The assignment_stmt must not be a defined assignment.

    where_construct_stmt where_assignment_stmt_block elsewhere_construct?
      end_where_stmt <E>
  end

  rule where_construct_stmt
    # F90:R740

    label:label? t_where t_paren_l mask_expr t_paren_r t_newline
      <Where_Construct_Stmt>
  end

  rule where_stmt
    # F90:R738
    #
    # Constraint: The assignment_stmt must not be a defined assignment.

    label:label? t_where t_paren_l mask_expr t_paren_r !label assignment_stmt
      <Where_Stmt>
  end

  rule write_stmt
    # F90:R910

    label:label? t_write t_paren_l io_control_spec_list t_paren_r
      output_item_list? t_newline <Write_Stmt>
  end

end

# paul.a.madden@noaa.gov
