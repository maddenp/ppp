# NOTES: Grammar rule numbers or section numbers from the Fortran 90 standard
# document are given when possible. Grammar rule names used here match those
# from the standard document, with underscores in place of hyphens. Some left-
# recursive rules given by the standard have been translated to right-recursive
# for PEG compatability; the original (implied) rules are given in comments. The
# "start" rule must go first; other rules are in alphabetical order. Constraints
# described in the standard document are given in comments. Rule names for
# literal terminals not defined in the standard are prefixed with "t_".

grammar Fortran

  rule start

    program_unit

  end

  rule action_stmt

    # R216 -- INCOMPLETE
    #
    # Note: Provide label handling in rules for individual statements.

    print_stmt

  end

  rule add_op

    # R710

    t_plus / t_minus

  end

  rule add_operand

    # R706
    #
    # Note: Left-recursive rule implied by standard:
    # ( add_operand mult_op)? mult_operand

    mult_operand ( mult_op add_operand )? <Verbatim>

  end

  rule and_op

    # R720

    ".and." <Verbatim>

  end

  rule alphanumeric_character

    # R302

    t_letter / t_digit / t_underscore

  end

  rule binary_constant

    # R408
    #
    # Constraint: digit must have one of the values 0 or 1. Note: 'digit is
    # replaced by 't_binary' here to enforce the constraint.

    "b" ( ( t_apostrophe t_binary+ t_apostrophe ) / ( t_quotemark t_binary+ t_quotemark ) ) <Verbatim>

  end

  rule boz_literal_constant

    # R407
    #
    # Constraint: A boz-literal-constant may appear only in a DATA statement.

    binary_constant / octal_constant / hex_constant

  end

  rule char_literal_constant

    # R420
    #
    # Constraint: The value of kind-param must specify a representation method
    # that exists on the processor.

    ( kind_param t_underscore )? t_apostrophe (!t_apostrophe rep_char)* t_apostrophe <Verbatim> / ( kind_param t_underscore )? t_quotemark (!t_quotemark rep_char)* t_quotemark <Verbatim>

  end

  rule character

    # R301

    alphanumeric_character / special_character

  end

  rule concat_op

    # R712

    "//" <Verbatim>

  end

  rule constant

    # R305

    literal_constant / named_constant

  end

  rule declaration_construct

    # R207 -- INCOMPLETE

    format_stmt

  end

  rule default_char_expr

    # R727
    #
    # Constraint: must be of type default character

    expr

  end

  rule defined_binary_op

    # R724
    #
    # Constraint: Must not contain more than 31 letters and must not be the same
    # as any intrinsic-operator or logical-literal-constant.

    t_dot t_letter t_letter+ t_dot <Verbatim>

  end

  rule defined_unary_op

    # R704
    #
    # Constraint: Must not contain more than 31 letters and must not be the same
    # as any intrinsic-operator or logical-literal-constant.

    !( intrinsic_operator / logical_literal_constant ) t_dot t_letter t_letter+ t_dot <Verbatim>

  end

  rule digit_string

    # R402

    t_digit+ <Verbatim>

  end

  rule end_program_stmt

    # R1103
    #
    # Constraint: The program-name may be included in the end-program-stmt only
    # if the optional program-stmt is used and, if included, must be identical
    # to the program-name specified in the program-stmt.

    label? t_end t_program? program_name? t_newline? <End_Program_Stmt>

  end

  rule equiv_op

    # R722

    ".eqv." <Verbatim> / ".neqv." <Verbatim>

  end

  rule equiv_operand

    # R715

    not_op? level_4_expr <Verbatim>

  end

  rule executable_construct

    # R215 -- INCOMPLETE

    action_stmt

  end

  rule execution_part

    # R208
    #
    # Constraint: An execution-part must not contain an end-function-stmt,
    # end-program-stmt, or end-subroutine-stmt.

    executable_construct execution_part_construct <Execution_Part>

  end

  rule execution_part_construct

    # R209 -- INCOMPLETE

    ( executable_construct / format_stmt )* <Execution_Part_Construct>

  end

  rule exponent

    # R416

    signed_digit_string

  end

  rule exponent_letter

    # R415

    [ed] <Verbatim>

  end

  rule expr

    # R723
    #
    # Note: Left-recursive rule implied by standard:
    # ( expr defined_binary_op )? level_5_expr

    level_5_expr ( defined_binary_op expr )? <Verbatim>

  end

  rule format

    # R913
    #
    # Constraint: The label must be the label of a FORMAT statement that appears
    # in the same scoping unit as the statement containing the format specifier.
    # The scalar-default-int-variable must have been assigned (8.2.4) the
    # statement label of a FORMAT statement that appears in the same scoping
    # unit as the format.
    
    default_char_expr / label / t_star / scalar_default_int_variable
  
  end

  rule format_specification

    # R1002
    #
    # Note: A vast simplification is made here under the assumption that it is
    # only necessary to pass a format-specification through verbatim, not to
    # analyze its contents.

    t_paren_l (!t_paren_r character)+ t_paren_r <Verbatim>

  end

 rule format_stmt

    # R1001
    #
    # Constraint: The format-stmt must be labeled.

    label t_format format_specification t_newline <Format_Stmt>

  end

  rule hex_constant

    # R410

    "z" ( ( t_apostrophe hex_digit+ t_apostrophe ) / ( t_quotemark hex_digit+ t_quotemark ) ) <Verbatim>

  end

  rule hex_digit

    # R411

    digit / [abcdef] <Verbatim>

  end

  rule int_literal_constant

    # R404

    digit_string ( t_underscore kind_param )? <Verbatim>

  end

  rule internal_subprogram_part

    ""

  end

  rule intrinsic_operator

    # R310

    power_op / mult_op / add_op / concat_op / rel_op / not_op / and_op / or_op / equiv_op

  end

  rule kind_param

    # R405
    #
    # Constraint: The value of kind-param must be nonnegative. The value of
    # kind-param must specify a representation method that exists on the
    # processor.

    digit_string / scalar_int_constant_name

  end

  rule label

    # R313
    #
    # Constraint: At least one digit in a label must be nonzero. If a statement
    # is labeled, the statement must contain a nonblank character. The same
    # statement label must not be given to more than one statement in a scoping
    # unit. Leading zeros are not significant in distinguishing between
    # statement labels.

    t_digit 1..5 <Verbatim>

  end

  rule level_1_expr

    # R703

    defined_unary_op? primary <Verbatim>

  end

  rule level_2_expr

    # R707
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_2_expr? add_op )? add_operand

    add_op? add_operand level_2_expr? <Verbatim>

  end

  rule level_3_expr

    # R711
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr concat_op )? level_2_expr

    level_2_expr ( concat_op level_3_expr )? <Verbatim>

  end

  rule level_4_expr

    # R713
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_3_expr rel_op )? level_3_expr

    level_3_expr ( rel_op level_3_expr )? <Verbatim>

  end
  
  rule level_5_expr

    # R718
    #
    # Note: Left-recursive rule implied by standard:
    # ( level_5_expr equiv_op)? equiv_operand

    equiv_operand ( equiv_op level_5_expr )? <Verbatim>

  end

  rule literal_constant

    # R306 -- INCOMPLETE
    #
    # Note: The choice order is different than that given in the standard, e.g.
    # an int_literal_constant should only be matched after failure to match a
    # real_literal_constant.

    real_literal_constant / int_literal_constant / logical_literal_constant / char_literal_constant / boz_literal_constant

  end

  rule logical_literal_constant

    # R421
    #
    # Constraint: The value of kind-param must specify a representation that
    # exists on the processor.

    ( t_true / t_false ) ( t_underscore kind_param )? <Verbatim>

  end

  rule main_program

    # R1101 -- INCOMPLETE
    #
    # Constraint: In a main-program, the execution-part must not contain a
    # RETURN statement or an ENTRY statement.

    program_stmt? specification_part? execution_part? end_program_stmt <Main_Program>

  end

  rule mult_op

    # R709

    t_star / t_slash

  end

  rule mult_operand

    # R705

    level_1_expr ( power_op mult_operand )? <Verbatim>

  end

  rule octal_constant

    # R409
    #
    # Constraint: digit must have one of the values 0 through 7. Note: 'digit is
    # replaced by 't_octal' here to enforce the constraint.

    "o" ( ( t_apostrophe t_octal+ t_apostrophe ) / ( t_quotemark t_octal+ t_quotemark ) ) <Verbatim>

  end

  rule name

    # R304
    #
    # Constraint: The maximum length of a name is 31 characters.

    t_letter alphanumeric_character* <Name>

  end

  rule named_constant

    # R307

    name

  end

  rule not_op

    # R719

    ".not." <Verbatim>

  end

  rule or_op

    # R721

    ".or." <Verbatim>

  end

  rule output_item

    # R915 -- INCOMPLETE

    expr

  end

  rule output_item_list

    # 9.4.2
    #
    # Constraint: In an output-item-list, an io-implied-do-object must be an
    # output-item.

    ( t_comma output_item )+ <Verbatim>

  end

  rule power_op

    # R708

    "**" <Verbatim>

  end

  rule primary

    # R701 -- INCOMPLETE
    #
    # Constraint: subobject must be a subobject whose parent is a constant. A
    # variable that is a primary must not be an assumed-size array.

    constant

  end

  rule print_stmt

    # R911

    label? t_print format output_item_list? t_newline <Print_Stmt>

  end

  rule program_name

    # 11.1

    name

  end

  rule program_stmt

    # R1102

    label? t_program program_name t_newline <Program_Stmt>

  end

  rule program_unit

    # R202 -- INCOMPLETE

    main_program # / external_subprogram / module / block_data

  end

  rule real_literal_constant

    # R413
    #
    # Constraint: If both kind-param and exponent-letter are present,
    # exponent-letter bust be E. The value of kind-param must specify an
    # approximation method that exists on the processor.

    significand ( exponent_letter exponent )? ( t_underscore kind_param )? <Verbatim> / digit_string exponent_letter exponent ( t_underscore kind_param )? <Verbatim>

  end

  rule rel_op_eq

    ".eq." <Verbatim> / "==" <Verbatim>

  end

  rule rel_op_ge

    ".ge." <Verbatim> / ">=" <Verbatim>

  end

  rule rel_op_gt

    ".gt." <Verbatim> / ">" <Verbatim>

  end

  rule rel_op_le

    ".le." <Verbatim> / "<=" <Verbatim>

  end

  rule rel_op_lt

    ".lt." <Verbatim> / "<" <Verbatim>

  end

  rule rel_op_ne

    ".ne." <Verbatim> / "/=" <Verbatim>

  end

  rule rel_op

    # R714

    rel_op_eq / rel_op_ne / rel_op_lt / rel_op_le / rel_op_gt / rel_op_ge

  end

  rule rep_char

    # 4.3.2.1 (processor-dependent)
    #
    # Constraint: For the type character with kind kind-param, and for type
    # default character otherwise, a representable character, rep-char, is:
    # (1) Any character in the processor-dependent character set in fixed source
    # form. A processor may restrict the occurrence of some of all of the
    # control characters. (2) Any graphic character in the processor-dependent
    # character set in free source form.

    character

  end

  rule scalar_default_int_variable

    # Wide use (not explicitly defined)
    #
    # Constraint (assumed): scalar-default-int-variable must be a scalar, and
    # must be of type default INTEGER.    

    variable

  end

  rule scalar_int_constant_name

    # 4.3.1.1 (not explicitly defined)
    #
    # Constraint (assumed): scalar-int-constant-name must be a scalar, and must
    # be of type INTEGER.

    named_constant

  end

  rule scalar_variable_name

    # Section 6 (not explicitly defined)
    #
    # Note: Assumed constraint: scalar-variable-name must be a scalar.

    variable_name

  end

  rule sign

    # R406

    t_plus / t_minus

  end

  rule signed_digit_string

    # R401

    sign? digit_string <Verbatim>

  end

  rule signed_int_literal_constant

    # R403

    sign? int_literal_constant <Verbatim>

  end

  rule signed_real_literal_constant

    # R412

    sign? real_literal_constant <Verbatim>

  end

  rule significand

    # R414

    digit_string t_dot digit_string? <Verbatim> / t_dot digit_string <Verbatim>

  end

  rule special_character

    # 3.1.4

    [\ \=\+\-\*\/\(\)\;\.\'\:\!\"\%\&\;\<\>\?\$]

  end

  rule specification_part

    # R204 -- INCOMPLETE

    #use_stmt* implicit_part? declaration_construct* <Specification_Part> 
    declaration_construct* <Specification_Part> 

  end

  rule t_apostrophe

    "'" <Verbatim>

  end

  rule t_binary

    [01] <Verbatim>

  end

  rule t_comma

    "," <Verbatim>

  end

  rule t_digit

    [0-9] <Verbatim>

  end

  rule t_dot

    "." <Verbatim>

  end

  rule t_end

    "end" <Verbatim>

  end

  rule t_false

    ".false." <Verbatim>

  end

  rule t_format

    "format" <Verbatim>

  end

  rule t_letter

    [a-z]

  end

  rule t_minus

    "-" <Verbatim>

  end

  rule t_newline

    "\n" <Verbatim>

  end

  rule t_octal

    [01234567] <Verbatim>

  end

  rule t_paren_l

    "(" <Verbatim>

  end

  rule t_paren_r

    ")" <Verbatim>

  end

  rule t_plus

    "+" <Verbatim>

  end

  rule t_print

    "print" <Verbatim>

  end

  rule t_program

    "program" <Verbatim>

  end

  rule t_quotemark

    "\"" <Verbatim>

  end
  rule t_slash

    "/" <Verbatim>

  end

  rule t_star

    "*" <Verbatim>

  end

  rule t_true

    ".true." <Verbatim>

  end

  rule t_underscore

    # R303

    "_"

  end

  rule variable

    # R601 -- INCOMPLETE
    #
    # Constraint: scalar-variable-name must not have the PARAMETER attribute.
    # array-variable-name must be the name of a data object that is an array.
    # array-variable-name must not have the PARAMETER attribute. subobject
    # must not be a subobject designator (for example, a substring) whose
    # parent is a constant.

    scalar_variable_name

  end

  rule variable_name

    # Wide use (not explicitly defined)
    #
    # Constraint (assumed): variable-name must not have the PARAMETER attribute.

    name

  end

end

# paul.a.madden@noaa.gov
