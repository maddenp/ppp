# NOTES: Grammar rule numbers or section numbers from the Fortran 90 standard
# document are given when possible. Grammar rule names used here match those
# from the standard document, with underscores in place of hyphens. Some left-
# recursive rules given by the standard have been translated to right-recursive
# for PEG compatability; the original (implied) rules are given in comments. The
# 'start' rule must go first; other rules are in alphabetical order. Any rule
# name that conflicts with a Treetop grammar token is prepended with an
# underscore (e.g. '_end'). Constraints described in the standard document are
# given in comments.

grammar Fortran

  rule start
    main_program
  end

  rule action_stmt
    # R216 -- INCOMPLETE!
    print_stmt
  end

  rule add_op
    # R710
    plus / minus
  end

  rule add_operand
    # R706
    # Left-recursive rule implied by standard:
    # ( add_operand mult_op)? mult_operand
    mult_operand ( mult_op add_operand )? <Verbatim>
  end

  rule alphanumeric_character
    # R302
    letter / digit / underscore
  end

  rule character
    # R301
    alphanumeric_character / special_character
  end

  rule comma
    "," <Verbatim>
  end

  rule concat_op
    # R712
    "//" <Verbatim>
  end

  rule constant
    # R305
    literal_constant / named_constant
  end

  rule default_char_expr
    # R727
    expr
    # Constraint: must be of type default character
  end

  rule defined_binary_op
    # R724
    dot letter letter+ dot <Verbatim>
    # Constraint: Must not contain more than 31 letters and must not be the same
    # as any intrinsic-operator or logical-literal-constant.
  end

  rule defined_unary_op
    # R704
    dot letter letter+ dot <Verbatim>
    # Constraint: Must not contain more than 31 letters and must not be the same
    # as any intrinsic-operator or logical-literal-constant.
  end

  rule digit
    # 3.1.2
    [0-9]
  end

  rule digit_string
    # R402
    digit+ <Verbatim>
  end

  rule dot
    "." <Verbatim>
  end

  rule _end
    "end" <Verbatim>
  end

  rule end_program_stmt
    # R1103
    _end program? program_name? newline? <End_Program_Stmt>
    # Constraint: The program-name may be included in the end-program-stmt only
    # if the optional program-stmt is used and, if included, must be identical
    # to the program-name specified in the program-stmt.
  end

  rule equiv_op
    # R722
    ".eqv." <Verbatim> / ".neqv." <Verbatim>
  end

  rule equiv_operand
    # R715
    not_op? level_4_expr <Verbatim>
  end

  rule executable_construct
    # R215 -- INCOMPLETE!
    action_stmt
  end

  rule execution_part
    # R208 -- INCOMPLETE!
    executable_construct execution_part_construct <Execution_Part>
    # Constraint: An execution-part must not contain an end-function-stmt,
    # end-program-stmt, or end-subroutine-stmt.
  end

  rule execution_part_construct
    # R209 -- INCOMPLETE!
    ( executable_construct )* <Execution_Part_Construct>
  end

  rule expr
    # R723
    # Left-recursive rule implied by standard:
    # ( expr defined_binary_op )? level_5_expr
    level_5_expr ( defined_binary_op expr )? <Verbatim>
  end

  rule format
    # R913 -- INCOMPLETE!
    default_char_expr / star
    # Constraint: The label must be the label of a FORMAT statement that appears
    # in the same scoping unit as the statement containing the format specifier.
  end

  rule int_literal_constant
    # R404
    digit_string ( underscore kind_param )? <Verbatim>
  end

  rule internal_subprogram_part
    ""
  end

  rule kind_param
    # R405
    digit_string / scalar_int_constant_name
    # Constraint: The value of kind-param must be nonnegative. The value of
    # kind-param must specify a representation method that exists on the
    # processor.
  end

  rule letter
    # 3.1.1
    [a-z]
  end

  rule level_1_expr
    # R703
    defined_unary_op? primary <Verbatim>
  end

  rule level_2_expr
    # R707
    # Left-recursive rule implied by standard:
    # ( level_2_expr? add_op )? add_operand
    add_op? add_operand level_2_expr? <Verbatim>
  end

  rule level_3_expr
    # R711
    # Left-recursive rule implied by standard:
    # ( level_3_expr concat_op )? level_2_expr
    level_2_expr ( concat_op level_3_expr )? <Verbatim>
  end

  rule level_4_expr
    # R713
    # Left-recursive rule implied by standard:
    # ( level_3_expr rel_op )? level_3_expr
    level_3_expr ( rel_op level_3_expr )? <Verbatim>
  end
  
  rule level_5_expr
    # R718
    # Left-recursive rule implied by standard:
    # ( level_5_expr equiv_op)? equiv_operand
    equiv_operand ( equiv_op level_5_expr )? <Verbatim>
  end

  rule literal_constant
    # R306 -- INCOMPLETE!
    int_literal_constant
  end

  rule main_program
    # R1101 -- INCOMPLETE!
    program_stmt? execution_part? end_program_stmt <Main_Program>
    # Constraint: In a main-program, the execution-part must not contain a
    # RETURN statement or an ENTRY statement.
  end

  rule minus
    "-" <Verbatim>
  end

  rule mult_op
    # R709
    star / slash
  end

  rule mult_operand
    # R705
    level_1_expr ( power_op mult_operand )? <Verbatim>
  end

  rule name
    # R304
    letter alphanumeric_character* <Name>
    # Constraint: The maximum length of a name is 31 characters.
  end

  rule named_constant
    # R307
    name
  end

  rule newline
    "\n" <Verbatim>
  end

  rule not_op
    # R719
    ".not." <Verbatim>
  end

  rule output_item
    # R915 -- INCOMPLETE!
    expr
  end

  rule output_item_list
    # 9.4.2
    comma output_item+ <Verbatim>
    # Constraint: In an output-item-list, an io-implied-do-object must be an
    # output-item.
  end

  rule plus
    "+" <Verbatim>
  end

  rule power_op
    # R708
    "**" <Verbatim>
  end

  rule primary
    # R701 -- INCOMPLETE!
    constant
    # Constraint: subobject must be a subobject whose parent is a constant. A
    # variable that is a primary must not be an assumed-size array.
  end

  rule print
    "print" <Verbatim>
  end

  rule print_stmt
    # R911
    print format output_item_list newline <Print_Stmt> / print format newline <Print_Stmt>
  end

  rule program
    "program" <Verbatim>
  end

  rule program_name
    # 11.1
    name
  end

  rule program_stmt
    # R1102
    program program_name newline <Program_Stmt>
  end

  rule rel_op_eq
    ".eq." <Verbatim> / "==" <Verbatim>
  end

  rule rel_op_ge
    ".ge." <Verbatim> / ">=" <Verbatim>
  end

  rule rel_op_gt
    ".gt." <Verbatim> / ">" <Verbatim>
  end

  rule rel_op_le
    ".le." <Verbatim> / "<=" <Verbatim>
  end

  rule rel_op_lt
    ".lt." <Verbatim> / "<" <Verbatim>
  end

  rule rel_op_ne
    ".ne." <Verbatim> / "/=" <Verbatim>
  end

  rule rel_op
    # R714
    rel_op_eq / rel_op_ne / rel_op_lt / rel_op_le / rel_op_gt / rel_op_ge
  end

  rule scalar_int_constant_name
    # 4.3.1.1
    # This rule is not given by the standard. Assumption: It is a named-constant
    # whose value is a scalar-int-expr. If error checking were required, a
    # type-and-rank check could be performed here.
    named_constant
  end

  rule sign
    # R406
    plus / minus
  end

  rule signed_digit_string
    # R401
    sign? digit_string <Verbatim>
  end

  rule signed_int_literal_constant
    # R403
    sign? int_literal_constant <Verbatim>
  end

  rule slash
    "/" <Verbatim>
  end

  rule special_character
    # 3.1.4
    [ =+-*/();.':!"%&;<>?$]
  end

  rule specification_part
    ""
  end

  rule star
    "*" <Verbatim>
  end

  rule underscore
    # R303
    '_'
  end

end

# paul.a.madden@noaa.gov
