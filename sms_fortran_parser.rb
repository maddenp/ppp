# Autogenerated from a Treetop grammar. Edits may be lost.


require 'fortran_parser'

module Fortran
  include Treetop::Runtime

  def root
    @root ||= :declaration_construct
  end

  module DeclarationConstruct0
    def stmt_function_stmt
      elements[0]
    end

  end

  def _nt_declaration_construct
    start_index = index
    if node_cache[:declaration_construct].has_key?(index)
      cached = node_cache[:declaration_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_derived_type_def
    if r1
      r0 = r1
    else
      r2 = _nt_interface_block
      if r2
        r0 = r2
      else
        r3 = _nt_type_declaration_stmt
        if r3
          r0 = r3
        else
          r4 = _nt_specification_stmt
          if r4
            r0 = r4
          else
            r5 = _nt_parameter_stmt
            if r5
              r0 = r5
            else
              r6 = _nt_format_stmt
              if r6
                r0 = r6
              else
                r7 = _nt_entry_stmt
                if r7
                  r0 = r7
                else
                  i8, s8 = index, []
                  r9 = _nt_stmt_function_stmt
                  s8 << r9
                  if r9
                    i10 = index
                    r11 = lambda { |e| sp_is_array?(e[0]) }.call(s8)
                    if r11
                      r10 = nil
                    else
                      @index = i10
                      r10 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s8 << r10
                  end
                  if s8.last
                    r8 = instantiate_node(E,input, i8...index, s8)
                    r8.extend(DeclarationConstruct0)
                  else
                    @index = i8
                    r8 = nil
                  end
                  if r8
                    r0 = r8
                  else
                    r12 = _nt_directive
                    if r12
                      r0 = r12
                    else
                      r13 = _nt_sms_passthrough
                      if r13
                        r0 = r13
                      else
                        r14 = _nt_sms_declarative
                        if r14
                          r0 = r14
                        else
                          @index = i0
                          r0 = nil
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:declaration_construct][start_index] = r0

    r0
  end

  module Directive0
    def t_newline
      elements[3]
    end
  end

  def _nt_directive
    start_index = index
    if node_cache[:directive].has_key?(index)
      cached = node_cache[:directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_sms_sentinel
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if has_terminal?("!", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("!")
        r3 = nil
      end
      s0 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_character
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(Directive0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:directive][start_index] = r0

    r0
  end

  def _nt_executable_construct
    start_index = index
    if node_cache[:executable_construct].has_key?(index)
      cached = node_cache[:executable_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_executable_construct_action_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_case_construct
      if r2
        r0 = r2
      else
        r3 = _nt_do_construct
        if r3
          r0 = r3
        else
          r4 = _nt_if_construct
          if r4
            r0 = r4
          else
            r5 = _nt_where_construct
            if r5
              r0 = r5
            else
              r6 = _nt_directive
              if r6
                r0 = r6
              else
                r7 = _nt_sms_passthrough
                if r7
                  r0 = r7
                else
                  r8 = _nt_sms_executable
                  if r8
                    r0 = r8
                  else
                    @index = i0
                    r0 = nil
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:executable_construct][start_index] = r0

    r0
  end

  def _nt_external_subprogram
    start_index = index
    if node_cache[:external_subprogram].has_key?(index)
      cached = node_cache[:external_subprogram][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_subroutine_subprogram
    if r1
      r0 = r1
    else
      r2 = _nt_function_subprogram
      if r2
        r0 = r2
      else
        r3 = _nt_directive
        if r3
          r0 = r3
        else
          r4 = _nt_sms_passthrough
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:external_subprogram][start_index] = r0

    r0
  end

  def _nt_implicit_part
    start_index = index
    if node_cache[:implicit_part].has_key?(index)
      cached = node_cache[:implicit_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    s1, i1 = [], index
    loop do
      r2 = _nt_implicit_part_stmt
      if r2
        s1 << r2
      else
        break
      end
    end
    if s1.empty?
      @index = i1
      r1 = nil
    else
      r1 = instantiate_node(E,input, i1...index, s1)
    end
    if r1
      r0 = r1
    else
      r3 = _nt_directive
      if r3
        r0 = r3
      else
        r4 = _nt_sms_passthrough
        if r4
          r0 = r4
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:implicit_part][start_index] = r0

    r0
  end

  def _nt_internal_subprogram
    start_index = index
    if node_cache[:internal_subprogram].has_key?(index)
      cached = node_cache[:internal_subprogram][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_subroutine_subprogram
    if r1
      r0 = r1
    else
      r2 = _nt_function_subprogram
      if r2
        r0 = r2
      else
        r3 = _nt_directive
        if r3
          r0 = r3
        else
          r4 = _nt_sms_passthrough
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:internal_subprogram][start_index] = r0

    r0
  end

  def _nt_module_subprogram
    start_index = index
    if node_cache[:module_subprogram].has_key?(index)
      cached = node_cache[:module_subprogram][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_subroutine_subprogram
    if r1
      r0 = r1
    else
      r2 = _nt_function_subprogram
      if r2
        r0 = r2
      else
        r3 = _nt_directive
        if r3
          r0 = r3
        else
          r4 = _nt_sms_passthrough
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:module_subprogram][start_index] = r0

    r0
  end

  module SmsBarrier0
    def sms_sentinel
      elements[0]
    end

    def sms_t_barrier
      elements[1]
    end

    def t_newline
      elements[2]
    end
  end

  def _nt_sms_barrier
    start_index = index
    if node_cache[:sms_barrier].has_key?(index)
      cached = node_cache[:sms_barrier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_barrier
      s0 << r2
      if r2
        r3 = _nt_t_newline
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Barrier,input, i0...index, s0)
      r0.extend(SmsBarrier0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_barrier][start_index] = r0

    r0
  end

  module SmsCompareVar0
    def sms_sentinel
      elements[0]
    end

    def sms_t_compare_var
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def variable
      elements[3]
    end

    def t_comma
      elements[4]
    end

    def sms_string
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def t_newline
      elements[7]
    end
  end

  def _nt_sms_compare_var
    start_index = index
    if node_cache[:sms_compare_var].has_key?(index)
      cached = node_cache[:sms_compare_var][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_compare_var
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_variable
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_sms_string
              s0 << r6
              if r6
                r7 = _nt_t_paren_r
                s0 << r7
                if r7
                  r8 = _nt_t_newline
                  s0 << r8
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Compare_Var,input, i0...index, s0)
      r0.extend(SmsCompareVar0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_compare_var][start_index] = r0

    r0
  end

  module SmsCreateDecomp0
    def sms_sentinel
      elements[0]
    end

    def sms_t_create_decomp
      elements[1]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_sms_create_decomp
    start_index = index
    if node_cache[:sms_create_decomp].has_key?(index)
      cached = node_cache[:sms_create_decomp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_create_decomp
      s0 << r2
      if r2
        s3, i3 = [], index
        loop do
          r4 = _nt_character
          if r4
            s3 << r4
          else
            break
          end
        end
        if s3.empty?
          @index = i3
          r3 = nil
        else
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        end
        s0 << r3
        if r3
          r5 = _nt_t_newline
          s0 << r5
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Create_Decomp,input, i0...index, s0)
      r0.extend(SmsCreateDecomp0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_create_decomp][start_index] = r0

    r0
  end

  def _nt_sms_declarative
    start_index = index
    if node_cache[:sms_declarative].has_key?(index)
      cached = node_cache[:sms_declarative][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_sms_declare_decomp
    if r1
      r0 = r1
    else
      r2 = _nt_sms_distribute_begin
      if r2
        r0 = r2
      else
        r3 = _nt_sms_distribute_end
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:sms_declarative][start_index] = r0

    r0
  end

  module SmsDeclareDecomp0
    def sms_sentinel
      elements[0]
    end

    def sms_t_declare_decomp
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_decomp_name
      elements[3]
    end

    def t_comma
      elements[4]
    end

    def scalar_int_literal_constant
      elements[5]
    end

    def t_colon
      elements[6]
    end

    def sms_t_unstructured
      elements[7]
    end

    def t_paren_r
      elements[8]
    end

    def t_newline
      elements[9]
    end
  end

  def _nt_sms_declare_decomp
    start_index = index
    if node_cache[:sms_declare_decomp].has_key?(index)
      cached = node_cache[:sms_declare_decomp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_declare_decomp
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_decomp_name
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_scalar_int_literal_constant
              s0 << r6
              if r6
                r7 = _nt_t_colon
                s0 << r7
                if r7
                  r8 = _nt_sms_t_unstructured
                  s0 << r8
                  if r8
                    r9 = _nt_t_paren_r
                    s0 << r9
                    if r9
                      r10 = _nt_t_newline
                      s0 << r10
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Declare_Decomp,input, i0...index, s0)
      r0.extend(SmsDeclareDecomp0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_declare_decomp][start_index] = r0

    r0
  end

  module SmsDecompName0
    def name
      elements[0]
    end

  end

  def _nt_sms_decomp_name
    start_index = index
    if node_cache[:sms_decomp_name].has_key?(index)
      cached = node_cache[:sms_decomp_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_name
    s0 << r1
    if r1
      if has_terminal?("", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure("")
        r2 = nil
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_Decomp_Name,input, i0...index, s0)
      r0.extend(SmsDecompName0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_decomp_name][start_index] = r0

    r0
  end

  module SmsDistributeBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_distribute
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_decomp_name
      elements[3]
    end

    def t_comma
      elements[4]
    end

    def sms_distribute_dims
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def sms_t_begin
      elements[7]
    end

    def t_newline
      elements[8]
    end

  end

  def _nt_sms_distribute_begin
    start_index = index
    if node_cache[:sms_distribute_begin].has_key?(index)
      cached = node_cache[:sms_distribute_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_distribute
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_decomp_name
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_sms_distribute_dims
              s0 << r6
              if r6
                r7 = _nt_t_paren_r
                s0 << r7
                if r7
                  r8 = _nt_sms_t_begin
                  s0 << r8
                  if r8
                    r9 = _nt_t_newline
                    s0 << r9
                    if r9
                      i10 = index
                      r11 = lambda { |e| sp_sms_distribute_begin(e[3],e[5]) }.call(s0)
                      if r11
                        @index = i10
                        r10 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        r10 = nil
                      end
                      s0 << r10
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Distribute_Begin,input, i0...index, s0)
      r0.extend(SmsDistributeBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_distribute_begin][start_index] = r0

    r0
  end

  def _nt_sms_distribute_dim
    start_index = index
    if node_cache[:sms_distribute_dim].has_key?(index)
      cached = node_cache[:sms_distribute_dim][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_literal_constant

    node_cache[:sms_distribute_dim][start_index] = r0

    r0
  end

  module SmsDistributeDims0
    def sms_distribute_dim1
      elements[0]
    end

    def t_comma
      elements[1]
    end

    def sms_distribute_dim2
      elements[2]
    end
  end

  module SmsDistributeDims1
    def t_comma
      elements[0]
    end

    def sms_distribute_dim
      elements[1]
    end
  end

  module SmsDistributeDims2
    def sms_distribute_dim
      elements[0]
    end

  end

  def _nt_sms_distribute_dims
    start_index = index
    if node_cache[:sms_distribute_dims].has_key?(index)
      cached = node_cache[:sms_distribute_dims][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_sms_distribute_dim
    s1 << r2
    if r2
      r3 = _nt_t_comma
      s1 << r3
      if r3
        r4 = _nt_sms_distribute_dim
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SMS_Distribute_Dims_1,input, i1...index, s1)
      r1.extend(SmsDistributeDims0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_t_comma
      s5 << r6
      if r6
        r7 = _nt_sms_distribute_dim
        s5 << r7
      end
      if s5.last
        r5 = instantiate_node(SMS_Distribute_Dims_2,input, i5...index, s5)
        r5.extend(SmsDistributeDims1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        i8, s8 = index, []
        r9 = _nt_sms_distribute_dim
        s8 << r9
        if r9
          if has_terminal?("", false, index)
            r10 = instantiate_node(SyntaxNode,input, index...(index + 0))
            @index += 0
          else
            terminal_parse_failure("")
            r10 = nil
          end
          s8 << r10
        end
        if s8.last
          r8 = instantiate_node(SMS_Distribute_Dims_3,input, i8...index, s8)
          r8.extend(SmsDistributeDims2)
        else
          @index = i8
          r8 = nil
        end
        if r8
          r0 = r8
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:sms_distribute_dims][start_index] = r0

    r0
  end

  module SmsDistributeEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_distribute
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_distribute_end
    start_index = index
    if node_cache[:sms_distribute_end].has_key?(index)
      cached = node_cache[:sms_distribute_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_distribute
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_distribute_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Distribute_End,input, i0...index, s0)
      r0.extend(SmsDistributeEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_distribute_end][start_index] = r0

    r0
  end

  module SmsExchange0
    def t_comma
      elements[0]
    end

    def variable
      elements[1]
    end
  end

  module SmsExchange1
    def sms_sentinel
      elements[0]
    end

    def sms_t_exchange
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def variable
      elements[3]
    end

    def t_paren_r
      elements[5]
    end

    def t_newline
      elements[6]
    end
  end

  def _nt_sms_exchange
    start_index = index
    if node_cache[:sms_exchange].has_key?(index)
      cached = node_cache[:sms_exchange][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_exchange
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_variable
          s0 << r4
          if r4
            s5, i5 = [], index
            loop do
              i6, s6 = index, []
              r7 = _nt_t_comma
              s6 << r7
              if r7
                r8 = _nt_variable
                s6 << r8
              end
              if s6.last
                r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                r6.extend(SmsExchange0)
              else
                @index = i6
                r6 = nil
              end
              if r6
                s5 << r6
              else
                break
              end
            end
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            s0 << r5
            if r5
              r9 = _nt_t_paren_r
              s0 << r9
              if r9
                r10 = _nt_t_newline
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Exchange,input, i0...index, s0)
      r0.extend(SmsExchange1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_exchange][start_index] = r0

    r0
  end

  module SmsExecutable0
    def sms_halo_comp
      elements[0]
    end

  end

  module SmsExecutable1
    def sms_parallel
      elements[0]
    end

  end

  module SmsExecutable2
    def sms_to_local
      elements[0]
    end

  end

  def _nt_sms_executable
    start_index = index
    if node_cache[:sms_executable].has_key?(index)
      cached = node_cache[:sms_executable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_sms_barrier
    if r1
      r0 = r1
    else
      r2 = _nt_sms_compare_var
      if r2
        r0 = r2
      else
        r3 = _nt_sms_exchange
        if r3
          r0 = r3
        else
          i4, s4 = index, []
          r5 = _nt_sms_halo_comp
          s4 << r5
          if r5
            i6 = index
            r7 = lambda { |e| sp_sms_halo_comp }.call(s4)
            if r7
              @index = i6
              r6 = instantiate_node(SyntaxNode,input, index...index)
            else
              r6 = nil
            end
            s4 << r6
          end
          if s4.last
            r4 = instantiate_node(E,input, i4...index, s4)
            r4.extend(SmsExecutable0)
          else
            @index = i4
            r4 = nil
          end
          if r4
            r0 = r4
          else
            i8, s8 = index, []
            r9 = _nt_sms_parallel
            s8 << r9
            if r9
              i10 = index
              r11 = lambda { |e| sp_sms_parallel }.call(s8)
              if r11
                @index = i10
                r10 = instantiate_node(SyntaxNode,input, index...index)
              else
                r10 = nil
              end
              s8 << r10
            end
            if s8.last
              r8 = instantiate_node(E,input, i8...index, s8)
              r8.extend(SmsExecutable1)
            else
              @index = i8
              r8 = nil
            end
            if r8
              r0 = r8
            else
              i12, s12 = index, []
              r13 = _nt_sms_to_local
              s12 << r13
              if r13
                i14 = index
                r15 = lambda { |e| sp_sms_to_local }.call(s12)
                if r15
                  @index = i14
                  r14 = instantiate_node(SyntaxNode,input, index...index)
                else
                  r14 = nil
                end
                s12 << r14
              end
              if s12.last
                r12 = instantiate_node(E,input, i12...index, s12)
                r12.extend(SmsExecutable2)
              else
                @index = i12
                r12 = nil
              end
              if r12
                r0 = r12
              else
                r16 = _nt_sms_set_communicator
                if r16
                  r0 = r16
                else
                  r17 = _nt_sms_unstructured_grid
                  if r17
                    r0 = r17
                  else
                    r18 = _nt_sms_passthrough
                    if r18
                      r0 = r18
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:sms_executable][start_index] = r0

    r0
  end

  module SmsHaloComp0
    def sms_halo_comp_begin
      elements[0]
    end

    def block
      elements[1]
    end

    def sms_halo_comp_end
      elements[2]
    end
  end

  def _nt_sms_halo_comp
    start_index = index
    if node_cache[:sms_halo_comp].has_key?(index)
      cached = node_cache[:sms_halo_comp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_halo_comp_begin
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
      if r2
        r3 = _nt_sms_halo_comp_end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp,input, i0...index, s0)
      r0.extend(SmsHaloComp0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp][start_index] = r0

    r0
  end

  module SmsHaloCompBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_halo_comp
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_halo_comp_pairs
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def sms_t_begin
      elements[5]
    end

    def t_newline
      elements[6]
    end

  end

  def _nt_sms_halo_comp_begin
    start_index = index
    if node_cache[:sms_halo_comp_begin].has_key?(index)
      cached = node_cache[:sms_halo_comp_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_halo_comp
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_halo_comp_pairs
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
            if r5
              r6 = _nt_sms_t_begin
              s0 << r6
              if r6
                r7 = _nt_t_newline
                s0 << r7
                if r7
                  i8 = index
                  r9 = lambda { |e| sp_sms_halo_comp_begin(e[3]) }.call(s0)
                  if r9
                    @index = i8
                    r8 = instantiate_node(SyntaxNode,input, index...index)
                  else
                    r8 = nil
                  end
                  s0 << r8
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp_Begin,input, i0...index, s0)
      r0.extend(SmsHaloCompBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp_begin][start_index] = r0

    r0
  end

  module SmsHaloCompEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_halo_comp
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_halo_comp_end
    start_index = index
    if node_cache[:sms_halo_comp_end].has_key?(index)
      cached = node_cache[:sms_halo_comp_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_halo_comp
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_halo_comp_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp_End,input, i0...index, s0)
      r0.extend(SmsHaloCompEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp_end][start_index] = r0

    r0
  end

  module SmsHaloCompPair0
    def t_lt
      elements[0]
    end

    def expr1
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def expr2
      elements[3]
    end

    def t_gt
      elements[4]
    end
  end

  def _nt_sms_halo_comp_pair
    start_index = index
    if node_cache[:sms_halo_comp_pair].has_key?(index)
      cached = node_cache[:sms_halo_comp_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_lt
    s0 << r1
    if r1
      r2 = _nt_expr
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_expr
          s0 << r4
          if r4
            r5 = _nt_t_gt
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp_Pair,input, i0...index, s0)
      r0.extend(SmsHaloCompPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp_pair][start_index] = r0

    r0
  end

  module SmsHaloCompPairs0
    def t_comma
      elements[0]
    end

    def sms_halo_comp_pair
      elements[1]
    end
  end

  module SmsHaloCompPairs1
    def t_comma
      elements[0]
    end

    def sms_halo_comp_pair
      elements[1]
    end
  end

  module SmsHaloCompPairs2
    def sms_halo_comp_pair
      elements[0]
    end

  end

  def _nt_sms_halo_comp_pairs
    start_index = index
    if node_cache[:sms_halo_comp_pairs].has_key?(index)
      cached = node_cache[:sms_halo_comp_pairs][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_halo_comp_pair
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_t_comma
      s3 << r4
      if r4
        r5 = _nt_sms_halo_comp_pair
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(SmsHaloCompPairs0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        i7, s7 = index, []
        r8 = _nt_t_comma
        s7 << r8
        if r8
          r9 = _nt_sms_halo_comp_pair
          s7 << r9
        end
        if s7.last
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          r7.extend(SmsHaloCompPairs1)
        else
          @index = i7
          r7 = nil
        end
        if r7
          r6 = r7
        else
          r6 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r6
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp_Pairs,input, i0...index, s0)
      r0.extend(SmsHaloCompPairs2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp_pairs][start_index] = r0

    r0
  end

  module SmsIgnoreBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_ignore
      elements[1]
    end

    def sms_t_begin
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_sms_ignore_begin
    start_index = index
    if node_cache[:sms_ignore_begin].has_key?(index)
      cached = node_cache[:sms_ignore_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_ignore
      s0 << r2
      if r2
        r3 = _nt_sms_t_begin
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Ignore_Begin,input, i0...index, s0)
      r0.extend(SmsIgnoreBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_ignore_begin][start_index] = r0

    r0
  end

  module SmsIgnoreEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_ignore
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_sms_ignore_end
    start_index = index
    if node_cache[:sms_ignore_end].has_key?(index)
      cached = node_cache[:sms_ignore_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_ignore
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Ignore_End,input, i0...index, s0)
      r0.extend(SmsIgnoreEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_ignore_end][start_index] = r0

    r0
  end

  module SmsParenthesizedArgs0
    def character
      elements[1]
    end
  end

  module SmsParenthesizedArgs1
    def t_paren_l
      elements[0]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_sms_parenthesized_args
    start_index = index
    if node_cache[:sms_parenthesized_args].has_key?(index)
      cached = node_cache[:sms_parenthesized_args][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        i4 = index
        r5 = _nt_t_paren_r
        if r5
          r4 = nil
        else
          @index = i4
          r4 = instantiate_node(SyntaxNode,input, index...index)
        end
        s3 << r4
        if r4
          r6 = _nt_character
          s3 << r6
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(SmsParenthesizedArgs0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
      if r2
        r7 = _nt_t_paren_r
        s0 << r7
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(SmsParenthesizedArgs1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_parenthesized_args][start_index] = r0

    r0
  end

  module SmsParallel0
    def sms_parallel_begin
      elements[0]
    end

    def block
      elements[1]
    end

    def sms_parallel_end
      elements[2]
    end
  end

  def _nt_sms_parallel
    start_index = index
    if node_cache[:sms_parallel].has_key?(index)
      cached = node_cache[:sms_parallel][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_parallel_begin
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
      if r2
        r3 = _nt_sms_parallel_end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Parallel,input, i0...index, s0)
      r0.extend(SmsParallel0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_parallel][start_index] = r0

    r0
  end

  module SmsParallelBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_parallel
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_decomp_name
      elements[3]
    end

    def t_comma
      elements[4]
    end

    def sms_parallel_var_lists
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def sms_t_begin
      elements[7]
    end

    def t_newline
      elements[8]
    end

  end

  def _nt_sms_parallel_begin
    start_index = index
    if node_cache[:sms_parallel_begin].has_key?(index)
      cached = node_cache[:sms_parallel_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_parallel
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_decomp_name
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_sms_parallel_var_lists
              s0 << r6
              if r6
                r7 = _nt_t_paren_r
                s0 << r7
                if r7
                  r8 = _nt_sms_t_begin
                  s0 << r8
                  if r8
                    r9 = _nt_t_newline
                    s0 << r9
                    if r9
                      i10 = index
                      r11 = lambda { |e| sp_sms_parallel_begin(e[3],e[5]) }.call(s0)
                      if r11
                        @index = i10
                        r10 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        r10 = nil
                      end
                      s0 << r10
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Parallel_Begin,input, i0...index, s0)
      r0.extend(SmsParallelBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_parallel_begin][start_index] = r0

    r0
  end

  module SmsParallelEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_parallel
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_parallel_end
    start_index = index
    if node_cache[:sms_parallel_end].has_key?(index)
      cached = node_cache[:sms_parallel_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_parallel
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_parallel_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Parallel_End,input, i0...index, s0)
      r0.extend(SmsParallelEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_parallel_end][start_index] = r0

    r0
  end

  module SmsParallelVarList0
    def t_comma
      elements[0]
    end

    def variable_name
      elements[1]
    end
  end

  module SmsParallelVarList1
    def t_lt
      elements[0]
    end

    def variable_name
      elements[1]
    end

    def t_gt
      elements[3]
    end
  end

  module SmsParallelVarList2
    def variable_name
      elements[0]
    end

  end

  def _nt_sms_parallel_var_list
    start_index = index
    if node_cache[:sms_parallel_var_list].has_key?(index)
      cached = node_cache[:sms_parallel_var_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_lt
    s1 << r2
    if r2
      r3 = _nt_variable_name
      s1 << r3
      if r3
        s4, i4 = [], index
        loop do
          i5, s5 = index, []
          r6 = _nt_t_comma
          s5 << r6
          if r6
            r7 = _nt_variable_name
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(SmsParallelVarList0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s1 << r4
        if r4
          r8 = _nt_t_gt
          s1 << r8
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SMS_Parallel_Var_List_1,input, i1...index, s1)
      r1.extend(SmsParallelVarList1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i9, s9 = index, []
      r10 = _nt_variable_name
      s9 << r10
      if r10
        if has_terminal?("", false, index)
          r11 = instantiate_node(SyntaxNode,input, index...(index + 0))
          @index += 0
        else
          terminal_parse_failure("")
          r11 = nil
        end
        s9 << r11
      end
      if s9.last
        r9 = instantiate_node(SMS_Parallel_Var_List_2,input, i9...index, s9)
        r9.extend(SmsParallelVarList2)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r0 = r9
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sms_parallel_var_list][start_index] = r0

    r0
  end

  module SmsParallelVarLists0
    def t_comma1
      elements[0]
    end

    def t_comma2
      elements[1]
    end

    def sms_parallel_var_list
      elements[2]
    end
  end

  module SmsParallelVarLists1
    def t_comma1
      elements[0]
    end

    def sms_parallel_var_list1
      elements[1]
    end

    def t_comma2
      elements[2]
    end

    def sms_parallel_var_list2
      elements[3]
    end
  end

  module SmsParallelVarLists2
    def t_comma
      elements[0]
    end

    def sms_parallel_var_list
      elements[1]
    end
  end

  module SmsParallelVarLists3
    def sms_parallel_var_list1
      elements[0]
    end

    def t_comma1
      elements[1]
    end

    def sms_parallel_var_list2
      elements[2]
    end

    def t_comma2
      elements[3]
    end

    def sms_parallel_var_list3
      elements[4]
    end
  end

  module SmsParallelVarLists4
    def sms_parallel_var_list1
      elements[0]
    end

    def t_comma1
      elements[1]
    end

    def t_comma2
      elements[2]
    end

    def sms_parallel_var_list2
      elements[3]
    end
  end

  module SmsParallelVarLists5
    def sms_parallel_var_list1
      elements[0]
    end

    def t_comma
      elements[1]
    end

    def sms_parallel_var_list2
      elements[2]
    end
  end

  module SmsParallelVarLists6
    def sms_parallel_var_list
      elements[0]
    end

  end

  def _nt_sms_parallel_var_lists
    start_index = index
    if node_cache[:sms_parallel_var_lists].has_key?(index)
      cached = node_cache[:sms_parallel_var_lists][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_comma
    s1 << r2
    if r2
      r3 = _nt_t_comma
      s1 << r3
      if r3
        r4 = _nt_sms_parallel_var_list
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SMS_Parallel_Var_Lists_001,input, i1...index, s1)
      r1.extend(SmsParallelVarLists0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_t_comma
      s5 << r6
      if r6
        r7 = _nt_sms_parallel_var_list
        s5 << r7
        if r7
          r8 = _nt_t_comma
          s5 << r8
          if r8
            r9 = _nt_sms_parallel_var_list
            s5 << r9
          end
        end
      end
      if s5.last
        r5 = instantiate_node(SMS_Parallel_Var_Lists_011,input, i5...index, s5)
        r5.extend(SmsParallelVarLists1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        i10, s10 = index, []
        r11 = _nt_t_comma
        s10 << r11
        if r11
          r12 = _nt_sms_parallel_var_list
          s10 << r12
        end
        if s10.last
          r10 = instantiate_node(SMS_Parallel_Var_Lists_010,input, i10...index, s10)
          r10.extend(SmsParallelVarLists2)
        else
          @index = i10
          r10 = nil
        end
        if r10
          r0 = r10
        else
          i13, s13 = index, []
          r14 = _nt_sms_parallel_var_list
          s13 << r14
          if r14
            r15 = _nt_t_comma
            s13 << r15
            if r15
              r16 = _nt_sms_parallel_var_list
              s13 << r16
              if r16
                r17 = _nt_t_comma
                s13 << r17
                if r17
                  r18 = _nt_sms_parallel_var_list
                  s13 << r18
                end
              end
            end
          end
          if s13.last
            r13 = instantiate_node(SMS_Parallel_Var_Lists_111,input, i13...index, s13)
            r13.extend(SmsParallelVarLists3)
          else
            @index = i13
            r13 = nil
          end
          if r13
            r0 = r13
          else
            i19, s19 = index, []
            r20 = _nt_sms_parallel_var_list
            s19 << r20
            if r20
              r21 = _nt_t_comma
              s19 << r21
              if r21
                r22 = _nt_t_comma
                s19 << r22
                if r22
                  r23 = _nt_sms_parallel_var_list
                  s19 << r23
                end
              end
            end
            if s19.last
              r19 = instantiate_node(SMS_Parallel_Var_Lists_101,input, i19...index, s19)
              r19.extend(SmsParallelVarLists4)
            else
              @index = i19
              r19 = nil
            end
            if r19
              r0 = r19
            else
              i24, s24 = index, []
              r25 = _nt_sms_parallel_var_list
              s24 << r25
              if r25
                r26 = _nt_t_comma
                s24 << r26
                if r26
                  r27 = _nt_sms_parallel_var_list
                  s24 << r27
                end
              end
              if s24.last
                r24 = instantiate_node(SMS_Parallel_Var_Lists_110,input, i24...index, s24)
                r24.extend(SmsParallelVarLists5)
              else
                @index = i24
                r24 = nil
              end
              if r24
                r0 = r24
              else
                i28, s28 = index, []
                r29 = _nt_sms_parallel_var_list
                s28 << r29
                if r29
                  if has_terminal?("", false, index)
                    r30 = instantiate_node(SyntaxNode,input, index...(index + 0))
                    @index += 0
                  else
                    terminal_parse_failure("")
                    r30 = nil
                  end
                  s28 << r30
                end
                if s28.last
                  r28 = instantiate_node(SMS_Parallel_Var_Lists_100,input, i28...index, s28)
                  r28.extend(SmsParallelVarLists6)
                else
                  @index = i28
                  r28 = nil
                end
                if r28
                  r0 = r28
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end
      end
    end

    node_cache[:sms_parallel_var_lists][start_index] = r0

    r0
  end

  module SmsPassthrough0
    def sms_serial
      elements[0]
    end

  end

  def _nt_sms_passthrough
    start_index = index
    if node_cache[:sms_passthrough].has_key?(index)
      cached = node_cache[:sms_passthrough][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_sms_create_decomp
    if r1
      r0 = r1
    else
      r2 = _nt_sms_ignore_begin
      if r2
        r0 = r2
      else
        r3 = _nt_sms_ignore_end
        if r3
          r0 = r3
        else
          r4 = _nt_sms_reduce
          if r4
            r0 = r4
          else
            i5, s5 = index, []
            r6 = _nt_sms_serial
            s5 << r6
            if r6
              i7 = index
              r8 = lambda { |e| sp_sms_serial }.call(s5)
              if r8
                @index = i7
                r7 = instantiate_node(SyntaxNode,input, index...index)
              else
                r7 = nil
              end
              s5 << r7
            end
            if s5.last
              r5 = instantiate_node(E,input, i5...index, s5)
              r5.extend(SmsPassthrough0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              r0 = r5
            else
              @index = i0
              r0 = nil
            end
          end
        end
      end
    end

    node_cache[:sms_passthrough][start_index] = r0

    r0
  end

  module SmsReduce0
    def sms_sentinel
      elements[0]
    end

    def sms_t_reduce
      elements[1]
    end

    def sms_parenthesized_args
      elements[2]
    end

    def t_newline
      elements[3]
    end
  end

  def _nt_sms_reduce
    start_index = index
    if node_cache[:sms_reduce].has_key?(index)
      cached = node_cache[:sms_reduce][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_reduce
      s0 << r2
      if r2
        r3 = _nt_sms_parenthesized_args
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Reduce,input, i0...index, s0)
      r0.extend(SmsReduce0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_reduce][start_index] = r0

    r0
  end

  def _nt_sms_sentinel
    start_index = index
    if node_cache[:sms_sentinel].has_key?(index)
      cached = node_cache[:sms_sentinel][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("!sms$", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("!sms$")
      r0 = nil
    end

    node_cache[:sms_sentinel][start_index] = r0

    r0
  end

  module SmsSerial0
    def sms_serial_begin
      elements[0]
    end

    def block
      elements[1]
    end

    def sms_serial_end
      elements[2]
    end
  end

  def _nt_sms_serial
    start_index = index
    if node_cache[:sms_serial].has_key?(index)
      cached = node_cache[:sms_serial][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_serial_begin
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
      if r2
        r3 = _nt_sms_serial_end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial,input, i0...index, s0)
      r0.extend(SmsSerial0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial][start_index] = r0

    r0
  end

  module SmsSerialBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_serial
      elements[1]
    end

    def sms_t_begin
      elements[3]
    end

    def t_newline
      elements[4]
    end

  end

  def _nt_sms_serial_begin
    start_index = index
    if node_cache[:sms_serial_begin].has_key?(index)
      cached = node_cache[:sms_serial_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_serial
      s0 << r2
      if r2
        r4 = _nt_sms_parenthesized_args
        if r4
          r3 = r4
        else
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
        if r3
          r5 = _nt_sms_t_begin
          s0 << r5
          if r5
            r6 = _nt_t_newline
            s0 << r6
            if r6
              i7 = index
              r8 = lambda { |e| sp_sms_serial_begin }.call(s0)
              if r8
                @index = i7
                r7 = instantiate_node(SyntaxNode,input, index...index)
              else
                r7 = nil
              end
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial_Begin,input, i0...index, s0)
      r0.extend(SmsSerialBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial_begin][start_index] = r0

    r0
  end

  module SmsSerialEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_serial
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_serial_end
    start_index = index
    if node_cache[:sms_serial_end].has_key?(index)
      cached = node_cache[:sms_serial_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_serial
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_serial_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial_End,input, i0...index, s0)
      r0.extend(SmsSerialEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial_end][start_index] = r0

    r0
  end

  module SmsSetCommunicator0
    def sms_sentinel
      elements[0]
    end

    def sms_t_set_communicator
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def variable_name
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_sms_set_communicator
    start_index = index
    if node_cache[:sms_set_communicator].has_key?(index)
      cached = node_cache[:sms_set_communicator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_set_communicator
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_variable_name
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
            if r5
              r6 = _nt_t_newline
              s0 << r6
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Set_Communicator,input, i0...index, s0)
      r0.extend(SmsSetCommunicator0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_set_communicator][start_index] = r0

    r0
  end

  def _nt_sms_string
    start_index = index
    if node_cache[:sms_string].has_key?(index)
      cached = node_cache[:sms_string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_char_literal_constant_dq
    if r1
      r0 = r1
    else
      r2 = _nt_char_literal_constant_sq
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sms_string][start_index] = r0

    r0
  end

  def _nt_sms_t_barrier
    start_index = index
    if node_cache[:sms_t_barrier].has_key?(index)
      cached = node_cache[:sms_t_barrier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("barrier", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("barrier")
      r0 = nil
    end

    node_cache[:sms_t_barrier][start_index] = r0

    r0
  end

  def _nt_sms_t_begin
    start_index = index
    if node_cache[:sms_t_begin].has_key?(index)
      cached = node_cache[:sms_t_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("begin", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("begin")
      r0 = nil
    end

    node_cache[:sms_t_begin][start_index] = r0

    r0
  end

  def _nt_sms_t_compare_var
    start_index = index
    if node_cache[:sms_t_compare_var].has_key?(index)
      cached = node_cache[:sms_t_compare_var][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("compare_var", false, index)
      r0 = instantiate_node(T,input, index...(index + 11))
      @index += 11
    else
      terminal_parse_failure("compare_var")
      r0 = nil
    end

    node_cache[:sms_t_compare_var][start_index] = r0

    r0
  end

  def _nt_sms_t_create_decomp
    start_index = index
    if node_cache[:sms_t_create_decomp].has_key?(index)
      cached = node_cache[:sms_t_create_decomp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("create_decomp", false, index)
      r0 = instantiate_node(T,input, index...(index + 13))
      @index += 13
    else
      terminal_parse_failure("create_decomp")
      r0 = nil
    end

    node_cache[:sms_t_create_decomp][start_index] = r0

    r0
  end

  def _nt_sms_t_declare_decomp
    start_index = index
    if node_cache[:sms_t_declare_decomp].has_key?(index)
      cached = node_cache[:sms_t_declare_decomp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("declare_decomp", false, index)
      r0 = instantiate_node(T,input, index...(index + 14))
      @index += 14
    else
      terminal_parse_failure("declare_decomp")
      r0 = nil
    end

    node_cache[:sms_t_declare_decomp][start_index] = r0

    r0
  end

  def _nt_sms_t_distribute
    start_index = index
    if node_cache[:sms_t_distribute].has_key?(index)
      cached = node_cache[:sms_t_distribute][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("distribute", false, index)
      r0 = instantiate_node(T,input, index...(index + 10))
      @index += 10
    else
      terminal_parse_failure("distribute")
      r0 = nil
    end

    node_cache[:sms_t_distribute][start_index] = r0

    r0
  end

  def _nt_sms_t_end
    start_index = index
    if node_cache[:sms_t_end].has_key?(index)
      cached = node_cache[:sms_t_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("end", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("end")
      r0 = nil
    end

    node_cache[:sms_t_end][start_index] = r0

    r0
  end

  def _nt_sms_t_exchange
    start_index = index
    if node_cache[:sms_t_exchange].has_key?(index)
      cached = node_cache[:sms_t_exchange][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("exchange", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("exchange")
      r0 = nil
    end

    node_cache[:sms_t_exchange][start_index] = r0

    r0
  end

  def _nt_sms_t_halo_comp
    start_index = index
    if node_cache[:sms_t_halo_comp].has_key?(index)
      cached = node_cache[:sms_t_halo_comp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("halo_comp", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("halo_comp")
      r0 = nil
    end

    node_cache[:sms_t_halo_comp][start_index] = r0

    r0
  end

  def _nt_sms_t_ignore
    start_index = index
    if node_cache[:sms_t_ignore].has_key?(index)
      cached = node_cache[:sms_t_ignore][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("ignore", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("ignore")
      r0 = nil
    end

    node_cache[:sms_t_ignore][start_index] = r0

    r0
  end

  def _nt_sms_t_lbound
    start_index = index
    if node_cache[:sms_t_lbound].has_key?(index)
      cached = node_cache[:sms_t_lbound][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("lbound", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("lbound")
      r0 = nil
    end

    node_cache[:sms_t_lbound][start_index] = r0

    r0
  end

  def _nt_sms_t_parallel
    start_index = index
    if node_cache[:sms_t_parallel].has_key?(index)
      cached = node_cache[:sms_t_parallel][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("parallel", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("parallel")
      r0 = nil
    end

    node_cache[:sms_t_parallel][start_index] = r0

    r0
  end

  def _nt_sms_t_reduce
    start_index = index
    if node_cache[:sms_t_reduce].has_key?(index)
      cached = node_cache[:sms_t_reduce][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("reduce", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("reduce")
      r0 = nil
    end

    node_cache[:sms_t_reduce][start_index] = r0

    r0
  end

  def _nt_sms_t_serial
    start_index = index
    if node_cache[:sms_t_serial].has_key?(index)
      cached = node_cache[:sms_t_serial][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("serial", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("serial")
      r0 = nil
    end

    node_cache[:sms_t_serial][start_index] = r0

    r0
  end

  def _nt_sms_t_set_communicator
    start_index = index
    if node_cache[:sms_t_set_communicator].has_key?(index)
      cached = node_cache[:sms_t_set_communicator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("set_communicator", false, index)
      r0 = instantiate_node(T,input, index...(index + 16))
      @index += 16
    else
      terminal_parse_failure("set_communicator")
      r0 = nil
    end

    node_cache[:sms_t_set_communicator][start_index] = r0

    r0
  end

  def _nt_sms_t_to_local
    start_index = index
    if node_cache[:sms_t_to_local].has_key?(index)
      cached = node_cache[:sms_t_to_local][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("to_local", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("to_local")
      r0 = nil
    end

    node_cache[:sms_t_to_local][start_index] = r0

    r0
  end

  def _nt_sms_t_ubound
    start_index = index
    if node_cache[:sms_t_ubound].has_key?(index)
      cached = node_cache[:sms_t_ubound][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("ubound", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("ubound")
      r0 = nil
    end

    node_cache[:sms_t_ubound][start_index] = r0

    r0
  end

  def _nt_sms_t_unstructured
    start_index = index
    if node_cache[:sms_t_unstructured].has_key?(index)
      cached = node_cache[:sms_t_unstructured][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("unstructured", false, index)
      r0 = instantiate_node(T,input, index...(index + 12))
      @index += 12
    else
      terminal_parse_failure("unstructured")
      r0 = nil
    end

    node_cache[:sms_t_unstructured][start_index] = r0

    r0
  end

  def _nt_sms_t_unstructured_grid
    start_index = index
    if node_cache[:sms_t_unstructured_grid].has_key?(index)
      cached = node_cache[:sms_t_unstructured_grid][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("unstructured_grid", false, index)
      r0 = instantiate_node(T,input, index...(index + 17))
      @index += 17
    else
      terminal_parse_failure("unstructured_grid")
      r0 = nil
    end

    node_cache[:sms_t_unstructured_grid][start_index] = r0

    r0
  end

  module SmsToLocal0
    def sms_to_local_begin
      elements[0]
    end

    def block
      elements[1]
    end

    def sms_to_local_end
      elements[2]
    end
  end

  def _nt_sms_to_local
    start_index = index
    if node_cache[:sms_to_local].has_key?(index)
      cached = node_cache[:sms_to_local][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_to_local_begin
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
      if r2
        r3 = _nt_sms_to_local_end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local,input, i0...index, s0)
      r0.extend(SmsToLocal0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local][start_index] = r0

    r0
  end

  module SmsToLocalBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_to_local
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_decomp_name
      elements[3]
    end

    def t_colon
      elements[4]
    end

    def sms_to_local_lists
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def sms_t_begin
      elements[7]
    end

    def t_newline
      elements[8]
    end

  end

  def _nt_sms_to_local_begin
    start_index = index
    if node_cache[:sms_to_local_begin].has_key?(index)
      cached = node_cache[:sms_to_local_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_to_local
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_decomp_name
          s0 << r4
          if r4
            r5 = _nt_t_colon
            s0 << r5
            if r5
              r6 = _nt_sms_to_local_lists
              s0 << r6
              if r6
                r7 = _nt_t_paren_r
                s0 << r7
                if r7
                  r8 = _nt_sms_t_begin
                  s0 << r8
                  if r8
                    r9 = _nt_t_newline
                    s0 << r9
                    if r9
                      i10 = index
                      r11 = lambda { |e| sp_sms_to_local_begin(e[3],e[5]) }.call(s0)
                      if r11
                        @index = i10
                        r10 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        r10 = nil
                      end
                      s0 << r10
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local_Begin,input, i0...index, s0)
      r0.extend(SmsToLocalBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local_begin][start_index] = r0

    r0
  end

  module SmsToLocalEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_to_local
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_to_local_end
    start_index = index
    if node_cache[:sms_to_local_end].has_key?(index)
      cached = node_cache[:sms_to_local_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_to_local
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_to_local_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local_End,input, i0...index, s0)
      r0.extend(SmsToLocalEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local_end][start_index] = r0

    r0
  end

  def _nt_sms_to_local_key
    start_index = index
    if node_cache[:sms_to_local_key].has_key?(index)
      cached = node_cache[:sms_to_local_key][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_sms_t_lbound
    if r1
      r0 = r1
    else
      r2 = _nt_sms_t_ubound
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sms_to_local_key][start_index] = r0

    r0
  end

  module SmsToLocalList0
    def t_lt
      elements[0]
    end

    def sms_distribute_dim
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def sms_var_list
      elements[3]
    end

    def t_colon
      elements[4]
    end

    def sms_to_local_key
      elements[5]
    end

    def t_gt
      elements[6]
    end
  end

  def _nt_sms_to_local_list
    start_index = index
    if node_cache[:sms_to_local_list].has_key?(index)
      cached = node_cache[:sms_to_local_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_lt
    s0 << r1
    if r1
      r2 = _nt_sms_distribute_dim
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_sms_var_list
          s0 << r4
          if r4
            r5 = _nt_t_colon
            s0 << r5
            if r5
              r6 = _nt_sms_to_local_key
              s0 << r6
              if r6
                r7 = _nt_t_gt
                s0 << r7
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local_List,input, i0...index, s0)
      r0.extend(SmsToLocalList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local_list][start_index] = r0

    r0
  end

  module SmsToLocalLists0
    def t_comma
      elements[0]
    end

    def sms_to_local_list
      elements[1]
    end
  end

  module SmsToLocalLists1
    def t_comma
      elements[0]
    end

    def sms_to_local_list
      elements[1]
    end

  end

  module SmsToLocalLists2
    def sms_to_local_list
      elements[0]
    end

  end

  def _nt_sms_to_local_lists
    start_index = index
    if node_cache[:sms_to_local_lists].has_key?(index)
      cached = node_cache[:sms_to_local_lists][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_to_local_list
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_t_comma
      s3 << r4
      if r4
        r5 = _nt_sms_to_local_list
        s3 << r5
        if r5
          i7, s7 = index, []
          r8 = _nt_t_comma
          s7 << r8
          if r8
            r9 = _nt_sms_to_local_list
            s7 << r9
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(SmsToLocalLists0)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s3 << r6
        end
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(SmsToLocalLists1)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local_Lists,input, i0...index, s0)
      r0.extend(SmsToLocalLists2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local_lists][start_index] = r0

    r0
  end

  module SmsUnstructuredGrid0
    def sms_sentinel
      elements[0]
    end

    def sms_t_unstructured_grid
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def variable_name
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_sms_unstructured_grid
    start_index = index
    if node_cache[:sms_unstructured_grid].has_key?(index)
      cached = node_cache[:sms_unstructured_grid][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_unstructured_grid
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_variable_name
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
            if r5
              r6 = _nt_t_newline
              s0 << r6
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Unstructured_Grid,input, i0...index, s0)
      r0.extend(SmsUnstructuredGrid0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_unstructured_grid][start_index] = r0

    r0
  end

  module SmsVarList0
    def t_comma
      elements[0]
    end

    def variable_name
      elements[1]
    end
  end

  module SmsVarList1
    def variable_name
      elements[0]
    end

  end

  def _nt_sms_var_list
    start_index = index
    if node_cache[:sms_var_list].has_key?(index)
      cached = node_cache[:sms_var_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_variable_name
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_variable_name
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(SmsVarList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_Var_List,input, i0...index, s0)
      r0.extend(SmsVarList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_var_list][start_index] = r0

    r0
  end

  def _nt_use_part
    start_index = index
    if node_cache[:use_part].has_key?(index)
      cached = node_cache[:use_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      i1 = index
      r2 = _nt_use_stmt
      if r2
        r1 = r2
      else
        r3 = _nt_directive
        if r3
          r1 = r3
        else
          r4 = _nt_sms_passthrough
          if r4
            r1 = r4
          else
            @index = i1
            r1 = nil
          end
        end
      end
      if r1
        s0 << r1
      else
        break
      end
    end
    r0 = instantiate_node(Use_Part,input, i0...index, s0)

    node_cache[:use_part][start_index] = r0

    r0
  end

end

class FortranParser < Treetop::Runtime::CompiledParser
  include Fortran
end


# paul.a.madden@noaa.gov
