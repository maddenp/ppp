# Autogenerated from a Treetop grammar. Edits may be lost.


module Fortran
  include Treetop::Runtime

  def root
    @root ||= :declaration_construct
  end

  module DeclarationConstruct0
    def stmt_function_stmt
      elements[0]
    end

  end

  def _nt_declaration_construct
    start_index = index
    if node_cache[:declaration_construct].has_key?(index)
      cached = node_cache[:declaration_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_derived_type_def
    if r1
      r0 = r1
    else
      r2 = _nt_interface_block
      if r2
        r0 = r2
      else
        r3 = _nt_type_declaration_stmt
        if r3
          r0 = r3
        else
          r4 = _nt_specification_stmt
          if r4
            r0 = r4
          else
            r5 = _nt_parameter_stmt
            if r5
              r0 = r5
            else
              r6 = _nt_format_stmt
              if r6
                r0 = r6
              else
                r7 = _nt_entry_stmt
                if r7
                  r0 = r7
                else
                  i8, s8 = index, []
                  r9 = _nt_stmt_function_stmt
                  s8 << r9
                  if r9
                    i10 = index
                    r11 = lambda { |e| sp_is_array?(e[0]) }.call(s8)
                    if r11
                      r10 = nil
                    else
                      @index = i10
                      r10 = instantiate_node(SyntaxNode,input, index...index)
                    end
                    s8 << r10
                  end
                  if s8.last
                    r8 = instantiate_node(NT,input, i8...index, s8)
                    r8.extend(DeclarationConstruct0)
                  else
                    @index = i8
                    r8 = nil
                  end
                  if r8
                    r0 = r8
                  else
                    r12 = _nt_sms_declarative
                    if r12
                      r0 = r12
                    else
                      @index = i0
                      r0 = nil
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:declaration_construct][start_index] = r0

    r0
  end

  module Directive0
    def t_newline
      elements[3]
    end
  end

  def _nt_directive
    start_index = index
    if node_cache[:directive].has_key?(index)
      cached = node_cache[:directive][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    i1 = index
    r2 = _nt_sms_sentinel
    if r2
      r1 = nil
    else
      @index = i1
      r1 = instantiate_node(SyntaxNode,input, index...index)
    end
    s0 << r1
    if r1
      if has_terminal?("!", false, index)
        r3 = instantiate_node(SyntaxNode,input, index...(index + 1))
        @index += 1
      else
        terminal_parse_failure("!")
        r3 = nil
      end
      s0 << r3
      if r3
        s4, i4 = [], index
        loop do
          r5 = _nt_character
          if r5
            s4 << r5
          else
            break
          end
        end
        if s4.empty?
          @index = i4
          r4 = nil
        else
          r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        end
        s0 << r4
        if r4
          r6 = _nt_t_newline
          s0 << r6
        end
      end
    end
    if s0.last
      r0 = instantiate_node(T,input, i0...index, s0)
      r0.extend(Directive0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:directive][start_index] = r0

    r0
  end

  def _nt_executable_construct
    start_index = index
    if node_cache[:executable_construct].has_key?(index)
      cached = node_cache[:executable_construct][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_executable_construct_action_stmt
    if r1
      r0 = r1
    else
      r2 = _nt_case_construct
      if r2
        r0 = r2
      else
        r3 = _nt_do_construct
        if r3
          r0 = r3
        else
          r4 = _nt_if_construct
          if r4
            r0 = r4
          else
            r5 = _nt_where_construct
            if r5
              r0 = r5
            else
              r6 = _nt_sms_executable
              if r6
                r0 = r6
              else
                r7 = _nt_directive
                if r7
                  r0 = r7
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end
      end
    end

    node_cache[:executable_construct][start_index] = r0

    r0
  end

  module ExternalSubprogram0
    def subroutine_subprogram
      elements[0]
    end

  end

  module ExternalSubprogram1
    def function_subprogram
      elements[0]
    end

  end

  def _nt_external_subprogram
    start_index = index
    if node_cache[:external_subprogram].has_key?(index)
      cached = node_cache[:external_subprogram][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_subroutine_subprogram
    s1 << r2
    if r2
      i3 = index
      r4 = lambda { |e| sp_subroutine_subprogram }.call(s1)
      if r4
        @index = i3
        r3 = instantiate_node(SyntaxNode,input, index...index)
      else
        r3 = nil
      end
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(NT,input, i1...index, s1)
      r1.extend(ExternalSubprogram0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_function_subprogram
      s5 << r6
      if r6
        i7 = index
        r8 = lambda { |e| sp_function_subprogram(e[0]) }.call(s5)
        if r8
          @index = i7
          r7 = instantiate_node(SyntaxNode,input, index...index)
        else
          r7 = nil
        end
        s5 << r7
      end
      if s5.last
        r5 = instantiate_node(NT,input, i5...index, s5)
        r5.extend(ExternalSubprogram1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:external_subprogram][start_index] = r0

    r0
  end

  def _nt_implicit_part
    start_index = index
    if node_cache[:implicit_part].has_key?(index)
      cached = node_cache[:implicit_part][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    s0, i0 = [], index
    loop do
      r1 = _nt_implicit_part_stmt
      if r1
        s0 << r1
      else
        break
      end
    end
    if s0.empty?
      @index = i0
      r0 = nil
    else
      r0 = instantiate_node(NT,input, i0...index, s0)
    end

    node_cache[:implicit_part][start_index] = r0

    r0
  end

  module SmsBarrier0
    def sms_sentinel
      elements[0]
    end

    def sms_t_barrier
      elements[1]
    end

    def t_newline
      elements[2]
    end
  end

  def _nt_sms_barrier
    start_index = index
    if node_cache[:sms_barrier].has_key?(index)
      cached = node_cache[:sms_barrier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_barrier
      s0 << r2
      if r2
        r3 = _nt_t_newline
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Barrier,input, i0...index, s0)
      r0.extend(SmsBarrier0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_barrier][start_index] = r0

    r0
  end

  module SmsCompareVar0
    def sms_sentinel
      elements[0]
    end

    def sms_t_compare_var
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def variable
      elements[3]
    end

    def t_comma
      elements[4]
    end

    def sms_string
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def t_newline
      elements[7]
    end
  end

  def _nt_sms_compare_var
    start_index = index
    if node_cache[:sms_compare_var].has_key?(index)
      cached = node_cache[:sms_compare_var][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_compare_var
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_variable
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_sms_string
              s0 << r6
              if r6
                r7 = _nt_t_paren_r
                s0 << r7
                if r7
                  r8 = _nt_t_newline
                  s0 << r8
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Compare_Var,input, i0...index, s0)
      r0.extend(SmsCompareVar0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_compare_var][start_index] = r0

    r0
  end

  module SmsCreateDecomp0
    def sms_sentinel
      elements[0]
    end

    def sms_t_create_decomp
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_decomp_name
      elements[3]
    end

    def t_comma1
      elements[4]
    end

    def sms_create_decomp_global
      elements[5]
    end

    def t_comma2
      elements[6]
    end

    def sms_create_decomp_halo
      elements[7]
    end

    def sms_create_decomp_regionsize
      elements[8]
    end

    def t_paren_r
      elements[9]
    end

    def t_newline
      elements[10]
    end
  end

  def _nt_sms_create_decomp
    start_index = index
    if node_cache[:sms_create_decomp].has_key?(index)
      cached = node_cache[:sms_create_decomp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_create_decomp
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_decomp_name
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_sms_create_decomp_global
              s0 << r6
              if r6
                r7 = _nt_t_comma
                s0 << r7
                if r7
                  r8 = _nt_sms_create_decomp_halo
                  s0 << r8
                  if r8
                    r9 = _nt_sms_create_decomp_regionsize
                    s0 << r9
                    if r9
                      r10 = _nt_t_paren_r
                      s0 << r10
                      if r10
                        r11 = _nt_t_newline
                        s0 << r11
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Create_Decomp,input, i0...index, s0)
      r0.extend(SmsCreateDecomp0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_create_decomp][start_index] = r0

    r0
  end

  module SmsCreateDecompGlobal0
    def t_lt
      elements[0]
    end

    def sms_varlist3d
      elements[1]
    end

    def t_gt
      elements[2]
    end
  end

  def _nt_sms_create_decomp_global
    start_index = index
    if node_cache[:sms_create_decomp_global].has_key?(index)
      cached = node_cache[:sms_create_decomp_global][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_lt
    s0 << r1
    if r1
      r2 = _nt_sms_varlist3d
      s0 << r2
      if r2
        r3 = _nt_t_gt
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Create_Decomp_Global,input, i0...index, s0)
      r0.extend(SmsCreateDecompGlobal0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_create_decomp_global][start_index] = r0

    r0
  end

  module SmsCreateDecompHalo0
    def t_lt
      elements[0]
    end

    def sms_varlist3d
      elements[1]
    end

    def t_gt
      elements[2]
    end
  end

  def _nt_sms_create_decomp_halo
    start_index = index
    if node_cache[:sms_create_decomp_halo].has_key?(index)
      cached = node_cache[:sms_create_decomp_halo][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_lt
    s0 << r1
    if r1
      r2 = _nt_sms_varlist3d
      s0 << r2
      if r2
        r3 = _nt_t_gt
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Create_Decomp_Halo,input, i0...index, s0)
      r0.extend(SmsCreateDecompHalo0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_create_decomp_halo][start_index] = r0

    r0
  end

  module SmsCreateDecompRegionsize0
    def t_colon
      elements[0]
    end

    def sms_t_regionsize
      elements[1]
    end

    def t_equal
      elements[2]
    end

    def variable
      elements[3]
    end
  end

  def _nt_sms_create_decomp_regionsize
    start_index = index
    if node_cache[:sms_create_decomp_regionsize].has_key?(index)
      cached = node_cache[:sms_create_decomp_regionsize][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_colon
    s0 << r1
    if r1
      r2 = _nt_sms_t_regionsize
      s0 << r2
      if r2
        r3 = _nt_t_equal
        s0 << r3
        if r3
          r4 = _nt_variable
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Create_Decomp_Regionsize,input, i0...index, s0)
      r0.extend(SmsCreateDecompRegionsize0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_create_decomp_regionsize][start_index] = r0

    r0
  end

  def _nt_sms_declarative
    start_index = index
    if node_cache[:sms_declarative].has_key?(index)
      cached = node_cache[:sms_declarative][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_sms_declare_decomp
    if r1
      r0 = r1
    else
      r2 = _nt_sms_distribute
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sms_declarative][start_index] = r0

    r0
  end

  module SmsDeclareDecomp0
    def sms_sentinel
      elements[0]
    end

    def sms_t_declare_decomp
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_decomp_name
      elements[3]
    end

    def t_comma
      elements[4]
    end

    def scalar_int_literal_constant
      elements[5]
    end

    def t_paren_r
      elements[7]
    end

    def t_newline
      elements[8]
    end
  end

  def _nt_sms_declare_decomp
    start_index = index
    if node_cache[:sms_declare_decomp].has_key?(index)
      cached = node_cache[:sms_declare_decomp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_declare_decomp
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_decomp_name
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_scalar_int_literal_constant
              s0 << r6
              if r6
                r8 = _nt_sms_declare_decomp_unstructured_option
                if r8
                  r7 = r8
                else
                  r7 = instantiate_node(SyntaxNode,input, index...index)
                end
                s0 << r7
                if r7
                  r9 = _nt_t_paren_r
                  s0 << r9
                  if r9
                    r10 = _nt_t_newline
                    s0 << r10
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Declare_Decomp,input, i0...index, s0)
      r0.extend(SmsDeclareDecomp0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_declare_decomp][start_index] = r0

    r0
  end

  module SmsDeclareDecompUnstructuredOption0
    def t_colon
      elements[0]
    end

    def sms_t_unstructured
      elements[1]
    end
  end

  def _nt_sms_declare_decomp_unstructured_option
    start_index = index
    if node_cache[:sms_declare_decomp_unstructured_option].has_key?(index)
      cached = node_cache[:sms_declare_decomp_unstructured_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_colon
    s0 << r1
    if r1
      r2 = _nt_sms_t_unstructured
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_Declare_Decomp_Unstructured_Option,input, i0...index, s0)
      r0.extend(SmsDeclareDecompUnstructuredOption0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_declare_decomp_unstructured_option][start_index] = r0

    r0
  end

  module SmsDecompName0
    def name
      elements[0]
    end

  end

  def _nt_sms_decomp_name
    start_index = index
    if node_cache[:sms_decomp_name].has_key?(index)
      cached = node_cache[:sms_decomp_name][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_name
    s0 << r1
    if r1
      if has_terminal?("", false, index)
        r2 = instantiate_node(SyntaxNode,input, index...(index + 0))
        @index += 0
      else
        terminal_parse_failure("")
        r2 = nil
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_Decomp_Name,input, i0...index, s0)
      r0.extend(SmsDecompName0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_decomp_name][start_index] = r0

    r0
  end

  module SmsDistribute0
    def sms_distribute_begin
      elements[0]
    end

    def declaration_constructs
      elements[1]
    end

    def sms_distribute_end
      elements[2]
    end
  end

  def _nt_sms_distribute
    start_index = index
    if node_cache[:sms_distribute].has_key?(index)
      cached = node_cache[:sms_distribute][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_distribute_begin
    s0 << r1
    if r1
      r2 = _nt_declaration_constructs
      s0 << r2
      if r2
        r3 = _nt_sms_distribute_end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Distribute,input, i0...index, s0)
      r0.extend(SmsDistribute0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_distribute][start_index] = r0

    r0
  end

  module SmsDistributeBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_distribute
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_decomp_name
      elements[3]
    end

    def t_comma
      elements[4]
    end

    def sms_distribute_dims
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def sms_t_begin
      elements[7]
    end

    def t_newline
      elements[8]
    end

  end

  def _nt_sms_distribute_begin
    start_index = index
    if node_cache[:sms_distribute_begin].has_key?(index)
      cached = node_cache[:sms_distribute_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_distribute
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_decomp_name
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_sms_distribute_dims
              s0 << r6
              if r6
                r7 = _nt_t_paren_r
                s0 << r7
                if r7
                  r8 = _nt_sms_t_begin
                  s0 << r8
                  if r8
                    r9 = _nt_t_newline
                    s0 << r9
                    if r9
                      i10 = index
                      r11 = lambda { |e| sp_sms_distribute_begin(e[3],e[5]) }.call(s0)
                      if r11
                        @index = i10
                        r10 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        r10 = nil
                      end
                      s0 << r10
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Distribute_Begin,input, i0...index, s0)
      r0.extend(SmsDistributeBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_distribute_begin][start_index] = r0

    r0
  end

  def _nt_sms_distribute_dim
    start_index = index
    if node_cache[:sms_distribute_dim].has_key?(index)
      cached = node_cache[:sms_distribute_dim][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    r0 = _nt_scalar_int_literal_constant

    node_cache[:sms_distribute_dim][start_index] = r0

    r0
  end

  module SmsDistributeDims0
    def sms_distribute_dim1
      elements[0]
    end

    def t_comma
      elements[1]
    end

    def sms_distribute_dim2
      elements[2]
    end
  end

  module SmsDistributeDims1
    def t_comma
      elements[0]
    end

    def sms_distribute_dim
      elements[1]
    end
  end

  module SmsDistributeDims2
    def sms_distribute_dim
      elements[0]
    end

  end

  def _nt_sms_distribute_dims
    start_index = index
    if node_cache[:sms_distribute_dims].has_key?(index)
      cached = node_cache[:sms_distribute_dims][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_sms_distribute_dim
    s1 << r2
    if r2
      r3 = _nt_t_comma
      s1 << r3
      if r3
        r4 = _nt_sms_distribute_dim
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SMS_Distribute_Dims_1,input, i1...index, s1)
      r1.extend(SmsDistributeDims0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_t_comma
      s5 << r6
      if r6
        r7 = _nt_sms_distribute_dim
        s5 << r7
      end
      if s5.last
        r5 = instantiate_node(SMS_Distribute_Dims_2,input, i5...index, s5)
        r5.extend(SmsDistributeDims1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        i8, s8 = index, []
        r9 = _nt_sms_distribute_dim
        s8 << r9
        if r9
          if has_terminal?("", false, index)
            r10 = instantiate_node(SyntaxNode,input, index...(index + 0))
            @index += 0
          else
            terminal_parse_failure("")
            r10 = nil
          end
          s8 << r10
        end
        if s8.last
          r8 = instantiate_node(SMS_Distribute_Dims_3,input, i8...index, s8)
          r8.extend(SmsDistributeDims2)
        else
          @index = i8
          r8 = nil
        end
        if r8
          r0 = r8
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:sms_distribute_dims][start_index] = r0

    r0
  end

  module SmsDistributeEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_distribute
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_distribute_end
    start_index = index
    if node_cache[:sms_distribute_end].has_key?(index)
      cached = node_cache[:sms_distribute_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_distribute
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_distribute_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Distribute_End,input, i0...index, s0)
      r0.extend(SmsDistributeEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_distribute_end][start_index] = r0

    r0
  end

  module SmsExchange0
    def t_comma
      elements[0]
    end

    def variable
      elements[1]
    end
  end

  module SmsExchange1
    def sms_sentinel
      elements[0]
    end

    def sms_t_exchange
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def variable
      elements[3]
    end

    def t_paren_r
      elements[5]
    end

    def t_newline
      elements[6]
    end
  end

  def _nt_sms_exchange
    start_index = index
    if node_cache[:sms_exchange].has_key?(index)
      cached = node_cache[:sms_exchange][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_exchange
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_variable
          s0 << r4
          if r4
            s5, i5 = [], index
            loop do
              i6, s6 = index, []
              r7 = _nt_t_comma
              s6 << r7
              if r7
                r8 = _nt_variable
                s6 << r8
              end
              if s6.last
                r6 = instantiate_node(SyntaxNode,input, i6...index, s6)
                r6.extend(SmsExchange0)
              else
                @index = i6
                r6 = nil
              end
              if r6
                s5 << r6
              else
                break
              end
            end
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            s0 << r5
            if r5
              r9 = _nt_t_paren_r
              s0 << r9
              if r9
                r10 = _nt_t_newline
                s0 << r10
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Exchange,input, i0...index, s0)
      r0.extend(SmsExchange1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_exchange][start_index] = r0

    r0
  end

  module SmsExecutable0
    def sms_halo_comp
      elements[0]
    end

  end

  module SmsExecutable1
    def sms_parallel
      elements[0]
    end

  end

  module SmsExecutable2
    def sms_serial
      elements[0]
    end

  end

  module SmsExecutable3
    def sms_to_local
      elements[0]
    end

  end

  def _nt_sms_executable
    start_index = index
    if node_cache[:sms_executable].has_key?(index)
      cached = node_cache[:sms_executable][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_sms_barrier
    if r1
      r0 = r1
    else
      r2 = _nt_sms_compare_var
      if r2
        r0 = r2
      else
        r3 = _nt_sms_create_decomp
        if r3
          r0 = r3
        else
          r4 = _nt_sms_exchange
          if r4
            r0 = r4
          else
            i5, s5 = index, []
            r6 = _nt_sms_halo_comp
            s5 << r6
            if r6
              i7 = index
              r8 = lambda { |e| sp_sms_halo_comp }.call(s5)
              if r8
                @index = i7
                r7 = instantiate_node(SyntaxNode,input, index...index)
              else
                r7 = nil
              end
              s5 << r7
            end
            if s5.last
              r5 = instantiate_node(NT,input, i5...index, s5)
              r5.extend(SmsExecutable0)
            else
              @index = i5
              r5 = nil
            end
            if r5
              r0 = r5
            else
              r9 = _nt_sms_ignore
              if r9
                r0 = r9
              else
                i10, s10 = index, []
                r11 = _nt_sms_parallel
                s10 << r11
                if r11
                  i12 = index
                  r13 = lambda { |e| sp_sms_parallel }.call(s10)
                  if r13
                    @index = i12
                    r12 = instantiate_node(SyntaxNode,input, index...index)
                  else
                    r12 = nil
                  end
                  s10 << r12
                end
                if s10.last
                  r10 = instantiate_node(NT,input, i10...index, s10)
                  r10.extend(SmsExecutable1)
                else
                  @index = i10
                  r10 = nil
                end
                if r10
                  r0 = r10
                else
                  r14 = _nt_sms_reduce
                  if r14
                    r0 = r14
                  else
                    i15, s15 = index, []
                    r16 = _nt_sms_serial
                    s15 << r16
                    if r16
                      i17 = index
                      r18 = lambda { |e| sp_sms_serial }.call(s15)
                      if r18
                        @index = i17
                        r17 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        r17 = nil
                      end
                      s15 << r17
                    end
                    if s15.last
                      r15 = instantiate_node(NT,input, i15...index, s15)
                      r15.extend(SmsExecutable2)
                    else
                      @index = i15
                      r15 = nil
                    end
                    if r15
                      r0 = r15
                    else
                      r19 = _nt_sms_set_communicator
                      if r19
                        r0 = r19
                      else
                        r20 = _nt_sms_start
                        if r20
                          r0 = r20
                        else
                          r21 = _nt_sms_stop
                          if r21
                            r0 = r21
                          else
                            i22, s22 = index, []
                            r23 = _nt_sms_to_local
                            s22 << r23
                            if r23
                              i24 = index
                              r25 = lambda { |e| sp_sms_to_local }.call(s22)
                              if r25
                                @index = i24
                                r24 = instantiate_node(SyntaxNode,input, index...index)
                              else
                                r24 = nil
                              end
                              s22 << r24
                            end
                            if s22.last
                              r22 = instantiate_node(NT,input, i22...index, s22)
                              r22.extend(SmsExecutable3)
                            else
                              @index = i22
                              r22 = nil
                            end
                            if r22
                              r0 = r22
                            else
                              r26 = _nt_sms_unstructured_grid
                              if r26
                                r0 = r26
                              else
                                @index = i0
                                r0 = nil
                              end
                            end
                          end
                        end
                      end
                    end
                  end
                end
              end
            end
          end
        end
      end
    end

    node_cache[:sms_executable][start_index] = r0

    r0
  end

  module SmsHaloComp0
    def sms_halo_comp_begin
      elements[0]
    end

    def block
      elements[1]
    end

    def sms_halo_comp_end
      elements[2]
    end
  end

  def _nt_sms_halo_comp
    start_index = index
    if node_cache[:sms_halo_comp].has_key?(index)
      cached = node_cache[:sms_halo_comp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_halo_comp_begin
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
      if r2
        r3 = _nt_sms_halo_comp_end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp,input, i0...index, s0)
      r0.extend(SmsHaloComp0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp][start_index] = r0

    r0
  end

  module SmsHaloCompBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_halo_comp
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_halo_comp_pairs
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def sms_t_begin
      elements[5]
    end

    def t_newline
      elements[6]
    end

  end

  def _nt_sms_halo_comp_begin
    start_index = index
    if node_cache[:sms_halo_comp_begin].has_key?(index)
      cached = node_cache[:sms_halo_comp_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_halo_comp
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_halo_comp_pairs
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
            if r5
              r6 = _nt_sms_t_begin
              s0 << r6
              if r6
                r7 = _nt_t_newline
                s0 << r7
                if r7
                  i8 = index
                  r9 = lambda { |e| sp_sms_halo_comp_begin(e[3]) }.call(s0)
                  if r9
                    @index = i8
                    r8 = instantiate_node(SyntaxNode,input, index...index)
                  else
                    r8 = nil
                  end
                  s0 << r8
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp_Begin,input, i0...index, s0)
      r0.extend(SmsHaloCompBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp_begin][start_index] = r0

    r0
  end

  module SmsHaloCompEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_halo_comp
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_halo_comp_end
    start_index = index
    if node_cache[:sms_halo_comp_end].has_key?(index)
      cached = node_cache[:sms_halo_comp_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_halo_comp
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_halo_comp_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp_End,input, i0...index, s0)
      r0.extend(SmsHaloCompEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp_end][start_index] = r0

    r0
  end

  module SmsHaloCompPair0
    def t_lt
      elements[0]
    end

    def expr1
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def expr2
      elements[3]
    end

    def t_gt
      elements[4]
    end
  end

  def _nt_sms_halo_comp_pair
    start_index = index
    if node_cache[:sms_halo_comp_pair].has_key?(index)
      cached = node_cache[:sms_halo_comp_pair][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_lt
    s0 << r1
    if r1
      r2 = _nt_expr
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_expr
          s0 << r4
          if r4
            r5 = _nt_t_gt
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp_Pair,input, i0...index, s0)
      r0.extend(SmsHaloCompPair0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp_pair][start_index] = r0

    r0
  end

  module SmsHaloCompPairs0
    def t_comma
      elements[0]
    end

    def sms_halo_comp_pair
      elements[1]
    end
  end

  module SmsHaloCompPairs1
    def t_comma
      elements[0]
    end

    def sms_halo_comp_pair
      elements[1]
    end
  end

  module SmsHaloCompPairs2
    def sms_halo_comp_pair
      elements[0]
    end

  end

  def _nt_sms_halo_comp_pairs
    start_index = index
    if node_cache[:sms_halo_comp_pairs].has_key?(index)
      cached = node_cache[:sms_halo_comp_pairs][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_halo_comp_pair
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_t_comma
      s3 << r4
      if r4
        r5 = _nt_sms_halo_comp_pair
        s3 << r5
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(SmsHaloCompPairs0)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
      if r2
        i7, s7 = index, []
        r8 = _nt_t_comma
        s7 << r8
        if r8
          r9 = _nt_sms_halo_comp_pair
          s7 << r9
        end
        if s7.last
          r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
          r7.extend(SmsHaloCompPairs1)
        else
          @index = i7
          r7 = nil
        end
        if r7
          r6 = r7
        else
          r6 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r6
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Halo_Comp_Pairs,input, i0...index, s0)
      r0.extend(SmsHaloCompPairs2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_halo_comp_pairs][start_index] = r0

    r0
  end

  module SmsIgnore0
    def sms_ignore_begin
      elements[0]
    end

    def block
      elements[1]
    end

    def sms_ignore_end
      elements[2]
    end

  end

  def _nt_sms_ignore
    start_index = index
    if node_cache[:sms_ignore].has_key?(index)
      cached = node_cache[:sms_ignore][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_ignore_begin
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
      if r2
        r3 = _nt_sms_ignore_end
        s0 << r3
        if r3
          i4 = index
          r5 = lambda { |e| sp_sms_ignore }.call(s0)
          if r5
            @index = i4
            r4 = instantiate_node(SyntaxNode,input, index...index)
          else
            r4 = nil
          end
          s0 << r4
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Ignore,input, i0...index, s0)
      r0.extend(SmsIgnore0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_ignore][start_index] = r0

    r0
  end

  module SmsIgnoreBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_ignore
      elements[1]
    end

    def sms_t_begin
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_ignore_begin
    start_index = index
    if node_cache[:sms_ignore_begin].has_key?(index)
      cached = node_cache[:sms_ignore_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_ignore
      s0 << r2
      if r2
        r3 = _nt_sms_t_begin
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_ignore_begin }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Ignore_Begin,input, i0...index, s0)
      r0.extend(SmsIgnoreBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_ignore_begin][start_index] = r0

    r0
  end

  module SmsIgnoreEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_ignore
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_ignore_end
    start_index = index
    if node_cache[:sms_ignore_end].has_key?(index)
      cached = node_cache[:sms_ignore_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_ignore
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_ignore_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Ignore_End,input, i0...index, s0)
      r0.extend(SmsIgnoreEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_ignore_end][start_index] = r0

    r0
  end

  module SmsParallel0
    def sms_parallel_begin
      elements[0]
    end

    def block
      elements[1]
    end

    def sms_parallel_end
      elements[2]
    end
  end

  def _nt_sms_parallel
    start_index = index
    if node_cache[:sms_parallel].has_key?(index)
      cached = node_cache[:sms_parallel][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_parallel_begin
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
      if r2
        r3 = _nt_sms_parallel_end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Parallel,input, i0...index, s0)
      r0.extend(SmsParallel0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_parallel][start_index] = r0

    r0
  end

  module SmsParallelBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_parallel
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_decomp_name
      elements[3]
    end

    def t_comma
      elements[4]
    end

    def sms_parallel_var_lists
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def sms_t_begin
      elements[7]
    end

    def t_newline
      elements[8]
    end

  end

  def _nt_sms_parallel_begin
    start_index = index
    if node_cache[:sms_parallel_begin].has_key?(index)
      cached = node_cache[:sms_parallel_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_parallel
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_decomp_name
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_sms_parallel_var_lists
              s0 << r6
              if r6
                r7 = _nt_t_paren_r
                s0 << r7
                if r7
                  r8 = _nt_sms_t_begin
                  s0 << r8
                  if r8
                    r9 = _nt_t_newline
                    s0 << r9
                    if r9
                      i10 = index
                      r11 = lambda { |e| sp_sms_parallel_begin(e[3],e[5]) }.call(s0)
                      if r11
                        @index = i10
                        r10 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        r10 = nil
                      end
                      s0 << r10
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Parallel_Begin,input, i0...index, s0)
      r0.extend(SmsParallelBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_parallel_begin][start_index] = r0

    r0
  end

  module SmsParallelEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_parallel
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_parallel_end
    start_index = index
    if node_cache[:sms_parallel_end].has_key?(index)
      cached = node_cache[:sms_parallel_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_parallel
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_parallel_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Parallel_End,input, i0...index, s0)
      r0.extend(SmsParallelEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_parallel_end][start_index] = r0

    r0
  end

  module SmsParallelVarList0
    def t_comma
      elements[0]
    end

    def variable_name
      elements[1]
    end
  end

  module SmsParallelVarList1
    def t_lt
      elements[0]
    end

    def variable_name
      elements[1]
    end

    def t_gt
      elements[3]
    end
  end

  module SmsParallelVarList2
    def variable_name
      elements[0]
    end

  end

  def _nt_sms_parallel_var_list
    start_index = index
    if node_cache[:sms_parallel_var_list].has_key?(index)
      cached = node_cache[:sms_parallel_var_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_lt
    s1 << r2
    if r2
      r3 = _nt_variable_name
      s1 << r3
      if r3
        s4, i4 = [], index
        loop do
          i5, s5 = index, []
          r6 = _nt_t_comma
          s5 << r6
          if r6
            r7 = _nt_variable_name
            s5 << r7
          end
          if s5.last
            r5 = instantiate_node(SyntaxNode,input, i5...index, s5)
            r5.extend(SmsParallelVarList0)
          else
            @index = i5
            r5 = nil
          end
          if r5
            s4 << r5
          else
            break
          end
        end
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        s1 << r4
        if r4
          r8 = _nt_t_gt
          s1 << r8
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SMS_Parallel_Var_List_1,input, i1...index, s1)
      r1.extend(SmsParallelVarList1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i9, s9 = index, []
      r10 = _nt_variable_name
      s9 << r10
      if r10
        if has_terminal?("", false, index)
          r11 = instantiate_node(SyntaxNode,input, index...(index + 0))
          @index += 0
        else
          terminal_parse_failure("")
          r11 = nil
        end
        s9 << r11
      end
      if s9.last
        r9 = instantiate_node(SMS_Parallel_Var_List_2,input, i9...index, s9)
        r9.extend(SmsParallelVarList2)
      else
        @index = i9
        r9 = nil
      end
      if r9
        r0 = r9
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sms_parallel_var_list][start_index] = r0

    r0
  end

  module SmsParallelVarLists0
    def t_comma1
      elements[0]
    end

    def t_comma2
      elements[1]
    end

    def sms_parallel_var_list
      elements[2]
    end
  end

  module SmsParallelVarLists1
    def t_comma1
      elements[0]
    end

    def sms_parallel_var_list1
      elements[1]
    end

    def t_comma2
      elements[2]
    end

    def sms_parallel_var_list2
      elements[3]
    end
  end

  module SmsParallelVarLists2
    def t_comma
      elements[0]
    end

    def sms_parallel_var_list
      elements[1]
    end
  end

  module SmsParallelVarLists3
    def sms_parallel_var_list1
      elements[0]
    end

    def t_comma1
      elements[1]
    end

    def sms_parallel_var_list2
      elements[2]
    end

    def t_comma2
      elements[3]
    end

    def sms_parallel_var_list3
      elements[4]
    end
  end

  module SmsParallelVarLists4
    def sms_parallel_var_list1
      elements[0]
    end

    def t_comma1
      elements[1]
    end

    def t_comma2
      elements[2]
    end

    def sms_parallel_var_list2
      elements[3]
    end
  end

  module SmsParallelVarLists5
    def sms_parallel_var_list1
      elements[0]
    end

    def t_comma
      elements[1]
    end

    def sms_parallel_var_list2
      elements[2]
    end
  end

  module SmsParallelVarLists6
    def sms_parallel_var_list
      elements[0]
    end

  end

  def _nt_sms_parallel_var_lists
    start_index = index
    if node_cache[:sms_parallel_var_lists].has_key?(index)
      cached = node_cache[:sms_parallel_var_lists][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_t_comma
    s1 << r2
    if r2
      r3 = _nt_t_comma
      s1 << r3
      if r3
        r4 = _nt_sms_parallel_var_list
        s1 << r4
      end
    end
    if s1.last
      r1 = instantiate_node(SMS_Parallel_Var_Lists_001,input, i1...index, s1)
      r1.extend(SmsParallelVarLists0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i5, s5 = index, []
      r6 = _nt_t_comma
      s5 << r6
      if r6
        r7 = _nt_sms_parallel_var_list
        s5 << r7
        if r7
          r8 = _nt_t_comma
          s5 << r8
          if r8
            r9 = _nt_sms_parallel_var_list
            s5 << r9
          end
        end
      end
      if s5.last
        r5 = instantiate_node(SMS_Parallel_Var_Lists_011,input, i5...index, s5)
        r5.extend(SmsParallelVarLists1)
      else
        @index = i5
        r5 = nil
      end
      if r5
        r0 = r5
      else
        i10, s10 = index, []
        r11 = _nt_t_comma
        s10 << r11
        if r11
          r12 = _nt_sms_parallel_var_list
          s10 << r12
        end
        if s10.last
          r10 = instantiate_node(SMS_Parallel_Var_Lists_010,input, i10...index, s10)
          r10.extend(SmsParallelVarLists2)
        else
          @index = i10
          r10 = nil
        end
        if r10
          r0 = r10
        else
          i13, s13 = index, []
          r14 = _nt_sms_parallel_var_list
          s13 << r14
          if r14
            r15 = _nt_t_comma
            s13 << r15
            if r15
              r16 = _nt_sms_parallel_var_list
              s13 << r16
              if r16
                r17 = _nt_t_comma
                s13 << r17
                if r17
                  r18 = _nt_sms_parallel_var_list
                  s13 << r18
                end
              end
            end
          end
          if s13.last
            r13 = instantiate_node(SMS_Parallel_Var_Lists_111,input, i13...index, s13)
            r13.extend(SmsParallelVarLists3)
          else
            @index = i13
            r13 = nil
          end
          if r13
            r0 = r13
          else
            i19, s19 = index, []
            r20 = _nt_sms_parallel_var_list
            s19 << r20
            if r20
              r21 = _nt_t_comma
              s19 << r21
              if r21
                r22 = _nt_t_comma
                s19 << r22
                if r22
                  r23 = _nt_sms_parallel_var_list
                  s19 << r23
                end
              end
            end
            if s19.last
              r19 = instantiate_node(SMS_Parallel_Var_Lists_101,input, i19...index, s19)
              r19.extend(SmsParallelVarLists4)
            else
              @index = i19
              r19 = nil
            end
            if r19
              r0 = r19
            else
              i24, s24 = index, []
              r25 = _nt_sms_parallel_var_list
              s24 << r25
              if r25
                r26 = _nt_t_comma
                s24 << r26
                if r26
                  r27 = _nt_sms_parallel_var_list
                  s24 << r27
                end
              end
              if s24.last
                r24 = instantiate_node(SMS_Parallel_Var_Lists_110,input, i24...index, s24)
                r24.extend(SmsParallelVarLists5)
              else
                @index = i24
                r24 = nil
              end
              if r24
                r0 = r24
              else
                i28, s28 = index, []
                r29 = _nt_sms_parallel_var_list
                s28 << r29
                if r29
                  if has_terminal?("", false, index)
                    r30 = instantiate_node(SyntaxNode,input, index...(index + 0))
                    @index += 0
                  else
                    terminal_parse_failure("")
                    r30 = nil
                  end
                  s28 << r30
                end
                if s28.last
                  r28 = instantiate_node(SMS_Parallel_Var_Lists_100,input, i28...index, s28)
                  r28.extend(SmsParallelVarLists6)
                else
                  @index = i28
                  r28 = nil
                end
                if r28
                  r0 = r28
                else
                  @index = i0
                  r0 = nil
                end
              end
            end
          end
        end
      end
    end

    node_cache[:sms_parallel_var_lists][start_index] = r0

    r0
  end

  module SmsReduce0
    def sms_sentinel
      elements[0]
    end

    def sms_t_reduce
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_reduce_varlist
      elements[3]
    end

    def t_comma
      elements[4]
    end

    def sms_reduce_op
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def t_newline
      elements[7]
    end
  end

  def _nt_sms_reduce
    start_index = index
    if node_cache[:sms_reduce].has_key?(index)
      cached = node_cache[:sms_reduce][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_reduce
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_reduce_varlist
          s0 << r4
          if r4
            r5 = _nt_t_comma
            s0 << r5
            if r5
              r6 = _nt_sms_reduce_op
              s0 << r6
              if r6
                r7 = _nt_t_paren_r
                s0 << r7
                if r7
                  r8 = _nt_t_newline
                  s0 << r8
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Reduce,input, i0...index, s0)
      r0.extend(SmsReduce0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_reduce][start_index] = r0

    r0
  end

  def _nt_sms_reduce_op
    start_index = index
    if node_cache[:sms_reduce_op].has_key?(index)
      cached = node_cache[:sms_reduce_op][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_sms_t_max
    if r1
      r0 = r1
    else
      r2 = _nt_sms_t_min
      if r2
        r0 = r2
      else
        r3 = _nt_sms_t_sum
        if r3
          r0 = r3
        else
          @index = i0
          r0 = nil
        end
      end
    end

    node_cache[:sms_reduce_op][start_index] = r0

    r0
  end

  module SmsReduceVarlist0
    def t_comma
      elements[0]
    end

    def variable
      elements[1]
    end

  end

  module SmsReduceVarlist1
    def variable
      elements[0]
    end

  end

  def _nt_sms_reduce_varlist
    start_index = index
    if node_cache[:sms_reduce_varlist].has_key?(index)
      cached = node_cache[:sms_reduce_varlist][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_variable
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_variable
          s3 << r5
          if r5
            i6 = index
            r7 = _nt_t_paren_r
            if r7
              r6 = nil
            else
              @index = i6
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r6
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(SmsReduceVarlist0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_Reduce_Varlist,input, i0...index, s0)
      r0.extend(SmsReduceVarlist1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_reduce_varlist][start_index] = r0

    r0
  end

  def _nt_sms_sentinel
    start_index = index
    if node_cache[:sms_sentinel].has_key?(index)
      cached = node_cache[:sms_sentinel][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("!sms$", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("!sms$")
      r0 = nil
    end

    node_cache[:sms_sentinel][start_index] = r0

    r0
  end

  module SmsSerial0
    def sms_serial_begin
      elements[0]
    end

    def block
      elements[1]
    end

    def sms_serial_end
      elements[2]
    end
  end

  def _nt_sms_serial
    start_index = index
    if node_cache[:sms_serial].has_key?(index)
      cached = node_cache[:sms_serial][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_serial_begin
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
      if r2
        r3 = _nt_sms_serial_end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial,input, i0...index, s0)
      r0.extend(SmsSerial0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial][start_index] = r0

    r0
  end

  module SmsSerialBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_serial
      elements[1]
    end

    def sms_t_begin
      elements[3]
    end

    def t_newline
      elements[4]
    end

  end

  def _nt_sms_serial_begin
    start_index = index
    if node_cache[:sms_serial_begin].has_key?(index)
      cached = node_cache[:sms_serial_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_serial
      s0 << r2
      if r2
        r4 = _nt_sms_serial_control
        if r4
          r3 = r4
        else
          r3 = instantiate_node(SyntaxNode,input, index...index)
        end
        s0 << r3
        if r3
          r5 = _nt_sms_t_begin
          s0 << r5
          if r5
            r6 = _nt_t_newline
            s0 << r6
            if r6
              i7 = index
              r8 = lambda { |e| sp_sms_serial_begin }.call(s0)
              if r8
                @index = i7
                r7 = instantiate_node(SyntaxNode,input, index...index)
              else
                r7 = nil
              end
              s0 << r7
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial_Begin,input, i0...index, s0)
      r0.extend(SmsSerialBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial_begin][start_index] = r0

    r0
  end

  module SmsSerialControl0
    def t_paren_l
      elements[0]
    end

    def sms_serial_control_option
      elements[1]
    end

    def t_paren_r
      elements[2]
    end
  end

  def _nt_sms_serial_control
    start_index = index
    if node_cache[:sms_serial_control].has_key?(index)
      cached = node_cache[:sms_serial_control][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_paren_l
    s0 << r1
    if r1
      r2 = _nt_sms_serial_control_option
      s0 << r2
      if r2
        r3 = _nt_t_paren_r
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial_Control,input, i0...index, s0)
      r0.extend(SmsSerialControl0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial_control][start_index] = r0

    r0
  end

  module SmsSerialControlOption0
    def t_colon
      elements[0]
    end

    def sms_serial_default
      elements[1]
    end
  end

  module SmsSerialControlOption1
    def sms_serial_intent_lists
      elements[0]
    end

  end

  module SmsSerialControlOption2
    def sms_serial_default
      elements[0]
    end

  end

  def _nt_sms_serial_control_option
    start_index = index
    if node_cache[:sms_serial_control_option].has_key?(index)
      cached = node_cache[:sms_serial_control_option][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_sms_serial_intent_lists
    s1 << r2
    if r2
      i4, s4 = index, []
      r5 = _nt_t_colon
      s4 << r5
      if r5
        r6 = _nt_sms_serial_default
        s4 << r6
      end
      if s4.last
        r4 = instantiate_node(SyntaxNode,input, i4...index, s4)
        r4.extend(SmsSerialControlOption0)
      else
        @index = i4
        r4 = nil
      end
      if r4
        r3 = r4
      else
        r3 = instantiate_node(SyntaxNode,input, index...index)
      end
      s1 << r3
    end
    if s1.last
      r1 = instantiate_node(SMS_Serial_Control_Option_1,input, i1...index, s1)
      r1.extend(SmsSerialControlOption1)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i7, s7 = index, []
      r8 = _nt_sms_serial_default
      s7 << r8
      if r8
        if has_terminal?("", false, index)
          r9 = instantiate_node(SyntaxNode,input, index...(index + 0))
          @index += 0
        else
          terminal_parse_failure("")
          r9 = nil
        end
        s7 << r9
      end
      if s7.last
        r7 = instantiate_node(SMS_Serial_Control_Option_2,input, i7...index, s7)
        r7.extend(SmsSerialControlOption2)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r0 = r7
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sms_serial_control_option][start_index] = r0

    r0
  end

  module SmsSerialDefault0
    def sms_t_default
      elements[0]
    end

    def t_equal
      elements[1]
    end

    def sms_serial_intent
      elements[2]
    end
  end

  def _nt_sms_serial_default
    start_index = index
    if node_cache[:sms_serial_default].has_key?(index)
      cached = node_cache[:sms_serial_default][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_t_default
    s0 << r1
    if r1
      r2 = _nt_t_equal
      s0 << r2
      if r2
        r3 = _nt_sms_serial_intent
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial_Default,input, i0...index, s0)
      r0.extend(SmsSerialDefault0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial_default][start_index] = r0

    r0
  end

  module SmsSerialEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_serial
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_serial_end
    start_index = index
    if node_cache[:sms_serial_end].has_key?(index)
      cached = node_cache[:sms_serial_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_serial
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_serial_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial_End,input, i0...index, s0)
      r0.extend(SmsSerialEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial_end][start_index] = r0

    r0
  end

  def _nt_sms_serial_intent
    start_index = index
    if node_cache[:sms_serial_intent].has_key?(index)
      cached = node_cache[:sms_serial_intent][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_sms_t_ignore
    if r1
      r0 = r1
    else
      r2 = _nt_sms_t_inout
      if r2
        r0 = r2
      else
        r3 = _nt_sms_t_in
        if r3
          r0 = r3
        else
          r4 = _nt_sms_t_out
          if r4
            r0 = r4
          else
            @index = i0
            r0 = nil
          end
        end
      end
    end

    node_cache[:sms_serial_intent][start_index] = r0

    r0
  end

  module SmsSerialIntentList0
    def t_lt
      elements[0]
    end

    def sms_serial_varlist
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def sms_serial_intent
      elements[3]
    end

    def t_gt
      elements[4]
    end
  end

  def _nt_sms_serial_intent_list
    start_index = index
    if node_cache[:sms_serial_intent_list].has_key?(index)
      cached = node_cache[:sms_serial_intent_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_lt
    s0 << r1
    if r1
      r2 = _nt_sms_serial_varlist
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_sms_serial_intent
          s0 << r4
          if r4
            r5 = _nt_t_gt
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial_Intent_List,input, i0...index, s0)
      r0.extend(SmsSerialIntentList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial_intent_list][start_index] = r0

    r0
  end

  module SmsSerialIntentLists0
    def t_comma
      elements[0]
    end

    def sms_serial_intent_list
      elements[1]
    end
  end

  module SmsSerialIntentLists1
    def sms_serial_intent_list
      elements[0]
    end

  end

  def _nt_sms_serial_intent_lists
    start_index = index
    if node_cache[:sms_serial_intent_lists].has_key?(index)
      cached = node_cache[:sms_serial_intent_lists][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_serial_intent_list
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_sms_serial_intent_list
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(SmsSerialIntentLists0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial_Intent_Lists,input, i0...index, s0)
      r0.extend(SmsSerialIntentLists1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial_intent_lists][start_index] = r0

    r0
  end

  module SmsSerialVarlist0
    def t_comma
      elements[0]
    end

    def variable
      elements[1]
    end

  end

  module SmsSerialVarlist1
    def variable
      elements[0]
    end

  end

  def _nt_sms_serial_varlist
    start_index = index
    if node_cache[:sms_serial_varlist].has_key?(index)
      cached = node_cache[:sms_serial_varlist][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_variable
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_variable
          s3 << r5
          if r5
            i6 = index
            r7 = _nt_t_gt
            if r7
              r6 = nil
            else
              @index = i6
              r6 = instantiate_node(SyntaxNode,input, index...index)
            end
            s3 << r6
          end
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(SmsSerialVarlist0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_Serial_Varlist,input, i0...index, s0)
      r0.extend(SmsSerialVarlist1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_serial_varlist][start_index] = r0

    r0
  end

  module SmsSetCommunicator0
    def sms_sentinel
      elements[0]
    end

    def sms_t_set_communicator
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def variable_name
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_sms_set_communicator
    start_index = index
    if node_cache[:sms_set_communicator].has_key?(index)
      cached = node_cache[:sms_set_communicator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_set_communicator
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_variable_name
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
            if r5
              r6 = _nt_t_newline
              s0 << r6
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Set_Communicator,input, i0...index, s0)
      r0.extend(SmsSetCommunicator0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_set_communicator][start_index] = r0

    r0
  end

  module SmsStart0
    def sms_sentinel
      elements[0]
    end

    def sms_t_start
      elements[1]
    end

    def t_newline
      elements[2]
    end
  end

  def _nt_sms_start
    start_index = index
    if node_cache[:sms_start].has_key?(index)
      cached = node_cache[:sms_start][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_start
      s0 << r2
      if r2
        r3 = _nt_t_newline
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Start,input, i0...index, s0)
      r0.extend(SmsStart0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_start][start_index] = r0

    r0
  end

  module SmsStop0
    def sms_sentinel
      elements[0]
    end

    def sms_t_stop
      elements[1]
    end

    def t_newline
      elements[2]
    end
  end

  def _nt_sms_stop
    start_index = index
    if node_cache[:sms_stop].has_key?(index)
      cached = node_cache[:sms_stop][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_stop
      s0 << r2
      if r2
        r3 = _nt_t_newline
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Stop,input, i0...index, s0)
      r0.extend(SmsStop0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_stop][start_index] = r0

    r0
  end

  def _nt_sms_string
    start_index = index
    if node_cache[:sms_string].has_key?(index)
      cached = node_cache[:sms_string][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_char_literal_constant_dq
    if r1
      r0 = r1
    else
      r2 = _nt_char_literal_constant_sq
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sms_string][start_index] = r0

    r0
  end

  def _nt_sms_t_barrier
    start_index = index
    if node_cache[:sms_t_barrier].has_key?(index)
      cached = node_cache[:sms_t_barrier][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("barrier", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("barrier")
      r0 = nil
    end

    node_cache[:sms_t_barrier][start_index] = r0

    r0
  end

  def _nt_sms_t_begin
    start_index = index
    if node_cache[:sms_t_begin].has_key?(index)
      cached = node_cache[:sms_t_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("begin", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("begin")
      r0 = nil
    end

    node_cache[:sms_t_begin][start_index] = r0

    r0
  end

  def _nt_sms_t_compare_var
    start_index = index
    if node_cache[:sms_t_compare_var].has_key?(index)
      cached = node_cache[:sms_t_compare_var][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("compare_var", false, index)
      r0 = instantiate_node(T,input, index...(index + 11))
      @index += 11
    else
      terminal_parse_failure("compare_var")
      r0 = nil
    end

    node_cache[:sms_t_compare_var][start_index] = r0

    r0
  end

  def _nt_sms_t_create_decomp
    start_index = index
    if node_cache[:sms_t_create_decomp].has_key?(index)
      cached = node_cache[:sms_t_create_decomp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("create_decomp", false, index)
      r0 = instantiate_node(T,input, index...(index + 13))
      @index += 13
    else
      terminal_parse_failure("create_decomp")
      r0 = nil
    end

    node_cache[:sms_t_create_decomp][start_index] = r0

    r0
  end

  def _nt_sms_t_declare_decomp
    start_index = index
    if node_cache[:sms_t_declare_decomp].has_key?(index)
      cached = node_cache[:sms_t_declare_decomp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("declare_decomp", false, index)
      r0 = instantiate_node(T,input, index...(index + 14))
      @index += 14
    else
      terminal_parse_failure("declare_decomp")
      r0 = nil
    end

    node_cache[:sms_t_declare_decomp][start_index] = r0

    r0
  end

  def _nt_sms_t_default
    start_index = index
    if node_cache[:sms_t_default].has_key?(index)
      cached = node_cache[:sms_t_default][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("default", false, index)
      r0 = instantiate_node(T,input, index...(index + 7))
      @index += 7
    else
      terminal_parse_failure("default")
      r0 = nil
    end

    node_cache[:sms_t_default][start_index] = r0

    r0
  end

  def _nt_sms_t_distribute
    start_index = index
    if node_cache[:sms_t_distribute].has_key?(index)
      cached = node_cache[:sms_t_distribute][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("distribute", false, index)
      r0 = instantiate_node(T,input, index...(index + 10))
      @index += 10
    else
      terminal_parse_failure("distribute")
      r0 = nil
    end

    node_cache[:sms_t_distribute][start_index] = r0

    r0
  end

  def _nt_sms_t_end
    start_index = index
    if node_cache[:sms_t_end].has_key?(index)
      cached = node_cache[:sms_t_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("end", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("end")
      r0 = nil
    end

    node_cache[:sms_t_end][start_index] = r0

    r0
  end

  def _nt_sms_t_exchange
    start_index = index
    if node_cache[:sms_t_exchange].has_key?(index)
      cached = node_cache[:sms_t_exchange][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("exchange", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("exchange")
      r0 = nil
    end

    node_cache[:sms_t_exchange][start_index] = r0

    r0
  end

  def _nt_sms_t_halo_comp
    start_index = index
    if node_cache[:sms_t_halo_comp].has_key?(index)
      cached = node_cache[:sms_t_halo_comp][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("halo_comp", false, index)
      r0 = instantiate_node(T,input, index...(index + 9))
      @index += 9
    else
      terminal_parse_failure("halo_comp")
      r0 = nil
    end

    node_cache[:sms_t_halo_comp][start_index] = r0

    r0
  end

  def _nt_sms_t_ignore
    start_index = index
    if node_cache[:sms_t_ignore].has_key?(index)
      cached = node_cache[:sms_t_ignore][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("ignore", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("ignore")
      r0 = nil
    end

    node_cache[:sms_t_ignore][start_index] = r0

    r0
  end

  def _nt_sms_t_in
    start_index = index
    if node_cache[:sms_t_in].has_key?(index)
      cached = node_cache[:sms_t_in][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("in", false, index)
      r0 = instantiate_node(T,input, index...(index + 2))
      @index += 2
    else
      terminal_parse_failure("in")
      r0 = nil
    end

    node_cache[:sms_t_in][start_index] = r0

    r0
  end

  def _nt_sms_t_inout
    start_index = index
    if node_cache[:sms_t_inout].has_key?(index)
      cached = node_cache[:sms_t_inout][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("inout", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("inout")
      r0 = nil
    end

    node_cache[:sms_t_inout][start_index] = r0

    r0
  end

  def _nt_sms_t_lbound
    start_index = index
    if node_cache[:sms_t_lbound].has_key?(index)
      cached = node_cache[:sms_t_lbound][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("lbound", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("lbound")
      r0 = nil
    end

    node_cache[:sms_t_lbound][start_index] = r0

    r0
  end

  def _nt_sms_t_max
    start_index = index
    if node_cache[:sms_t_max].has_key?(index)
      cached = node_cache[:sms_t_max][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("max", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("max")
      r0 = nil
    end

    node_cache[:sms_t_max][start_index] = r0

    r0
  end

  def _nt_sms_t_min
    start_index = index
    if node_cache[:sms_t_min].has_key?(index)
      cached = node_cache[:sms_t_min][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("min", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("min")
      r0 = nil
    end

    node_cache[:sms_t_min][start_index] = r0

    r0
  end

  def _nt_sms_t_out
    start_index = index
    if node_cache[:sms_t_out].has_key?(index)
      cached = node_cache[:sms_t_out][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("out", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("out")
      r0 = nil
    end

    node_cache[:sms_t_out][start_index] = r0

    r0
  end

  def _nt_sms_t_parallel
    start_index = index
    if node_cache[:sms_t_parallel].has_key?(index)
      cached = node_cache[:sms_t_parallel][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("parallel", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("parallel")
      r0 = nil
    end

    node_cache[:sms_t_parallel][start_index] = r0

    r0
  end

  def _nt_sms_t_reduce
    start_index = index
    if node_cache[:sms_t_reduce].has_key?(index)
      cached = node_cache[:sms_t_reduce][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("reduce", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("reduce")
      r0 = nil
    end

    node_cache[:sms_t_reduce][start_index] = r0

    r0
  end

  def _nt_sms_t_regionsize
    start_index = index
    if node_cache[:sms_t_regionsize].has_key?(index)
      cached = node_cache[:sms_t_regionsize][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("regionsize", false, index)
      r0 = instantiate_node(T,input, index...(index + 10))
      @index += 10
    else
      terminal_parse_failure("regionsize")
      r0 = nil
    end

    node_cache[:sms_t_regionsize][start_index] = r0

    r0
  end

  def _nt_sms_t_serial
    start_index = index
    if node_cache[:sms_t_serial].has_key?(index)
      cached = node_cache[:sms_t_serial][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("serial", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("serial")
      r0 = nil
    end

    node_cache[:sms_t_serial][start_index] = r0

    r0
  end

  def _nt_sms_t_set_communicator
    start_index = index
    if node_cache[:sms_t_set_communicator].has_key?(index)
      cached = node_cache[:sms_t_set_communicator][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("set_communicator", false, index)
      r0 = instantiate_node(T,input, index...(index + 16))
      @index += 16
    else
      terminal_parse_failure("set_communicator")
      r0 = nil
    end

    node_cache[:sms_t_set_communicator][start_index] = r0

    r0
  end

  def _nt_sms_t_start
    start_index = index
    if node_cache[:sms_t_start].has_key?(index)
      cached = node_cache[:sms_t_start][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("start", false, index)
      r0 = instantiate_node(T,input, index...(index + 5))
      @index += 5
    else
      terminal_parse_failure("start")
      r0 = nil
    end

    node_cache[:sms_t_start][start_index] = r0

    r0
  end

  def _nt_sms_t_stop
    start_index = index
    if node_cache[:sms_t_stop].has_key?(index)
      cached = node_cache[:sms_t_stop][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("stop", false, index)
      r0 = instantiate_node(T,input, index...(index + 4))
      @index += 4
    else
      terminal_parse_failure("stop")
      r0 = nil
    end

    node_cache[:sms_t_stop][start_index] = r0

    r0
  end

  def _nt_sms_t_sum
    start_index = index
    if node_cache[:sms_t_sum].has_key?(index)
      cached = node_cache[:sms_t_sum][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("sum", false, index)
      r0 = instantiate_node(T,input, index...(index + 3))
      @index += 3
    else
      terminal_parse_failure("sum")
      r0 = nil
    end

    node_cache[:sms_t_sum][start_index] = r0

    r0
  end

  def _nt_sms_t_to_local
    start_index = index
    if node_cache[:sms_t_to_local].has_key?(index)
      cached = node_cache[:sms_t_to_local][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("to_local", false, index)
      r0 = instantiate_node(T,input, index...(index + 8))
      @index += 8
    else
      terminal_parse_failure("to_local")
      r0 = nil
    end

    node_cache[:sms_t_to_local][start_index] = r0

    r0
  end

  def _nt_sms_t_ubound
    start_index = index
    if node_cache[:sms_t_ubound].has_key?(index)
      cached = node_cache[:sms_t_ubound][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("ubound", false, index)
      r0 = instantiate_node(T,input, index...(index + 6))
      @index += 6
    else
      terminal_parse_failure("ubound")
      r0 = nil
    end

    node_cache[:sms_t_ubound][start_index] = r0

    r0
  end

  def _nt_sms_t_unstructured
    start_index = index
    if node_cache[:sms_t_unstructured].has_key?(index)
      cached = node_cache[:sms_t_unstructured][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("unstructured", false, index)
      r0 = instantiate_node(T,input, index...(index + 12))
      @index += 12
    else
      terminal_parse_failure("unstructured")
      r0 = nil
    end

    node_cache[:sms_t_unstructured][start_index] = r0

    r0
  end

  def _nt_sms_t_unstructured_grid
    start_index = index
    if node_cache[:sms_t_unstructured_grid].has_key?(index)
      cached = node_cache[:sms_t_unstructured_grid][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    if has_terminal?("unstructured_grid", false, index)
      r0 = instantiate_node(T,input, index...(index + 17))
      @index += 17
    else
      terminal_parse_failure("unstructured_grid")
      r0 = nil
    end

    node_cache[:sms_t_unstructured_grid][start_index] = r0

    r0
  end

  module SmsToLocal0
    def sms_to_local_begin
      elements[0]
    end

    def block
      elements[1]
    end

    def sms_to_local_end
      elements[2]
    end
  end

  def _nt_sms_to_local
    start_index = index
    if node_cache[:sms_to_local].has_key?(index)
      cached = node_cache[:sms_to_local][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_to_local_begin
    s0 << r1
    if r1
      r2 = _nt_block
      s0 << r2
      if r2
        r3 = _nt_sms_to_local_end
        s0 << r3
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local,input, i0...index, s0)
      r0.extend(SmsToLocal0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local][start_index] = r0

    r0
  end

  module SmsToLocalBegin0
    def sms_sentinel
      elements[0]
    end

    def sms_t_to_local
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def sms_decomp_name
      elements[3]
    end

    def t_colon
      elements[4]
    end

    def sms_to_local_lists
      elements[5]
    end

    def t_paren_r
      elements[6]
    end

    def sms_t_begin
      elements[7]
    end

    def t_newline
      elements[8]
    end

  end

  def _nt_sms_to_local_begin
    start_index = index
    if node_cache[:sms_to_local_begin].has_key?(index)
      cached = node_cache[:sms_to_local_begin][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_to_local
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_sms_decomp_name
          s0 << r4
          if r4
            r5 = _nt_t_colon
            s0 << r5
            if r5
              r6 = _nt_sms_to_local_lists
              s0 << r6
              if r6
                r7 = _nt_t_paren_r
                s0 << r7
                if r7
                  r8 = _nt_sms_t_begin
                  s0 << r8
                  if r8
                    r9 = _nt_t_newline
                    s0 << r9
                    if r9
                      i10 = index
                      r11 = lambda { |e| sp_sms_to_local_begin(e[3],e[5]) }.call(s0)
                      if r11
                        @index = i10
                        r10 = instantiate_node(SyntaxNode,input, index...index)
                      else
                        r10 = nil
                      end
                      s0 << r10
                    end
                  end
                end
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local_Begin,input, i0...index, s0)
      r0.extend(SmsToLocalBegin0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local_begin][start_index] = r0

    r0
  end

  module SmsToLocalEnd0
    def sms_sentinel
      elements[0]
    end

    def sms_t_to_local
      elements[1]
    end

    def sms_t_end
      elements[2]
    end

    def t_newline
      elements[3]
    end

  end

  def _nt_sms_to_local_end
    start_index = index
    if node_cache[:sms_to_local_end].has_key?(index)
      cached = node_cache[:sms_to_local_end][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_to_local
      s0 << r2
      if r2
        r3 = _nt_sms_t_end
        s0 << r3
        if r3
          r4 = _nt_t_newline
          s0 << r4
          if r4
            i5 = index
            r6 = lambda { |e| sp_sms_to_local_end }.call(s0)
            if r6
              @index = i5
              r5 = instantiate_node(SyntaxNode,input, index...index)
            else
              r5 = nil
            end
            s0 << r5
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local_End,input, i0...index, s0)
      r0.extend(SmsToLocalEnd0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local_end][start_index] = r0

    r0
  end

  def _nt_sms_to_local_key
    start_index = index
    if node_cache[:sms_to_local_key].has_key?(index)
      cached = node_cache[:sms_to_local_key][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    r1 = _nt_sms_t_lbound
    if r1
      r0 = r1
    else
      r2 = _nt_sms_t_ubound
      if r2
        r0 = r2
      else
        @index = i0
        r0 = nil
      end
    end

    node_cache[:sms_to_local_key][start_index] = r0

    r0
  end

  module SmsToLocalList0
    def t_lt
      elements[0]
    end

    def sms_distribute_dim
      elements[1]
    end

    def t_comma
      elements[2]
    end

    def sms_var_list
      elements[3]
    end

    def t_colon
      elements[4]
    end

    def sms_to_local_key
      elements[5]
    end

    def t_gt
      elements[6]
    end
  end

  def _nt_sms_to_local_list
    start_index = index
    if node_cache[:sms_to_local_list].has_key?(index)
      cached = node_cache[:sms_to_local_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_t_lt
    s0 << r1
    if r1
      r2 = _nt_sms_distribute_dim
      s0 << r2
      if r2
        r3 = _nt_t_comma
        s0 << r3
        if r3
          r4 = _nt_sms_var_list
          s0 << r4
          if r4
            r5 = _nt_t_colon
            s0 << r5
            if r5
              r6 = _nt_sms_to_local_key
              s0 << r6
              if r6
                r7 = _nt_t_gt
                s0 << r7
              end
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local_List,input, i0...index, s0)
      r0.extend(SmsToLocalList0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local_list][start_index] = r0

    r0
  end

  module SmsToLocalLists0
    def t_comma
      elements[0]
    end

    def sms_to_local_list
      elements[1]
    end
  end

  module SmsToLocalLists1
    def t_comma
      elements[0]
    end

    def sms_to_local_list
      elements[1]
    end

  end

  module SmsToLocalLists2
    def sms_to_local_list
      elements[0]
    end

  end

  def _nt_sms_to_local_lists
    start_index = index
    if node_cache[:sms_to_local_lists].has_key?(index)
      cached = node_cache[:sms_to_local_lists][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_to_local_list
    s0 << r1
    if r1
      i3, s3 = index, []
      r4 = _nt_t_comma
      s3 << r4
      if r4
        r5 = _nt_sms_to_local_list
        s3 << r5
        if r5
          i7, s7 = index, []
          r8 = _nt_t_comma
          s7 << r8
          if r8
            r9 = _nt_sms_to_local_list
            s7 << r9
          end
          if s7.last
            r7 = instantiate_node(SyntaxNode,input, i7...index, s7)
            r7.extend(SmsToLocalLists0)
          else
            @index = i7
            r7 = nil
          end
          if r7
            r6 = r7
          else
            r6 = instantiate_node(SyntaxNode,input, index...index)
          end
          s3 << r6
        end
      end
      if s3.last
        r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
        r3.extend(SmsToLocalLists1)
      else
        @index = i3
        r3 = nil
      end
      if r3
        r2 = r3
      else
        r2 = instantiate_node(SyntaxNode,input, index...index)
      end
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_To_Local_Lists,input, i0...index, s0)
      r0.extend(SmsToLocalLists2)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_to_local_lists][start_index] = r0

    r0
  end

  module SmsUnstructuredGrid0
    def sms_sentinel
      elements[0]
    end

    def sms_t_unstructured_grid
      elements[1]
    end

    def t_paren_l
      elements[2]
    end

    def variable_name
      elements[3]
    end

    def t_paren_r
      elements[4]
    end

    def t_newline
      elements[5]
    end
  end

  def _nt_sms_unstructured_grid
    start_index = index
    if node_cache[:sms_unstructured_grid].has_key?(index)
      cached = node_cache[:sms_unstructured_grid][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_sms_sentinel
    s0 << r1
    if r1
      r2 = _nt_sms_t_unstructured_grid
      s0 << r2
      if r2
        r3 = _nt_t_paren_l
        s0 << r3
        if r3
          r4 = _nt_variable_name
          s0 << r4
          if r4
            r5 = _nt_t_paren_r
            s0 << r5
            if r5
              r6 = _nt_t_newline
              s0 << r6
            end
          end
        end
      end
    end
    if s0.last
      r0 = instantiate_node(SMS_Unstructured_Grid,input, i0...index, s0)
      r0.extend(SmsUnstructuredGrid0)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_unstructured_grid][start_index] = r0

    r0
  end

  module SmsVarlist3d0
    def variable1
      elements[0]
    end

    def t_comma1
      elements[1]
    end

    def variable2
      elements[2]
    end

    def t_comma2
      elements[3]
    end

    def variable3
      elements[4]
    end
  end

  module SmsVarlist3d1
    def t_comma1
      elements[0]
    end

    def variable1
      elements[1]
    end

    def t_comma2
      elements[2]
    end

    def variable2
      elements[3]
    end
  end

  module SmsVarlist3d2
    def t_comma1
      elements[0]
    end

    def t_comma2
      elements[1]
    end

    def variable
      elements[2]
    end
  end

  module SmsVarlist3d3
    def variable1
      elements[0]
    end

    def t_comma
      elements[1]
    end

    def variable2
      elements[2]
    end
  end

  module SmsVarlist3d4
    def t_comma
      elements[0]
    end

    def variable
      elements[1]
    end
  end

  module SmsVarlist3d5
    def variable
      elements[0]
    end

  end

  def _nt_sms_varlist3d
    start_index = index
    if node_cache[:sms_varlist3d].has_key?(index)
      cached = node_cache[:sms_varlist3d][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0 = index
    i1, s1 = index, []
    r2 = _nt_variable
    s1 << r2
    if r2
      r3 = _nt_t_comma
      s1 << r3
      if r3
        r4 = _nt_variable
        s1 << r4
        if r4
          r5 = _nt_t_comma
          s1 << r5
          if r5
            r6 = _nt_variable
            s1 << r6
          end
        end
      end
    end
    if s1.last
      r1 = instantiate_node(SMS_Varlist3D_1,input, i1...index, s1)
      r1.extend(SmsVarlist3d0)
    else
      @index = i1
      r1 = nil
    end
    if r1
      r0 = r1
    else
      i7, s7 = index, []
      r8 = _nt_t_comma
      s7 << r8
      if r8
        r9 = _nt_variable
        s7 << r9
        if r9
          r10 = _nt_t_comma
          s7 << r10
          if r10
            r11 = _nt_variable
            s7 << r11
          end
        end
      end
      if s7.last
        r7 = instantiate_node(SMS_Varlist3D_2,input, i7...index, s7)
        r7.extend(SmsVarlist3d1)
      else
        @index = i7
        r7 = nil
      end
      if r7
        r0 = r7
      else
        i12, s12 = index, []
        r13 = _nt_t_comma
        s12 << r13
        if r13
          r14 = _nt_t_comma
          s12 << r14
          if r14
            r15 = _nt_variable
            s12 << r15
          end
        end
        if s12.last
          r12 = instantiate_node(SMS_Varlist3D_3,input, i12...index, s12)
          r12.extend(SmsVarlist3d2)
        else
          @index = i12
          r12 = nil
        end
        if r12
          r0 = r12
        else
          i16, s16 = index, []
          r17 = _nt_variable
          s16 << r17
          if r17
            r18 = _nt_t_comma
            s16 << r18
            if r18
              r19 = _nt_variable
              s16 << r19
            end
          end
          if s16.last
            r16 = instantiate_node(SMS_Varlist3D_4,input, i16...index, s16)
            r16.extend(SmsVarlist3d3)
          else
            @index = i16
            r16 = nil
          end
          if r16
            r0 = r16
          else
            i20, s20 = index, []
            r21 = _nt_t_comma
            s20 << r21
            if r21
              r22 = _nt_variable
              s20 << r22
            end
            if s20.last
              r20 = instantiate_node(SMS_Varlist3D_5,input, i20...index, s20)
              r20.extend(SmsVarlist3d4)
            else
              @index = i20
              r20 = nil
            end
            if r20
              r0 = r20
            else
              i23, s23 = index, []
              r24 = _nt_variable
              s23 << r24
              if r24
                if has_terminal?("", false, index)
                  r25 = instantiate_node(SyntaxNode,input, index...(index + 0))
                  @index += 0
                else
                  terminal_parse_failure("")
                  r25 = nil
                end
                s23 << r25
              end
              if s23.last
                r23 = instantiate_node(SMS_Varlist3D_6,input, i23...index, s23)
                r23.extend(SmsVarlist3d5)
              else
                @index = i23
                r23 = nil
              end
              if r23
                r0 = r23
              else
                @index = i0
                r0 = nil
              end
            end
          end
        end
      end
    end

    node_cache[:sms_varlist3d][start_index] = r0

    r0
  end

  module SmsVarList0
    def t_comma
      elements[0]
    end

    def variable_name
      elements[1]
    end
  end

  module SmsVarList1
    def variable_name
      elements[0]
    end

  end

  def _nt_sms_var_list
    start_index = index
    if node_cache[:sms_var_list].has_key?(index)
      cached = node_cache[:sms_var_list][index]
      if cached
        cached = SyntaxNode.new(input, index...(index + 1)) if cached == true
        @index = cached.interval.end
      end
      return cached
    end

    i0, s0 = index, []
    r1 = _nt_variable_name
    s0 << r1
    if r1
      s2, i2 = [], index
      loop do
        i3, s3 = index, []
        r4 = _nt_t_comma
        s3 << r4
        if r4
          r5 = _nt_variable_name
          s3 << r5
        end
        if s3.last
          r3 = instantiate_node(SyntaxNode,input, i3...index, s3)
          r3.extend(SmsVarList0)
        else
          @index = i3
          r3 = nil
        end
        if r3
          s2 << r3
        else
          break
        end
      end
      r2 = instantiate_node(SyntaxNode,input, i2...index, s2)
      s0 << r2
    end
    if s0.last
      r0 = instantiate_node(SMS_Var_List,input, i0...index, s0)
      r0.extend(SmsVarList1)
    else
      @index = i0
      r0 = nil
    end

    node_cache[:sms_var_list][start_index] = r0

    r0
  end

end

class FortranParser < Treetop::Runtime::CompiledParser
  include Fortran
end

