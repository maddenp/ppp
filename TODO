### ENVIRONMENT

- Derived types provided by modules should appear in envfiles.

### ERROR CHECKING / REPORTING

- Error in SMS_Exchange#translate when > 25 variables specified. Better yet,
  implement register/exchange scheme.

- Error needed when compare_var variable is not distributed or no mod info.

- sms$serial should complain about in/out/inout intent of variables that never
  occur in the region. Or should we force bcast/gather/scatter of these?

- sms$serial should complain about mismatches, e.g. explicitly specifying a
  variable as both 'in' and 'ignore'. Is this already in place?

### GRAMMAR

- Implement a continuation scheme (following Fortran!) for SMS directives. This
  probably goes in class Translator in sms_fortran.rb, to be executed alongside
  sms$[insert|remove] during early lexical transformations.

### NEW FEATURES

- Does where-stmt need implicit parallelization? Currently, it operates on halo
  memory as well.

### NORMALIZATION

- Replace ad-hoc normalizer with (maybe) Ragel-based transformer. Should handle
  holleriths, too. Changes made to text coordinates during processing by the
  state machine should be recorded so that coordinates related to errors during
  parsing can be mapped to original-source coordinates.

### OPTIMIZATION

- write_envfile is called by declare() whenever something is added to a module.
  This creates a lot of IO if many programmtic delcarations are performed. It
  would be better to do this once -- maybe as a post-translation walk that calls
  write_envfile for each module encountered.

### PARSING

- In fortran.rb's dolabel_repeat?(), consider not just the most recently pushed
  label, but also labels further down in the stack? That would also be an error,
  right?

- In grammar class methods that return an optional element (execution_part() of
  Main_Program e.g.) check *there* for expected class vs SyntaxNode and return
  nil for the latter (i.e. the optional element is not present). This factors
  the knowledge about the grammar into the appropriate class.

- write-stmt seems to parse wrong, 'write' recognized as Data_Ref. This could be
  a problem re: implicit translation of write io statements.

- rule variable is broken: See parse tree for program 'i=1\nend'. 'i' is parsed
  as data_ref. It seems that some mechanism to differentiate between user-
  defined and intrinsic types is needed. Also, probably user-defined type
  information  needs to be in the environment, written to .sms mod files, etc.

- Structure constructor recognition is broken, is parsed as function reference.
  See t0151. May also be related to need to track, store, load user-defined type
  info.

- IIRC, parsing of allocate_object is broken, in that the variable_name option
  (2nd choice) will never be chosen because structure_component always matches.
  Need more sophisticated logic...

- In fortran.tt, rule array_spec makes a claim about a bad parse. The comment
  should include a case to demonstrate this, so that the comment can be removed
  if/when the parse problem is corrected.

- Deduce types of implicit variables. We cannot require 'implicit none'.

### REFACTORING

- In e.g. SMS_Exchange, rename maxrank -> ppp_max_rank and sms_maxvars -> 
  ppp_max_exchange_vars, first renaming the ppp_* vars in the SMS library to
  adhere to sms__ naming convention. 7 as the max fortran rank would be
  reasonable to keep in ppp, but the max vars bit (may occur, with a different
  name, in other directives) should be a reference into the library code.

- Re-enable continuation lines check, now that exchanges used declared arrays.
  Actually, maybe wait until register/exchange scheme is in place.

- declare() is naive. What about declaring an array with the same type as an
  already-declared scalar? Need more flexibility...

- Factor more sms text out into T sms_* methods (esp library calls).

- More helper functions for e.g. sms_halo_comp() for env[:sms_halo_comp].

### TRANSLATION

- Now that the output filename is mandatory, is should be used in place of
  '(translation) marker' messages in e.g. sms_chkstat calls.

- Add original sms directives to output for non-block directives (or any other
  that are missing from translated output).

- Move tedius sms__exchange* data-structure inits and sets into sms library.
  Better yet, implement register/exchange scheme.

- In SMS_Serial translate, what should halo[l|u] be when dh is nil?

- Hardcoded '1's referring to s1, e1, etc. should be looked up from env. See
  translate() for SMS_Declare_Decomp, SMS_Unstructured_Grid, Array_Section,
  SMS_Create_Decomp. In SMS_Declare_Decomp translate, roll out as many e{n}/s{n}
  arrays as needed for the decomposition.

- Consider which directives may nest in which others, and which may not. Factor
  handling of these error conditions.

- How to handle pointer assignment statements in serial regions? Nullify
  statements? Assign statements? Consider the following:

  ORIGINAL                              TRANSLATION
  ------------------------------------- ----------------------------------------
                                        logical::sms__ptrassign_1
                                        logical::sms__ptrassign_2
                                        ...
                                        sms__ptrassign_1=.false.
                                        sms__ptrassign_2=.false.
                                        if (sms__i_am_root()) then
  !sms$serial begin                       !sms$serial begin
  if (cond1) then                         if (cond1) then
    p=>t                                    p=>t ; sms__ptrassign_1=.true.
    if (cond2) then                         if (cond2) then
      p=>u                                    p=>u ; sms__ptrassign_2=.true.
    endif                                   endif
  endif                                   endif
                                        endif
  !sms$serial end                       !sms$serial end
                                        sms__bcast(sms__ptrassign_1)
                                        sms__bcast(sms__ptrassign_2)
                                        if (sms__ptrassign_1) p=>t
                                        if (sms__ptrassign_2) p=>u

  Not all the way there, maybe. What if a do-loop alternately assigns p to t1
  and t2, so that the final association of p will depend on the upper loop bound
  being either even or odd? Then both sms__ptrassign_*s will be true. Subsequent
  pointer assignments should set the alternatives to .false.. e.g.

  do i=1,n
    if (mod(1,2).eq.0) then
      p=>t1
    else
      p=>t2
    endif
  enddo

  If sms__ptrassign_1 relates to p=>t1 and sms__ptrassign_2 relates to p=>t2,
  the former should be false and the latter true when n is false, and vice versa
  when n is odd.

- Be more selective about serial vars_in_region membership. Weed out uses that
  cannot possibly change values. See, maybe, 'serial_intent' mechanism used in
  re: namelist reads in serial regions for a solution. For example, read_stmt,
  write_stmt et al are not function calls, so we *do* know which of their
  arguments may be modified during a call (e.g. iostat's variable can, file's
  variable cannot) we can limit bcast/gather/scatter of these.

### TREE

- To make all of this more useful, build an AST from the parse tree. Then, do
  translations on and produce final output from the AST.
