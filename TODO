### ENVIRONMENT

- Don't use OpenStruct for static (see e.g. select in sp_module, where special
  code is needed to avoid calling [] on an OpenStruct. Use only Hash in env.

- Change 'function' key (with true value) to 'subprogram' with 'function' and
  'subroutine' values, and start recording module subroutines in env.

- Derived types provided by modules should appear in envfiles.

### ERROR CHECKING / REPORTING

- Error needed when compare_var variable is not distributed or no mod info

- sms$serial should complain about in/out/inout intent of variables that never
  occur in the region. Or should we force bcast/gather/scatter of these?

- sms$serial should complain about mismatches, e.g. explicitly specifying a
  variable as both 'in' and 'ignore'.

### GRAMMAR

- Implement a continuation scheme (following Fortran!) for SMS directives.

- Carefully consider the cases where an envpop'ing sp_* method is called from
  a grammar rule other than the one whose parse was requested and try to make
  these consistent and correct. For example, previously, sp_sms_ignore was
  called from the sms_ignore_executable option of the sms_executable rule,
  which meant that the env stack (pushed by the sms_ignore_begin rule) would
  not be popped if a parse of :sms_ignore_executable was requested! It would
  have been necessary to request a parse of the more general sms_executable
  rule (and let the parser discover that sms_ignore_executable is the match)
  in order to get the env stack popped. So, sp_* methods altering the env stack
  should probably be moved into the matching nodes; otherwise, care must be
  taken to do internal parses of the more general rule that calls the stack-
  altering method.

### NEW FEATURES

- Does where-stmt need implicit parallelization? Currently, it operates on halo
  memory as well.

- implicit-do constructs may require parallel treatment. See e.g. outFMTed.F90
  in FIM, where a serial region is currently required.

### OPTIMIZATION

* Could env[:sms_serial] have as its value the serial-region node, to avoid
  searching up the tree for it in translate() contexts? IIRC, the value now
  is simply 'true', but a reference to the node might be more useful. See e.g.
  ancestor(SMS_Serial) in Label#translate: env[:sms_serial] could return the
  same object.

* Time ppp on fim routines, find long ones, profile, optimize

* Instead of deepcopy on env, chain hashes with ancestor lookup mechanism. This
  may obsolete the redef mechanism -- be sure to clean that up if so.

- read_stmt, write_stmt et al are not function calls, so we *do* know which of
  their arguments may be modified during a call (e.g. iostat's variable can,
  file's variable cannot) we we can limit bcast/gather/scatter of these in a
  serial region.

- write_envfile is called by declare() whenever something is added to a module.
  This creates a lot of IO if many programmtic delcarations are performed. It
  would be better to do this once -- maybe as a post-translation walk that calls
  write_envfile for each module encountered.

### PARSING

- Deduce types of implicit variables.

- write-stmt seems to parse wrong, 'write' recognized as Data_Ref. This could be
  a problem re: implicit translation of write io statements.

- rule variable is broken: See parse tree for program 'i=1\nend'. 'i' is parsed
  as data_ref. It seems that some mechanism to differentiate between user-
  defined and intrinsic types is needed. Also, probably user-defined type
  information  needs to be in the environment, written to .sms mod files, etc.

- Structure constructor recognition is broken, is parsed as function reference.
  See t0151. May also be related to need to track, store, load user-defined type
  info.

- IIRC, parsing of allocate_object is broken, in that the variable_name option
  (2nd choice) will never be chosen because structure_component always matches.
  Need some more sophisticated logic...

- In fortran.tt, rule array_spec makes a claim about a bad parse. The comment
  should include a case to demonstrate this, so that the comment can be removed
  if/when the parse problem is corrected.

- In fortran.rb's dolabel_repeat?(), consider not just the most recently pushed
  label, but also labels further down in the stack? That would also be an error,
  right?

- In grammar class methods that return an optional element (execution_part() of
  Main_Program e.g.) check *there* for expected class vs SyntaxNode and return
  nil for the latter (i.e. the optional element is not present). This factors
  the knowledge about the grammar into the appropriate class.

### REFACTORING

- Get rid of class T and all uses? E seems much safer... Or use T & NT?

- In fortran.rb/sms_fortran.rb, standardize when methods on nodes return strings
  or SyntaxNode subclasses. That is, should we convert to strings as early as
  possible, or delay until a string is absolutely required? Probably the latter.

- In sms_commtag, instead of working at root node, use env[:static]?

- Re-enable continuation lines check, deal with looooong exchange in dyn_init.
  Are the array literals as compact as possible (e.g. do we need all 7 dims, all
  25 (?) MAX_PPP_VARS)? Better yet, make exchange use a begin/queue-multiple/end
  buffering scheme, which avoids limits on exchange vars and minimized the size
  of each call into the SMS library.

- In sms_fortran.rb, 'names_in_region' should be 'vars_in_region' and should
  be just that -- not function or subroutine names, not parameter names, etc.

- declare() is naive. What about declaring an array with the same type as an
  already-declared scalar? Need more flexibility...

- Factor more sms text out into T#sms_* methods (esp library calls).

- varprop -> varenv?

### TRANSLATION

* Consider R1213 alt-return-spec in re: branching into / out of serial region.

* 'assign' targets and labels are unique per scoping unit, so neither belongs in
  evn[:static]. Also, these must not be inherited by subscopes, so must be
  removed before deepcopy (or whatever mechanism takes its place). Or, store
  scoping-unit info, e.g.: env[:assign_map][scoping_unit][#{label}]=...

* Since "Leading zeros are not significant in distinguishing between statement
  labels", leading zeros should be stripped when using strigified label nodes
  as keys in hashes.

* In SMS_Reduce#translate, build out case statement for the other supported
  nnt_* types. BUT, maybe we should be querying MPI for this information in the
  SMS library (see e.g. bugzilla bug #21).

* Need SMS library function that takes type and kind arguemnts and returns the
  correct nnt_ type to use in library calls. There's some hack in fimppp now to
  remove a user-defined kind -- this needs to be undone and to work correctly.
  BUT see bugzilla bug #21 re: SMS querying MPI for this information so that
  user-defined kinds can be transparently supported.

- Does sms_gather() really need all 7 dims (see e.g. gather rollout in
  Write_Stmt or SMS_Serial.

- SMS_Create_Decomp#translate is only valid for one decomposed dimension. Extend
  it to handle three.

- In SMS_Serial#translate, there's a potential issue in that a Name may be
  e.g. a function or subroutine name, in which case it may not (will not?)
  appear in the environment. For now, ignore the Name if it's not in the
  environment, which prevents translation of non-variable names. Note that
  'standard' behavior is to exit with an error if an expected name is not found,
  so this is divergent. Worse, it may be *wrong* as function names may
  eventually appear in the environment (to note their type).

- In SMS_Serial#translate, what should halo[l|u] be when dh is nil?

- Hardcoded '1's referring to decomposition elements should be looked up from
  env.

### TREE

- To make all of this more useful, build an AST from the parse tree. Then, do
  translations on and produce final output from the AST.
