### ENVIRONMENT

- Derived types provided by modules should appear in envfiles.

### ERROR CHECKING / REPORTING

- Error needed when compare_var variable is not distributed or no mod info.

- sms$serial should complain about in/out/inout intent of variables that never
  occur in the region. Or should we force bcast/gather/scatter of these?

- sms$serial should complain about mismatches, e.g. explicitly specifying a
  variable as both 'in' and 'ignore'. Is this already in place?

### GRAMMAR

- Give specific names to the many NT nodes in [sms_]fortran.tt. IN PROGRESS.

- Implement a continuation scheme (following Fortran!) for SMS directives.

### NEW FEATURES

- Need to handle broadcast/scatter of variables contained in io-implied-do input
  or output item lists, e.g. read (88) (a(i),i=1,n). Here, a must be either
  broadcast or scattered. (Related? See e.g. outFMTed.F90 in FIM, where a serial
  region is currently required.)

- Does where-stmt need implicit parallelization? Currently, it operates on halo
  memory as well.

- Provide support for distributed Structure of Arrays (SoA).

- Provide support for distributed Array of Structures (AoS).

### OPTIMIZATION

- read_stmt, write_stmt et al are not function calls, so we *do* know which of
  their arguments may be modified during a call (e.g. iostat's variable can,
  file's variable cannot) we can limit bcast/gather/scatter of these in a
  serial region.

- write_envfile is called by declare() whenever something is added to a module.
  This creates a lot of IO if many programmtic delcarations are performed. It
  would be better to do this once -- maybe as a post-translation walk that calls
  write_envfile for each module encountered.

- Be sure to avoid re-reading files like 'sentinels' and 'intrinsics in internal
  parses.

### PARSING

- In fortran.rb's dolabel_repeat?(), consider not just the most recently pushed
  label, but also labels further down in the stack? That would also be an error,
  right?

- In grammar class methods that return an optional element (execution_part() of
  Main_Program e.g.) check *there* for expected class vs SyntaxNode and return
  nil for the latter (i.e. the optional element is not present). This factors
  the knowledge about the grammar into the appropriate class.

- write-stmt seems to parse wrong, 'write' recognized as Data_Ref. This could be
  a problem re: implicit translation of write io statements.

- rule variable is broken: See parse tree for program 'i=1\nend'. 'i' is parsed
  as data_ref. It seems that some mechanism to differentiate between user-
  defined and intrinsic types is needed. Also, probably user-defined type
  information  needs to be in the environment, written to .sms mod files, etc.

- Structure constructor recognition is broken, is parsed as function reference.
  See t0151. May also be related to need to track, store, load user-defined type
  info.

- IIRC, parsing of allocate_object is broken, in that the variable_name option
  (2nd choice) will never be chosen because structure_component always matches.
  Need some more sophisticated logic...

- In fortran.tt, rule array_spec makes a claim about a bad parse. The comment
  should include a case to demonstrate this, so that the comment can be removed
  if/when the parse problem is corrected.

- Deduce types of implicit variables.

### REFACTORING

- Re-enable continuation lines check, deal with looooong exchange in dyn_init.
  Are the array literals as compact as possible (e.g. do we need all 7 dims, all
  25 (?) MAX_PPP_VARS)? Better yet, make exchange use a begin/queue-multiple/end
  buffering scheme, which avoids limits on exchange vars and minimized the size
  of each call into the SMS library.

- declare() is naive. What about declaring an array with the same type as an
  already-declared scalar? Need more flexibility...

- Factor more sms text out into T sms_* methods (esp library calls).

- More helper functions for e.g. sms_halo_comp() for env[:sms_halo_comp].

- Outside sp_* methods, use varenv_get instead of env[].

### TRANSLATION

- Now that the output filename is mandatory, is should be used in place of
  '(translation) marker' messages in e.g. sms_chkstat calls.

- Add original sms directives to output for non-block directives (or any other
  that are missing from translated output).

- In SMS_Serial translate, what should halo[l|u] be when dh is nil?

- Hardcoded '1's referring to decomposition elements should be looked up from
  env. See translate() for SMS_Declare_Decomp, SMS_Unstructured_Grid,
  Array_Section, SMS_Create_Decomp. In SMS_Declare_Decomp translate, roll out
  as many e{n}/s{n} arrays as needed for the decomposition.

- Consider which directives may nest in which others, and which may not. Factor
  handling of these error conditions.

- Do other uses of global start/stop (gstrt/gstop) need the same treatment as
  in SMS_Exchange's translate()? If so, can it be factored and reused?

- How to handle pointer assignment statements in serial regions? Nullify
  statements? Assign statements? Consider the following:

  ORIGINAL                              TRANSLATION
  ------------------------------------- ----------------------------------------
                                        logical::sms__ptrassign_1
                                        logical::sms__ptrassign_2
                                        ...
                                        sms__ptrassign_1=.false.
                                        sms__ptrassign_2=.false.
  !sms$serial begin                     !sms$serial begin
  if (cond1) then                       if (cond1) then
    p=>t                                  p=>t ; sms__ptrassign_1=.true.
    if (cond2) then                       if (cond2) then
      p=>u                                  p=>u ; sms__ptrassign_2=.true.
    endif                                 endif
  endif                                 endif
                                        sms__bcast(sms__ptrassign_1)
                                        sms__bcast(sms__ptrassign_2)
                                        if (sms__ptrassign_1) p=>t
                                        if (sms__ptrassign_2) p=>u

- Be more selective about serial vars_in_region membership. Weed out uses that
  cannot possible change values. See, maybe, 'serial_intent' mechanism used in
  re: namelist reads in serial regions for a solution.

### TREE

- To make all of this more useful, build an AST from the parse tree. Then, do
  translations on and produce final output from the AST.
