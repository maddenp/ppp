### ENVIRONMENT

- Derived types provided by modules should appear in envfiles. Update: A start
  has been made here, in that derived-type names are now registered in the
  environment with {"sort"=>"type"}. The type's contents need to be added.

### ERROR CHECKING / REPORTING

### GRAMMAR

### NEW FEATURES

### NORMALIZATION

- Replace ad-hoc normalizer with (maybe) Ragel-based transformer. Should handle
  holleriths, too. Changes made to text coordinates during processing by the
  state machine should be recorded so that coordinates related to errors during
  parsing can be mapped to original-source coordinates. Note that prepsrc_free
  and prepsrc_fixed changes need to be incorporated into this somehow.

### OPTIMIZATION

- Test/measure new case-insensitivity and regex capabilities in Treetop.

- Try to simplify internal parses by replacing code blocks with single stmts,
  e.g. a continue stmt, and just swapping in the old block after reparse.

- write_envfile is called by declare() whenever something is added to a module.
  This creates a lot of IO if many programmtic delcarations are performed. It
  would be better to do this once -- maybe as a post-translation walk that calls
  write_envfile for each module encountered.

- Consider replacing internal mini-parses with manual node/tree construction.

### PARSING

- Reconsider storing references to tree nodes during parsing. Instead, consider
  replacing 'adopt' walk with a general data-collection walk, after initial
  parse. Some data collection during parsing will still be necessary for correct
  parsing, but move anything related to collecting information for translation
  to the data-collection walk. Also get rid of env[:global][:parsed].

- Get rid of :safe optization, at least when new normalier is in place, maybe
  before. It didn't help much and adds complication.

- Deduce types of implicit variables. We cannot require 'implicit none'.

- In fortran.rb's dolabel_repeat?(), consider not just the most recently pushed
  label, but also labels further down in the stack? That would also be an error,
  right?

- In grammar class methods that return an optional element (execution_part() of
  Main_Program e.g.) check *there* for expected class vs SyntaxNode and return
  nil for the latter (i.e. the optional element is not present). This factors
  the knowledge about the grammar into the appropriate class.

- Intel compiler directives (http://goo.gl/c8q2eu) need independent grammar
  rules, with scoping to decl, exe, other sections.

### REFACTORING

- Implement register/exchange scheme.

- In e.g. SMS_Exchange, rename maxrank -> ppp_max_rank and sms_maxvars ->
  ppp_max_exchange_vars, first renaming the ppp_* vars in the SMS library to
  adhere to sms__ naming convention. 7 as the max fortran rank would be
  reasonable to keep in ppp, but the max vars bit (may occur, with a different
  name, in other directives) should be a reference into the library code.

- declare() is naive. What about declaring an array with the same type as an
  already-declared scalar? Need more flexibility...

- It might be better to get rid of of 'sort' key in .sms file, rename 'dims' to
  'rank', and have rank 0 => scalar, rank > 0 => array. But the value of the
  'sort' key can also be '_namelist', so that has to be dealt with somehow.
  Maybe rank => _namelist would work. In general, think about how the names
  'dimension' and 'rank' are used, and what would be best.

### TRANSLATION

- Deal with derived types. Start e.g. with treating them in serial regions.

- Perform sms$parallel translation implicitly.

- sms$halo_comp -> one-line directive bound to parallel do loop.

- In SMS_Serial translate, what should halo[l|u] be when dh is nil?

- Hardcoded '1's referring to s1, e1, etc. should be looked up from env. See
  translate() for SMS_Declare_Decomp, SMS_Unstructured_Grid, Array_Section,
  SMS_Create_Decomp. In SMS_Declare_Decomp translate, roll out as many e{n}/s{n}
  arrays as needed for the decomposition.

- Consider which directives may nest in which others, and which may not. Factor
  handling of these error conditions.

- Deal with structured grids.

- Think about (and deal with) distributed parameter arrays.

- Currently, if an object allocated inside a serial region is also modified in a
  (not necessarily the same) serial region, it becomes an l-value eligible for
  post-region broadcast. (Note that allocating a distributed array in a serial
  region is already prohibited, so this applies only to non-distributed arrays
  and scalars.) However, this is erroneous because the object has only been
  allocated by the root processor. So, currently, such an object must be given
  explicit 'ignore' treatment. Automatic treatment could be improved by a check
  that the object in question is allocated on all processors and, in the case of
  arrays, has the same size on all processors, in which case broadcasts are
  safe. It should be possible to implement this check via a reduce, e.g. set 'x'
  to 0 for unallocated objects, and to the size of allocated ones (scalar size =
  1), and reduce 'x'. If pre- and post-reduce 'x' is identical, perform the
  broadcast. That's a sketch, and could require more thought. Similarly, pointer
  assignments may need similar checks: The allocation status of a target should
  be checked before replaying a pointer assignment on all tasks after a serial
  region.

- Branching into or out of serial regions or parallel loops is prohibited, but
  is 'goto l', where 'l' is an integer variable, already detected? If not, it
  should be. Also, when replaying label 'assign' after a serial region, is there
  anything to consider here in re: branching into / out of serial/parallel
  blocks?

- Disqualify from eligibility for post-serial-region broadcast (a) 'intent(in)'
  variables, and (b) variables appearing (only) as arguments to intrinsic
  functions, which are pure.

### TREE

- To make all of this more useful, build an AST from the parse tree. Then, do
  translations on and produce final output from the AST.
