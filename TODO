- Remove 'continue' shims in fim.

- Remove sms$ignore around 'type' blocks?

- Does the envfile from a module that uses another module contain the info from
  the other module? Should it?

- Use ppp__status in calls into sms library to abort on error. nnt_chkstat

- Check status on all allocates rolled out by ppp.

- Must handle eor=/err= inside serial region, too.

- Carefully consider the cases where an envpop'ing sp_* method is called from
  a grammar rule other than the one whose parse was requested and try to make
  these consistent and correct. For example, previously, sp_sms_ignore was
  called from the sms_ignore_executable option of the sms_executable rule,
  which meant that the env stack (pushed by the sms_ignore_begin rule) would
  not be popped if a parse of :sms_ignore_executable was requested! It would
  have been necessary to request a parse of the more general sms_executable
  rule (and let the parser discover that sms_ignore_executable is the match)
  in order to get the env stack popped. So, sp_* methods altering the env stack
  should probably be moved into the matching nodes; otherwise, care must be
  taken to do internal parses of the more general rule that calls the stack-
  altering method.

- write-stmt seems to parse wrong, 'write' recognized as Data_Ref. This could be
  a problem re: implicit translation of write io statements.

- Sort envfile output for easy xxdiff comparison.

- .env file does not contain items added during translation, (true?) e.g.
  module_decomp.env does not even *exist*, much less contain the items added
  during translation.

- Error needed when compare_var variable is not distributed or no mod info

- where-stmt may need (automatic?) parallel treatment.

- implicit-do constructs may require parallel treatment. See e.g. outFMTed.F90
  in FIM, where a serial region is currently required.

- Are distributed array assignments e.g.
    !sms$distribute (dh,1) begin
    integer::a(100)
    !sms$distribute end
    a=0
  supported?

- Stop tracking kind. Pass only *type* to MPI-calling SMS routines and, in the
  latter, use mpi_sizeof() + mpi_type_match_size() in the library to make a
  run-time determination of MPI type to use. Get rid of related kind() methods
  in fortran.rb. IS THIS A GOOD IDEA?

- It might be better to prefix all in-class method calls with 'self.' for
  clarity. Or better to get rid of 'self' altogether for conciseness?

- rule variable is broken: See parse tree for program 'i=1\nend'. 'i' is parsed
  as data_ref. It seems that some mechanism to differentiate between user-
  defined and intrinsic types is needed. Also, probably user-defined type
  information  needs to be in the environment, written to .sms mod files, etc.

- Structure constructor recognition is broken, is parsed as function reference.
  See t0151. May also be related to need to track, store, load user-defined type
  info.

- translate() on SMS_Unstructured_Grid cannot possibly be correct in the general
  case, right?

- IIRC, parsing of allocate_object is broken, in that the variable_name option
  (2nd choice) will never be chosen because structure_component always matches.
  Need some more sophisticated logic...

- Should derived types provided by modules appear in .env files (probably!), and
  how?

- Fortran#replace_statements (plural) may be problematic (i.e. it might modify
  the tree in unsound ways). It may be better to use the block_do_construct
  trick (do\n...exit\nend do", replacing a single statement.

- To make all of this more useful, build an AST from the parse tree. Then, do
  translations on and produce final output from the AST.

- In SMS_Create_Decomp#translate, merge multiple 1..3 loops. They are as they
  are now to aid in textual comparison to legacy ppp.

- SMS_Create_Decomp#translate is only valid for one decomposed dimension. Extend
  it to handle three.

- Define new API, document, bring translator up-to-spec.

- Can we replace env with OpenStruct? What does that look like serialized to
  YAML? Is it human readable/writeable?

- In SMS_Reduce#translate, build out case statement for the other supported
  nnt_* types.

- Make nnt_/ppp_/sms_ namespace consistent. Ensure that any rolled-out names
  adhere to whatever standard is chosen.

- Why are some SMS API routines ppp_* (e.g. ppp_bcast) and some sms_* (e.g.
  sms_scatter)? Can this please be made consistent?

- In fortran.rb/sms_fortran.rb, standardize when methods on nodes return strings
  or SyntaxNode subclasses. That is, should we convert to strings as early as
  possible, or delay until a string is absolutely required? Probably the latter.

- sms$serial should complain about in/out/inout intent of variables that never
  occur in the region. Or should we force bcast/gather/scatter of these?

- sms$serial should complain about mismatches, e.g. explicitly specifying a
  variable as both 'in' and 'ignore'.

- In SMS_Serial#translate, there's a potential issue in that a Name may be
  e.g. a function or subroutine name, in which case it may not (will not?)
  appear in the environment. For now, ignore the Name if it's not in the
  environment, which prevents translation of non-variable names. Note that
  'standard' behavior is to exit with an error if an expected name is not found,
  so this is divergent. Worse, it may be *wrong* as function names may
  eventually appear in the environment (to note their type).

- translate_children() -- do we need 'if e' & compact & 'if x'?

- In getvarenv(), give more verbose information about why a failure has occurred
  and what to do about it (e.g. .env file is not available, so get dependencies
  right, or write your own .env file, only ask ppp to operate on appropriate
  variables, etc.)

- Factor array-literal creation for sms_compare_var, esms_exhcange, sms_serial,
  etc.

- Need SMS library function that takes type and kind arguemnts and returns the
  correct nnt_ type to use in library calls. There's some hack in fimppp now to
  remove a user-defined kind -- this needs to be undone and to work correctly.

- In SMS_Serial#translate, what should halo[l|u] be when dh is nil?

- Refactor SMS_Serial#translate!

- replace_element may also be unsound, as it removes nodes from the tree.
  Instead, maybe walk up the tree and update text_value components?

- In sms_fortran.rb, 'names_in_region' should be 'vars_in_region' and should
  be just that -- not function or subroutine names, not parameter names, etc.

- read_stmt, write_stmt et al are not function calls, so we *do* know which of
  their arguments may be modified during a call (e.g. iostat's variable can,
  file's variable cannot) we we can limit bcast/gather/scatter of these in a
  serial region.

- See "BUG" comment in SMS_Serial#translate.

- Get rid of class T and all uses? E seems much safer... Or use T & NT?

- Is/are other halol/halou roll-out(s) correct? sms$exchange? All positions 0
  except for decomposed dim?

- Hardcoded '1's referring to decomposition elements should be looked up from
  env.

- In sms_fortran.rb SMS_Serial#translate, factor varenv["dim#{r}"] & similar.

- In fortran.rb's dolabel_repeat?(), consider not just the most recently pushed
  label, but also labels further down in the stack? That would also be an error,
  right?

- In fortran.tt, rule array_spec makes a claim about a bad parse. The comment
  should include a case to demonstrate this, so that the comment can be removed
  if/when the parse problem is corrected.

- Re-enable continuation lines check, deal with looooong exchange in dyn_init.
  Are the array literals as compact as possible (e.g. do we need all 7 dims, all
  25 (?) MAX_PPP_VARS)? Better yet, make exchange use a begin/queue-multiple/end
  buffering scheme, which avoids limits on exchange vars and minimized the size
  of each call into the SMS library.

- Implement a continuation scheme (following Fortran!) for SMS directives.

- Factor 'if (iam_root()) then' wrapping in IO statements.

- Factor out common elements in implicit IO translate() methods.

- Should main-program envpush as well? Current mismatch between # of envpushes
  and env pops

- What about making calls inside serial regions to routines that do IO stmts?
  If those IO stmts contain err=, iostat=, etc., broadcasts will hang. Can
  we detect this at compile time and at least fail with an explanation?

- Time ppp on fim routines, find long ones, profile, optimize

- Should error handling be added for translated IO statements with none? If
  not, what happens when the root task terminates per F90:9.4.3? Do the other
  tasks hang?

- Prevent goto branching into serial regions (track, along with each used label,
  its serial/parallel-context status and check this in post-processing.

- Does sms_gather() really need all 7 dims (see e.g. gather rollout in
  Write_Stmt or SMS_Serial.

- Factor duplication between IO_Stmt and SMS_Serial.

- It might be clearer to break IO_Stmt into several more specific classes.
  This may work better after duplication between IO_Stmt and SMS_Serial is
  factored.

- Deduce types of implicit variables.

- If Fortran allows shadowing a use-obtained array with a local of the same
  name, it will be critical to create a new env entry for the local, rather
  than just updating the entry created when the module was read in. For example,
  a variable could be a distributed read array in a use'ed module but a
  scalar integer as a local. If the distribute info persitst in the variable's
  env entry, it will be incorrect. Maybe: Any occurrence of a name in the
  declaration section should immediately overwrite an existing env entry, but
  only one time (since dimension, access, type info may all occur in separate
  decl statements -- they can't be wiping out eachother's env entries, but
  the first one encountered should wipe out whatever was obtained via use
  association).

- Need to add to env for function optional RESULT name/type (probably do at
  close of function_subroutine, since function type may not be made explicit
  by function_stmt).

- What about e.g. 'a(1:5)=0' when 'a' is distributed and elements 1:4 are only
  present on one task? This is probably ok due to s1/e1 behavior, but check...

- In grammar class methods that return an optional element (execution_part() of
  Main_Program e.g.) check *there* for expected class vs SyntaxNode and return
  nil for the latter (i.e. the optional element is not present). This factors
  the knowledge about the grammar into the appropriate class.

- Refactor distribute_array_bounds() in sms_fortran.rb.

- Maybe do not *remove* nodes. For example, in SMS_Serial#translate, position of
  'block' changes when begin/end stmts are removed. Why not just leave them and
  override their to_s() (maybe conditionally) or replace them with SyntaxNodes?
  Maybe redefine to_s method to return empty string? Change remote() to
  silence()?

- Shouldnt 4th arg to ppp_bcast be a scalar, instead of an array? Or is this
  about the 3rd arg, which is different between bcast and bcast_char?

- Pros/Cons of e.g. env[:serial] vs inside?(SMS_Serial)? Standardize on one?

- declare() is naive. What about declaring an array with the same type as an
  already-declared scalar? Need more flexibility...

- Factor more sms text out into T#sms_* methods.

- Optimization: When processing a file, hash read-in module files so that a
  repeat use (e.g. in another subroutine in that module) need not read from
  disk again.

- stop-stmt in serial region needs to bring down all tasks.
