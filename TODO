### ENVIRONMENT

- Sort envfile output for easy xxdiff comparison.

* .sms file does not contain items added during translation, (true?) e.g.
  module_decomp.sms does not even *exist*, much less contain the items added
  during translation.

- Should derived types provided by modules appear in .sms files (probably!), and
  how?

* Consider:

  program p
    real::x(3)=(/1,2,3/)
    call s
  contains
    subroutine s
      integer::x=88
      print *,x
    end subroutine s
  end program p

  The definition of x in s should replace (not append to / overwrite) the
  definition in p. If, for example, x in p had a kind attribute, it would
  persist, incorrectly, in the copy of the environment created for s. Or,
  if x were distributed in p, the decomp information would incorrectly
  persist. Maybe: Any occurrence of a name in the declaration section should
  immediately overwrite an existing env entry, but only one time (since
  dimension, access, type info may all occur in separate decl statements --
  they can't be wiping out eachother's env entries, but the first one
  encountered should wipe out whatever was obtained via use association).

* Need to add to env for function optional RESULT name/type (probably do at
  close of function_subroutine, since function type may not be made explicit
  by function_stmt).

### ERROR CHECKING / REPORTING

- In getvarenv(), give more verbose information about why a failure has occurred
  and what to do about it (e.g. .sms file is not available, so get dependencies
  right, or write your own .sms file, only ask ppp to operate on appropriate
  variables, etc.)

- Error needed when compare_var variable is not distributed or no mod info

- sms$serial should complain about in/out/inout intent of variables that never
  occur in the region. Or should we force bcast/gather/scatter of these?

- sms$serial should complain about mismatches, e.g. explicitly specifying a
  variable as both 'in' and 'ignore'.

### GRAMMAR

- Implement a continuation scheme (following Fortran!) for SMS directives.

- Carefully consider the cases where an envpop'ing sp_* method is called from
  a grammar rule other than the one whose parse was requested and try to make
  these consistent and correct. For example, previously, sp_sms_ignore was
  called from the sms_ignore_executable option of the sms_executable rule,
  which meant that the env stack (pushed by the sms_ignore_begin rule) would
  not be popped if a parse of :sms_ignore_executable was requested! It would
  have been necessary to request a parse of the more general sms_executable
  rule (and let the parser discover that sms_ignore_executable is the match)
  in order to get the env stack popped. So, sp_* methods altering the env stack
  should probably be moved into the matching nodes; otherwise, care must be
  taken to do internal parses of the more general rule that calls the stack-
  altering method.

- Why are some SMS API routines ppp_* (e.g. ppp_bcast) and some sms_* (e.g.
  sms_scatter)? Can this please be made consistent?

### NEW FEATURES

- where-stmt may need (automatic?) parallel treatment.

- implicit-do constructs may require parallel treatment. See e.g. outFMTed.F90
  in FIM, where a serial region is currently required.

- Are distributed array assignments e.g.
    !sms$distribute (dh,1) begin
    integer::a(100)
    !sms$distribute end
    a=0
  supported?

### OPTIMIZATION

* When processing a file, hash read-in module files so that a repeat use (e.g.
  in another subroutine in that module) need not read from disk again.

* Instead of deepcopy on env, chain hashes with ancestor lookup mechanism.

- read_stmt, write_stmt et al are not function calls, so we *do* know which of
  their arguments may be modified during a call (e.g. iostat's variable can,
  file's variable cannot) we we can limit bcast/gather/scatter of these in a
  serial region.

* Time ppp on fim routines, find long ones, profile, optimize

### PARSING

- Should main-program envpush as well? Current mismatch between # of envpushes
  and env pops

- write-stmt seems to parse wrong, 'write' recognized as Data_Ref. This could be
  a problem re: implicit translation of write io statements.

- rule variable is broken: See parse tree for program 'i=1\nend'. 'i' is parsed
  as data_ref. It seems that some mechanism to differentiate between user-
  defined and intrinsic types is needed. Also, probably user-defined type
  information  needs to be in the environment, written to .sms mod files, etc.

- Structure constructor recognition is broken, is parsed as function reference.
  See t0151. May also be related to need to track, store, load user-defined type
  info.

- IIRC, parsing of allocate_object is broken, in that the variable_name option
  (2nd choice) will never be chosen because structure_component always matches.
  Need some more sophisticated logic...

- In fortran.tt, rule array_spec makes a claim about a bad parse. The comment
  should include a case to demonstrate this, so that the comment can be removed
  if/when the parse problem is corrected.

- Deduce types of implicit variables.

- In fortran.rb's dolabel_repeat?(), consider not just the most recently pushed
  label, but also labels further down in the stack? That would also be an error,
  right?

- In grammar class methods that return an optional element (execution_part() of
  Main_Program e.g.) check *there* for expected class vs SyntaxNode and return
  nil for the latter (i.e. the optional element is not present). This factors
  the knowledge about the grammar into the appropriate class.

### REFACTORING

- Factor array-literal creation for sms_compare_var, sms_exhcange, sms_serial,
  etc.

- In SMS_Create_Decomp#translate, merge multiple 1..3 loops. They are as they
  are now to aid in textual comparison to legacy ppp.

- It might be better to prefix all in-class method calls with 'self.' for
  clarity. Or better to get rid of 'self' altogether for conciseness?

- Get rid of class T and all uses? E seems much safer... Or use T & NT?

- In sms_commtag, instead of working at root node, use env[:static]?

- Re-enable continuation lines check, deal with looooong exchange in dyn_init.
  Are the array literals as compact as possible (e.g. do we need all 7 dims, all
  25 (?) MAX_PPP_VARS)? Better yet, make exchange use a begin/queue-multiple/end
  buffering scheme, which avoids limits on exchange vars and minimized the size
  of each call into the SMS library.

- In fortran.rb/sms_fortran.rb, standardize when methods on nodes return strings
  or SyntaxNode subclasses. That is, should we convert to strings as early as
  possible, or delay until a string is absolutely required? Probably the latter.

- In sms_fortran.rb, 'names_in_region' should be 'vars_in_region' and should
  be just that -- not function or subroutine names, not parameter names, etc.

- Pros/Cons of e.g. env[:serial] vs inside?(SMS_Serial)? Standardize on one?

- declare() is naive. What about declaring an array with the same type as an
  already-declared scalar? Need more flexibility...

- Factor more sms text out into T#sms_* methods.

### TRANSLATION

* Use ppp__status in calls into sms library to abort on error. nnt_chkstat

* stop-stmt in serial region needs to bring down all tasks.

* Must handle eor=/err= inside serial region, too.

* Should error handling be added for translated IO statements with none? If
  not, what happens when the root task terminates per F90:9.4.3? Do the other
  tasks hang?

* Prevent goto branching into serial regions (track, along with each used label,
  its serial/parallel-context status and check this in post-processing.

- Does sms_gather() really need all 7 dims (see e.g. gather rollout in
  Write_Stmt or SMS_Serial.

- SMS_Unstructured_Grid#translate cannot possibly be correct in the general
  case, right?

- SMS_Create_Decomp#translate is only valid for one decomposed dimension. Extend
  it to handle three.

- In SMS_Reduce#translate, build out case statement for the other supported
  nnt_* types. BUT, maybe we should be querying MPI for this information in the
  SMS library (see e.g. bugzilla bug #21.

- In SMS_Serial#translate, there's a potential issue in that a Name may be
  e.g. a function or subroutine name, in which case it may not (will not?)
  appear in the environment. For now, ignore the Name if it's not in the
  environment, which prevents translation of non-variable names. Note that
  'standard' behavior is to exit with an error if an expected name is not found,
  so this is divergent. Worse, it may be *wrong* as function names may
  eventually appear in the environment (to note their type).

- Need SMS library function that takes type and kind arguemnts and returns the
  correct nnt_ type to use in library calls. There's some hack in fimppp now to
  remove a user-defined kind -- this needs to be undone and to work correctly.
  BUT see bugzilla bug #21 re: SMS querying MPI for this information so that
  user-defined kinds can be transparently supported.

- In SMS_Serial#translate, what should halo[l|u] be when dh is nil?

- See "BUG" comment in SMS_Serial#translate.

- Is/are other halol/halou roll-out(s) correct? sms$exchange? All positions 0
  except for decomposed dim?

- Hardcoded '1's referring to decomposition elements should be looked up from
  env.

- What about making calls inside serial regions to routines that do IO stmts?
  If those IO stmts contain err=, iostat=, etc., broadcasts will hang. Can
  we detect this at compile time and at least fail with an explanation?

* Shouldnt 4th arg to ppp_bcast be a scalar, instead of an array? Or is this
  about the 3rd arg, which is different between bcast and bcast_char?

- translate_children() -- do we need 'if e' & compact & 'if x'?

### TREE

- Fortran#replace_statements (plural) may be problematic (i.e. it might modify
  the tree in unsound ways). It may be better to use the block_do_construct
  trick (do\n...exit\nend do", replacing a single statement.

- To make all of this more useful, build an AST from the parse tree. Then, do
  translations on and produce final output from the AST.

- replace_element may also be unsound, as it removes nodes from the tree.
  Instead, maybe walk up the tree and update text_value components?

- Maybe do not *remove* nodes. For example, in SMS_Serial#translate, position of
  'block' changes when begin/end stmts are removed. Why not just leave them and
  override their to_s() (maybe conditionally) or replace them with SyntaxNodes?
  Maybe redefine to_s method to return empty string? Change remote() to
  silence()?
