- directives to do

  !sms$create_decomp
  !sms$ignore begin/end
  !sms$reduce
  !sms$reduce begin/end
  !sms$serial begin/end
  directiveless io translations

x directives done

  !sms$barrier
  !sms$compare_var
  !sms$declare_decomp
  !sms$distribute
  !sms$exchange
  !sms$halo_comp begin/end
  !sms$insert
  !sms$parallel begin/end
  !sms$remove
  !sms$set_communicator
  !sms$to_local begin/end
  !sms$unstructured_grid

- Translate print, write, namelist stuff, other act-like-serial items.

- Remove various HACKS and deal with any fallout.

- REMOVE sms_passthrough and everything related to it.

- REMOVE sms$ignore* and everything related to it.

- Need tests of F90:R1206 generic_spec (2nd two forms).

- Need tests of all R905 possibilities.

- Need tests of all F90:R912 possibilities.

- Need tests of all F90:R924 possibilities.

- Move proc_sms_executable call from sms_executable : sms_barrier to
  executable_construct : sms_executable once sms$ignore begin/end are gone.
  Also: sms_compare_var.

- Move proc_sms_declarative call from sms_declarative : sms_distribute to
  declaration_construct : sms_declarative once sms$ignore begin/end are gone.

- In declare(), use push(tree) instead of insert(0,tree) to insert new
  declarations at the END of the declarations list. Unfortunately, the old
  ppp breaks (fim:cnuity.F90) with the declaration at the end -- can't see
  the break between declaration and execution.

- When the legacy ppp is removed from the build chain, remove the sms$ignore
  region being inserted by use(), which is only an interim shim to keep legacy
  ppp from freaking out.

- declare() is naive. What about declaring an array with the same type as an
  already-declared scalar? Need more flexibility...

- Error needed when compare_var variable is not distributed or no mod info

- Remove HACK from SMS_Compare_Var::translate() when modules are being loaded
  into env. No sense in looking up env information for use'd variables.

- WHERE may need (automatic?) parallel treatment.

- Are distributed array assignments e.g.
    !sms$distribute (dh,1) begin
    integer::a(100)
    !sms$distribute end
    a=0
  supported?

- Need to check for erroneous placement of executable sms construct in
  declaration section, and vice versa, as compiler will not help with
  this. Maybe this is already being done via grammar.

- Stop tracking kind. Pass only *type* to MPI-calling SMS routines and, in the
  latter, use mpi_sizeof() + mpi_type_match_size() in the library to make a
  run-time determination of MPI type to use. Get rid of related kind() methods
  in fortran.rb.

- Check for and clean up any unused rules (especially sms_* rules)

- It might be better to prefix in-class method calls with 'self.' for clarity.

- Why does sms$parallel require positional variable lists, while sms$to_local
  requires numbered lists? This should be harmonized. The latter is better.

- rule variable is broken: See parse tree for program 'i=1\nend'. 'i' is parsed
  as data_ref. It seems that some mechanism to differentiate between user-
  defined and intrinsic types is needed. Also, probably user-defined type
  information  needs to be in the environment, written to .sms mod files, etc.

- Structure constructor recognition is broken, is parsed as function reference.
  See t0151. May also be related to need to track, store, load user-defined type
  info.

- Make implicit none mandatory! Parsing is weird w/o it.

- write-stmt seems to parse wrong, too: 'write' recognized as Data_Ref.

- Change all 'print *' to print/write with format list in tests. Otherwise,
  output may vary with processor (gfortran, ifort, etc.).

- translate() on SMS_Unstructured_Grid cannot possibly be correct in the general
  case, right?

- Get rid of @@distribute, @@parallel et al and use env[:distribute] etc.? The
  way env stack changes may be a problem, e.g. distribute begin/end causes an
  env stack push/pop, so distribute info for a variable declared in that block
  isn't available outside the block, while when it is added to @@distribute, it
  always is.

- Can we get rid of leading underscores in key names e.g. _explicit ?

- Add output to no-output tests to make sure code is not deleted in translation
  (e.g. reveiw t0160 changes)

- Server mode more suitable for running under JRuby? i.e. clients specify input
  filenames & arguments, worker thread (process) does translation. Could
  eliminate JRuby startup overhead issues.

- Sort envfile output for easy xxdiff comparison.

- Does the envfile from a module that uses another module contain the info from
  the other module? Should it?

- When sms$ignore is gone, reconsider places where 'rule directive' can apply in
  non-SMS grammar. Currently, to allow for a Fortran-only parser that still
  accepts SMS directives that appear in 'weird' places (like sms$ignore
  directives that appear outside any declarative or executable context),
  'directive' appears in rule positions where it should not eventually be
  necessary.

- After replacing an element or statement, walk up tree replacing text_value
  with new version while ancestor text_value = *old* replaced node's text_value?

- Better vertical whitespace in output (e.g. before & after functions and sub-
  routines -- maybe all blocks?)

- IIRC, parsing of allocate_object is broken, in that the variable_name option
  (2nd choice) will never be chosen because structure_component always matches.
  Need some more sophisticated logic...

- Should derived types provided by modules appear in .env files (probably!), and
  how?

- Fortran#replace_statements (plural) may be problematic (i.e. it might modify
  the tree in unsound ways). It may be better to use the block_do_construct
  trick, replacing a single statement.

- Fortran#declare needs to insert new declarations at the *bottom* of the decl
  section, not at the top, so that declare() calls can be made, intuitively, in
  the required order.

- .env file does not contain items added during translation, e.g.
  module_decomp.env does not even *exist*, much less contain the items added
  during translation.

- In translator.rb, think about 'opts' and what is actually optional. Move
  requirements into the mandatory argslist.

- Does pppts in server mode adequately indicate the failed test?

- To make all of this more useful, build an AST from the parse tree. Then, do
  translations on and produce final output from the AST.

- Make a single method for complaining about not-found-in-environment symbols
  and explaining what the cause & remedy might be.

- Reformulate distribute being/end as distribute region.

- In SMS_Create_Decomp#translate, merge multiple 1..3 loops. They are as they
  are now to aid in textual comparison to legacy ppp.

- SMS_Create_Decomp#translate is only valid for one decomposed dimension. Extend
  it to handle three.